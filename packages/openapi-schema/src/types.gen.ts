// This file is auto-generated by @hey-api/openapi-ts

export type ExtractVariablesRequest = {
  /**
   * Natural language prompt describing the desired functionality
   */
  prompt: string;
  /**
   * Canvas ID to retrieve existing variable context and content
   */
  canvasId: string;
  /**
   * Processing mode for variable extraction:
   * - direct: Directly update Canvas variables and return results
   * - candidate: Return candidate solutions for user selection
   *
   */
  mode: 'direct' | 'candidate';
  /**
   * Optional session ID for direct mode to check for existing candidate records.
   * When provided in direct mode, the system will check if there are
   * unapplied candidate records for this session.
   *
   */
  sessionId?: string;
};

/**
 * Processing mode for variable extraction:
 * - direct: Directly update Canvas variables and return results
 * - candidate: Return candidate solutions for user selection
 *
 */
export type mode = 'direct' | 'candidate';

/**
 * Processing mode for variable extraction:
 * - direct: Directly update Canvas variables and return results
 * - candidate: Return candidate solutions for user selection
 *
 */
export const mode = {
  DIRECT: 'direct',
  CANDIDATE: 'candidate',
} as const;

export type VariableExtractionResult = {
  /**
   * Original natural language prompt from user input
   */
  originalPrompt: string;
  /**
   * Processed prompt with variable references embedded.
   * Variables are represented using handlebars syntax (e.g., {{variableName}}).
   *
   */
  processedPrompt: string;
  /**
   * List of extracted workflow variables
   */
  variables: Array<WorkflowVariable>;
  /**
   * List of variables that were reused from existing context
   */
  reusedVariables: Array<VariableReuse>;
  /**
   * Session ID for candidate mode responses.
   * This ID can be used in subsequent direct mode requests
   * to apply the selected candidate solution.
   *
   */
  sessionId?: string;
  /**
   * Confidence score for the extraction (0.0 to 1.0)
   */
  extractionConfidence?: number;
};

/**
 * Information about variables reused from existing context
 */
export type VariableReuse = {
  /**
   * Text in the prompt that triggered variable reuse detection
   */
  detectedText: string;
  /**
   * Name of the existing variable that was reused
   */
  reusedVariableName: string;
  /**
   * Confidence score for the reuse detection (0.0 to 1.0)
   */
  confidence: number;
  /**
   * Explanation of why this variable was reused
   */
  reason: string;
};

/**
 * MCP Server type
 */
export type McpServerType = 'sse' | 'streamable' | 'stdio';

/**
 * MCP Server type
 */
export const McpServerType = {
  SSE: 'sse',
  STREAMABLE: 'streamable',
  STDIO: 'stdio',
} as const;

export type McpServerDTO = {
  /**
   * MCP server name
   */
  name: string;
  type: McpServerType;
  /**
   * MCP server URL (for sse and streamable types)
   */
  url?: string;
  /**
   * Command to execute (for stdio type)
   */
  command?: string;
  /**
   * Command arguments (for stdio type)
   */
  args?: Array<string>;
  /**
   * Environment variables (for stdio type)
   */
  env?: {
    [key: string]: string;
  };
  /**
   * HTTP headers (for sse and streamable types)
   */
  headers?: {
    [key: string]: string;
  };
  /**
   * Reconnection configuration
   */
  reconnect?: {
    /**
     * Whether reconnection is enabled
     */
    enabled?: boolean;
    /**
     * Maximum number of reconnection attempts
     */
    maxAttempts?: number;
    /**
     * Delay between reconnection attempts in milliseconds
     */
    delayMs?: number;
  };
  /**
   * Additional configuration
   */
  config?: {
    [key: string]: unknown;
  };
  /**
   * Whether the MCP server is enabled
   */
  enabled: boolean;
  /**
   * Whether the MCP server is global
   */
  isGlobal: boolean;
  /**
   * MCP server creation time
   */
  createdAt?: string;
  /**
   * MCP server update time
   */
  updatedAt?: string;
};

export type ListMcpServersResponse = BaseResponse & {
  data?: Array<McpServerDTO>;
};

export type UpsertMcpServerRequest = {
  /**
   * MCP server name
   */
  name: string;
  /**
   * Original MCP server name for update
   */
  originalName?: string;
  type: McpServerType;
  /**
   * MCP server URL (required for sse and streamable types)
   */
  url?: string;
  /**
   * Command to execute (required for stdio type)
   */
  command?: string;
  /**
   * Command arguments (required for stdio type)
   */
  args?: Array<string>;
  /**
   * Environment variables (for stdio type)
   */
  env?: {
    [key: string]: string;
  };
  /**
   * HTTP headers (for sse and streamable types)
   */
  headers?: {
    [key: string]: string;
  };
  /**
   * Reconnection configuration
   */
  reconnect?: {
    /**
     * Whether reconnection is enabled
     */
    enabled?: boolean;
    /**
     * Maximum number of reconnection attempts
     */
    maxAttempts?: number;
    /**
     * Delay between reconnection attempts in milliseconds
     */
    delayMs?: number;
  };
  /**
   * Additional configuration
   */
  config?: {
    [key: string]: unknown;
  };
  /**
   * Whether the MCP server is enabled
   */
  enabled?: boolean;
};

export type UpsertMcpServerResponse = BaseResponse & {
  data?: McpServerDTO;
};

export type DeleteMcpServerRequest = {
  /**
   * MCP name to delete
   */
  name: string;
};

export type McpServerTool = {
  /**
   * Tool name
   */
  name: string;
  /**
   * Tool description
   */
  description: string;
};

export type ValidateMcpServerResponse = BaseResponse & {
  data?: Array<McpServerTool>;
};

export type DeleteMcpServerResponse = BaseResponse;

/**
 * Refly user, used as JWT payload
 */
export type User = {
  /**
   * UID
   */
  uid: string;
  /**
   * Email
   */
  email?: string;
};

/**
 * Auth type
 */
export type AuthType = 'email' | 'oauth';

/**
 * Auth type
 */
export const AuthType = {
  EMAIL: 'email',
  OAUTH: 'oauth',
} as const;

/**
 * Auth account
 */
export type Account = {
  /**
   * Auth type
   */
  type: AuthType;
  /**
   * Provider
   */
  provider: string;
  /**
   * Auth scope
   */
  scope?: Array<string>;
  /**
   * Provider account ID
   */
  providerAccountId: string;
};

/**
 * List auth accounts response
 */
export type ListAccountsResponse = BaseResponse & {
  /**
   * List of auth accounts
   */
  data?: Array<Account>;
};

/**
 * Check tool OAuth status response
 */
export type CheckToolOAuthStatusResponse = BaseResponse & {
  /**
   * OAuth status information
   */
  data?: {
    /**
     * Whether user has sufficient OAuth authorization
     */
    authorized?: boolean;
    /**
     * OAuth provider
     */
    provider?: string;
    /**
     * Required OAuth scopes
     */
    scope?: Array<string>;
  };
};

/**
 * Refly user in shared entity
 */
export type ShareUser = {
  /**
   * UID
   */
  uid: string;
  /**
   * User name
   */
  name?: string;
  /**
   * User nickname
   */
  nickname?: string;
  /**
   * User creation time
   */
  createdAt?: string;
  /**
   * User avatar
   */
  avatar?: string;
};

/**
 * List order
 */
export type ListOrder = 'creationAsc' | 'creationDesc' | 'updationAsc' | 'updationDesc';

/**
 * List order
 */
export const ListOrder = {
  CREATION_ASC: 'creationAsc',
  CREATION_DESC: 'creationDesc',
  UPDATION_ASC: 'updationAsc',
  UPDATION_DESC: 'updationDesc',
} as const;

/**
 * Canvas status
 */
export type CanvasStatus = 'ready' | 'duplicating' | 'duplicate_failed';

/**
 * Canvas status
 */
export const CanvasStatus = {
  READY: 'ready',
  DUPLICATING: 'duplicating',
  DUPLICATE_FAILED: 'duplicate_failed',
} as const;

export type Canvas = {
  /**
   * Canvas ID
   */
  canvasId: string;
  /**
   * Canvas title
   */
  title: string;
  /**
   * Whether this canvas is read-only
   */
  readOnly?: boolean;
  /**
   * Canvas status
   */
  status?: CanvasStatus;
  /**
   * Canvas owner
   */
  owner?: ShareUser;
  /**
   * Canvas share record
   */
  shareRecord?: ShareRecord;
  /**
   * Canvas workflow app
   */
  workflowApp?: WorkflowApp;
  /**
   * Used toolsets in the canvas
   */
  usedToolsets?: Array<GenericToolset>;
  /**
   * Minimap URL
   */
  minimapUrl?: string;
  /**
   * Minimap storage key
   */
  minimapStorageKey?: string;
  /**
   * Workflow schedule configuration
   */
  schedule?: WorkflowSchedule;
  /**
   * Canvas creation time
   */
  createdAt: string;
  /**
   * Canvas update time
   */
  updatedAt: string;
};

export type WorkflowSchedule = {
  /**
   * Schedule ID
   */
  scheduleId?: string;
  /**
   * User ID
   */
  uid?: string;
  /**
   * Canvas ID
   */
  canvasId?: string;
  /**
   * Schedule name
   */
  name?: string;
  /**
   * Whether the schedule is enabled
   */
  isEnabled?: boolean;
  /**
   * Cron expression
   */
  cronExpression?: string;
  /**
   * Schedule config JSON (type, time, weekdays, monthDays)
   */
  scheduleConfig?: string;
  /**
   * Timezone
   */
  timezone?: string;
  /**
   * Next run time
   */
  nextRunAt?: string | null;
  /**
   * Last run time
   */
  lastRunAt?: string | null;
  /**
   * Creation time
   */
  createdAt?: string;
  /**
   * Update time
   */
  updatedAt?: string;
  /**
   * Deletion time
   */
  deletedAt?: string | null;
};

export type CreateScheduleRequest = {
  /**
   * Canvas ID to schedule
   */
  canvasId: string;
  /**
   * Schedule name
   */
  name: string;
  /**
   * Cron expression for scheduling
   */
  cronExpression: string;
  /**
   * Schedule configuration JSON
   */
  scheduleConfig: string;
  /**
   * Timezone for schedule execution
   */
  timezone?: string;
  /**
   * Whether the schedule is enabled
   */
  isEnabled?: boolean;
};

export type CreateScheduleResponse = {
  /**
   * Whether the operation was successful
   */
  success?: boolean;
  data?: WorkflowSchedule;
  /**
   * Response message
   */
  message?: string;
};

export type UpdateScheduleRequest = {
  /**
   * Schedule ID to update
   */
  scheduleId: string;
  /**
   * Schedule name
   */
  name?: string;
  /**
   * Cron expression for scheduling
   */
  cronExpression?: string;
  /**
   * Schedule configuration JSON
   */
  scheduleConfig?: string;
  /**
   * Timezone for schedule execution
   */
  timezone?: string;
  /**
   * Whether the schedule is enabled
   */
  isEnabled?: boolean;
};

export type UpdateScheduleResponse = {
  /**
   * Whether the operation was successful
   */
  success?: boolean;
  data?: WorkflowSchedule;
  /**
   * Response message
   */
  message?: string;
};

export type DeleteScheduleRequest = {
  /**
   * Schedule ID to delete
   */
  scheduleId: string;
};

export type DeleteScheduleResponse = {
  /**
   * Whether the operation was successful
   */
  success?: boolean;
  data?: WorkflowSchedule;
  /**
   * Response message
   */
  message?: string;
};

export type ListSchedulesRequest = {
  /**
   * Canvas ID to filter schedules
   */
  canvasId?: string;
  /**
   * Page number for pagination
   */
  page?: number;
  /**
   * Number of items per page
   */
  pageSize?: number;
};

export type ListSchedulesResponse = {
  /**
   * Whether the operation was successful
   */
  success?: boolean;
  data?: {
    /**
     * Total number of schedules
     */
    total?: number;
    /**
     * Current page number
     */
    page?: number;
    /**
     * Number of items per page
     */
    pageSize?: number;
    /**
     * List of schedules
     */
    items?: Array<WorkflowSchedule>;
  };
};

export type GetScheduleDetailRequest = {
  /**
   * Schedule ID to get details for
   */
  scheduleId: string;
};

export type GetScheduleDetailResponse = {
  /**
   * Whether the operation was successful
   */
  success?: boolean;
  data?: WorkflowSchedule;
  /**
   * Response message
   */
  message?: string;
};

export type WorkflowScheduleRecord = {
  /**
   * Schedule record ID
   */
  scheduleRecordId?: string;
  /**
   * Schedule ID
   */
  scheduleId?: string;
  /**
   * User ID
   */
  uid?: string;
  /**
   * Source canvas ID (template)
   */
  sourceCanvasId?: string;
  /**
   * Execution canvas ID
   */
  canvasId?: string;
  /**
   * Workflow execution ID
   */
  workflowExecutionId?: string;
  /**
   * Workflow title
   */
  workflowTitle?: string;
  /**
   * Execution status
   */
  status?: 'scheduled' | 'pending' | 'processing' | 'running' | 'success' | 'failed' | 'skipped';
  /**
   * Scheduled execution time
   */
  scheduledAt?: string;
  /**
   * Actual trigger time
   */
  triggeredAt?: string;
  /**
   * Execution completion time
   */
  completedAt?: string | null;
  /**
   * Execution priority
   */
  priority?: number;
  /**
   * Credit used for execution
   */
  creditUsed?: number;
  /**
   * Failure reason if failed
   */
  failureReason?: string | null;
  /**
   * Detailed error information
   */
  errorDetails?: string | null;
  /**
   * JSON string of tools used
   */
  usedTools?: string | null;
  /**
   * Canvas snapshot storage key
   */
  snapshotStorageKey?: string | null;
  /**
   * Record creation time
   */
  createdAt?: string;
  /**
   * Record update time
   */
  updatedAt?: string;
};

/**
 * Execution status
 */
export type status =
  | 'scheduled'
  | 'pending'
  | 'processing'
  | 'running'
  | 'success'
  | 'failed'
  | 'skipped';

/**
 * Execution status
 */
export const status = {
  SCHEDULED: 'scheduled',
  PENDING: 'pending',
  PROCESSING: 'processing',
  RUNNING: 'running',
  SUCCESS: 'success',
  FAILED: 'failed',
  SKIPPED: 'skipped',
} as const;

export type GetScheduleRecordsRequest = {
  /**
   * Schedule ID
   */
  scheduleId: string;
  /**
   * Page number for pagination
   */
  page?: number;
  /**
   * Number of items per page
   */
  pageSize?: number;
};

export type GetScheduleRecordsResponse = {
  /**
   * Whether the operation was successful
   */
  success?: boolean;
  data?: {
    /**
     * Total number of records
     */
    total?: number;
    /**
     * Current page number
     */
    page?: number;
    /**
     * Number of items per page
     */
    pageSize?: number;
    /**
     * List of schedule records
     */
    items?: Array<WorkflowScheduleRecord>;
  };
};

export type ListAllScheduleRecordsRequest = {
  /**
   * Page number for pagination
   */
  page?: number;
  /**
   * Number of items per page
   */
  pageSize?: number;
  executionStatus?: ScheduleRecordExecutionStatus;
  triggerType?: ScheduleRecordTriggerType;
  /**
   * Search keyword for workflow title
   */
  keyword?: string;
  /**
   * Filter by tools used
   */
  tools?: Array<string>;
  /**
   * Filter by canvas ID
   */
  canvasId?: string;
};

/**
 * Filter by execution status
 */
export type ScheduleRecordExecutionStatus =
  | 'scheduled'
  | 'pending'
  | 'processing'
  | 'running'
  | 'success'
  | 'failed';

/**
 * Filter by execution status
 */
export const ScheduleRecordExecutionStatus = {
  SCHEDULED: 'scheduled',
  PENDING: 'pending',
  PROCESSING: 'processing',
  RUNNING: 'running',
  SUCCESS: 'success',
  FAILED: 'failed',
} as const;

/**
 * Filter by trigger type
 */
export type ScheduleRecordTriggerType = 'schedule' | 'webhook' | 'api';

/**
 * Filter by trigger type
 */
export const ScheduleRecordTriggerType = {
  SCHEDULE: 'schedule',
  WEBHOOK: 'webhook',
  API: 'api',
} as const;

export type ListAllScheduleRecordsResponse = {
  /**
   * Whether the operation was successful
   */
  success?: boolean;
  data?: {
    /**
     * Total number of records
     */
    total?: number;
    /**
     * Current page number
     */
    page?: number;
    /**
     * Number of items per page
     */
    pageSize?: number;
    /**
     * List of schedule records with schedule names
     */
    items?: Array<
      WorkflowScheduleRecord & {
        /**
         * Schedule name
         */
        scheduleName?: string;
      }
    >;
  };
};

export type GetAvailableToolsResponse = {
  /**
   * Whether the operation was successful
   */
  success?: boolean;
  /**
   * List of available tools
   */
  data?: Array<{
    /**
     * Tool ID
     */
    id?: string;
    /**
     * Tool name
     */
    name?: string;
  }>;
};

export type GetScheduleRecordDetailRequest = {
  /**
   * Schedule record ID
   */
  scheduleRecordId: string;
};

export type GetScheduleRecordDetailResponse = {
  /**
   * Whether the operation was successful
   */
  success?: boolean;
  data?: WorkflowScheduleRecord & {
    /**
     * Schedule name
     */
    scheduleName?: string;
  };
};

export type GetRecordSnapshotRequest = {
  /**
   * Schedule record ID
   */
  scheduleRecordId: string;
};

export type GetRecordSnapshotResponse = {
  /**
   * Whether the operation was successful
   */
  success?: boolean;
  /**
   * Canvas snapshot data (JSON object)
   */
  data?: {
    [key: string]: unknown;
  };
};

export type TriggerScheduleManuallyRequest = {
  /**
   * Schedule ID to trigger
   */
  scheduleId: string;
};

export type TriggerScheduleManuallyResponse = {
  /**
   * Whether the operation was successful
   */
  success?: boolean;
  data?: {
    /**
     * Schedule ID
     */
    scheduleId?: string;
    /**
     * Created schedule record ID
     */
    scheduleRecordId?: string;
    /**
     * Trigger time
     */
    triggeredAt?: string;
    /**
     * Execution priority
     */
    priority?: number;
  };
};

export type RetryScheduleRecordRequest = {
  /**
   * Schedule record ID to retry
   */
  scheduleRecordId: string;
};

export type RetryScheduleRecordResponse = {
  /**
   * Whether the operation was successful
   */
  success?: boolean;
  data?: {
    /**
     * Schedule record ID
     */
    scheduleRecordId?: string;
    /**
     * Schedule ID
     */
    scheduleId?: string;
    /**
     * New status (pending)
     */
    status?: string;
    /**
     * Execution priority
     */
    priority?: number;
  };
};

export type CanvasTemplateCategory = {
  /**
   * Category ID
   */
  categoryId: string;
  /**
   * Category name
   */
  name: string;
  /**
   * Category label dictionary
   */
  labelDict: {
    [key: string]: string;
  };
  /**
   * Category description dictionary
   */
  descriptionDict: {
    [key: string]: string;
  };
};

export type CanvasTemplate = {
  /**
   * Canvas template ID
   */
  templateId: string;
  /**
   * Share ID
   */
  shareId: string;
  /**
   * Share user
   */
  shareUser?: ShareUser;
  /**
   * Canvas template version
   */
  version?: number;
  /**
   * Canvas template category
   */
  category?: CanvasTemplateCategory;
  /**
   * Canvas template title
   */
  title: string;
  /**
   * Canvas template description
   */
  description: string;
  /**
   * Canvas template language code
   */
  language: string;
  /**
   * Whether this canvas template is featured
   */
  featured?: boolean;
  /**
   * Workflow app ID
   */
  appId?: string;
  /**
   * Canvas template cover image URL
   */
  coverUrl?: string;
  /**
   * Associated workflow app share ID
   */
  appShareId?: string;
  /**
   * Credit usage for running this workflow app
   */
  creditUsage?: number | null;
  /**
   * Canvas template creation time
   */
  createdAt: string;
  /**
   * Canvas template update time
   */
  updatedAt: string;
};

/**
 * Resource metadata
 */
export type ResourceMeta = {
  /**
   * Weblink URL
   */
  url?: string;
  /**
   * Weblink title
   */
  title?: string;
  /**
   * File content type (MIME type)
   */
  contentType?: string;
};

/**
 * Resource type
 */
export type ResourceType =
  | 'weblink'
  | 'text'
  | 'file'
  | 'document'
  | 'image'
  | 'video'
  | 'audio'
  | 'text/plain';

/**
 * Resource type
 */
export const ResourceType = {
  WEBLINK: 'weblink',
  TEXT: 'text',
  FILE: 'file',
  DOCUMENT: 'document',
  IMAGE: 'image',
  VIDEO: 'video',
  AUDIO: 'audio',
  TEXT_PLAIN: 'text/plain',
} as const;

/**
 * Error message for resource indexing
 */
export type IndexError = {
  /**
   * Error type
   */
  type?: 'pageLimitExceeded' | 'unknownError';
  /**
   * Error metadata
   */
  metadata?: {
    [key: string]: unknown;
  };
};

/**
 * Error type
 */
export type type = 'pageLimitExceeded' | 'unknownError';

/**
 * Error type
 */
export const type = {
  PAGE_LIMIT_EXCEEDED: 'pageLimitExceeded',
  UNKNOWN_ERROR: 'unknownError',
} as const;

export type Resource = {
  /**
   * Resource ID (empty if it's external)
   */
  resourceId: string;
  /**
   * Resource type
   */
  resourceType: ResourceType;
  /**
   * Resource title
   */
  title: string;
  /**
   * Resource metadata
   */
  data?: ResourceMeta;
  /**
   * Resource index status
   */
  indexStatus?: IndexStatus;
  /**
   * Error message for resource indexing
   */
  indexError?: IndexError;
  /**
   * Resource storage key
   */
  storageKey?: string;
  /**
   * Resource storage size (in bytes)
   */
  storageSize?: string;
  /**
   * Resource vector storage size (in bytes)
   */
  vectorSize?: string;
  /**
   * Raw file storage key (used to download the file)
   */
  rawFileKey?: string;
  /**
   * Canvas ID to bind with
   */
  canvasId?: string;
  /**
   * Resource creation time
   */
  createdAt?: string;
  /**
   * Resource update time
   */
  updatedAt?: string;
  /**
   * Preview content for this resource
   */
  contentPreview?: string;
  /**
   * Share ID
   */
  shareId?: string;
  /**
   * Document content for this resource (only returned in getResourceDetail API)
   */
  content?: string;
  /**
   * Download URL for this resource (for file type only)
   */
  downloadURL?: string;
  /**
   * Publicly accessible URL for this resource (file type only)
   */
  publicURL?: string;
};

export type Document = {
  /**
   * Document ID
   */
  docId: string;
  /**
   * Document title
   */
  title: string;
  /**
   * Document content preview
   */
  contentPreview?: string;
  /**
   * Full document content (only returned in detail api)
   */
  content?: string;
  /**
   * Whether this document is read-only
   */
  readOnly?: boolean;
  /**
   * Canvas ID to bind with
   */
  canvasId?: string;
  /**
   * Document creation time
   */
  createdAt?: string;
  /**
   * Document update time
   */
  updatedAt?: string;
};

/**
 * Entity type
 */
export type EntityType =
  | 'document'
  | 'resource'
  | 'canvas'
  | 'share'
  | 'user'
  | 'project'
  | 'skillResponse'
  | 'codeArtifact'
  | 'page'
  | 'mediaResult'
  | 'workflowApp'
  | 'driveFile';

/**
 * Entity type
 */
export const EntityType = {
  DOCUMENT: 'document',
  RESOURCE: 'resource',
  CANVAS: 'canvas',
  SHARE: 'share',
  USER: 'user',
  PROJECT: 'project',
  SKILL_RESPONSE: 'skillResponse',
  CODE_ARTIFACT: 'codeArtifact',
  PAGE: 'page',
  MEDIA_RESULT: 'mediaResult',
  WORKFLOW_APP: 'workflowApp',
  DRIVE_FILE: 'driveFile',
} as const;

/**
 * Entity
 */
export type Entity = {
  /**
   * Entity ID
   */
  entityId?: string;
  /**
   * Entity type
   */
  entityType?: EntityType;
};

/**
 * Data input mode
 */
export type InputMode =
  | 'text'
  | 'textarea'
  | 'number'
  | 'select'
  | 'multiSelect'
  | 'radio'
  | 'switch';

/**
 * Data input mode
 */
export const InputMode = {
  TEXT: 'text',
  TEXTAREA: 'textarea',
  NUMBER: 'number',
  SELECT: 'select',
  MULTI_SELECT: 'multiSelect',
  RADIO: 'radio',
  SWITCH: 'switch',
} as const;

/**
 * Config scope
 */
export type ConfigScope = Array<'runtime' | 'template'>;

/**
 * Select option
 */
export type SelectOption = {
  /**
   * Option value
   */
  value: string;
  /**
   * Option label (key is locale, value is label)
   */
  labelDict?: {
    [key: string]: string;
  };
  /**
   * Whether this option is disabled
   */
  disabled?: boolean;
};

/**
 * Dynamic config item
 */
export type DynamicConfigItem = {
  /**
   * Config key
   */
  key: string;
  /**
   * Config input mode
   */
  inputMode: InputMode;
  /**
   * Specifies whether this config is required
   */
  required?: boolean;
  /**
   * Config label (key is locale, value is label)
   */
  labelDict: {
    [key: string]: string;
  };
  /**
   * Config description (key is locale, value is description)
   */
  descriptionDict: {
    [key: string]: string;
  };
  /**
   * Default value
   */
  defaultValue?: number | string | boolean | Array<string>;
  /**
   * Config options
   */
  options?: Array<SelectOption>;
  /**
   * Additional input properties
   */
  inputProps?: {
    /**
     * Minimum value for number input
     */
    min?: number;
    /**
     * Maximum value for number input
     */
    max?: number;
    /**
     * Step value for number input
     */
    step?: number;
    /**
     * Decimal precision for number input
     */
    precision?: number;
    /**
     * Whether to display as password input
     */
    passwordType?: boolean;
  };
};

/**
 * Dynamic config value
 */
export type DynamicConfigValue = {
  /**
   * Config key label
   */
  label: string;
  /**
   * Config value
   */
  value:
    | string
    | number
    | boolean
    | Array<string>
    | {
        [key: string]: unknown;
      };
  /**
   * Config display value
   */
  displayValue: string;
  /**
   * The contexts in which the requirement applies
   */
  configScope?: ConfigScope;
};

/**
 * Skill template config schema
 */
export type SkillTemplateConfigDefinition = {
  /**
   * Config items
   */
  items: Array<DynamicConfigItem>;
};

/**
 * Icon type
 */
export type IconType = 'emoji' | 'image';

/**
 * Icon type
 */
export const IconType = {
  EMOJI: 'emoji',
  IMAGE: 'image',
} as const;

/**
 * Icon
 */
export type Icon = {
  /**
   * Icon type
   */
  type: IconType;
  /**
   * Icon value
   */
  value: string;
};

/**
 * Skill metadata
 */
export type SkillMeta = {
  /**
   * Skill name
   */
  name: string;
  /**
   * Skill icon
   */
  icon?: Icon;
};

/**
 * Action metadata
 */
export type ActionMeta = {
  /**
   * Action type
   */
  type?: ActionType;
  /**
   * Action name
   */
  name: string;
  /**
   * Action icon
   */
  icon?: Icon;
};

/**
 * Skill runtime config
 */
export type SkillRuntimeConfig = {
  /**
   * Whether to disable link parsing for input query
   */
  disableLinkParsing?: boolean;
  /**
   * Whether to enable knowledge base for input query
   */
  enabledKnowledgeBase?: boolean;
};

/**
 * Skill template config (key is config item key, value is config value)
 */
export type SkillTemplateConfig = {
  [key: string]: DynamicConfigValue;
};

/**
 * Action config (key is config item key, value is config value)
 */
export type ActionConfig = {
  [key: string]: DynamicConfigValue;
};

/**
 * Source metadata
 */
export type SourceMeta = {
  /**
   * Source URL
   * @deprecated
   */
  source?: string;
  /**
   * Source title
   * @deprecated
   */
  title?: string;
  /**
   * Source publish timesss
   */
  publishedTime?: string;
  /**
   * Related entity ID
   */
  entityId?: string;
  /**
   * Related entity type
   */
  entityType?: string;
  /**
   * Original locale
   */
  originalLocale?: string;
  /**
   * Translated display locale
   */
  translatedDisplayLocale?: string;
  /**
   * Whether the source is translated
   */
  isTranslated?: boolean;
  /**
   * Original query
   */
  originalQuery?: string;
  /**
   * Translated query
   */
  translatedQuery?: string;
  /**
   * Source type
   */
  sourceType?: 'webSearch' | 'library';
};

/**
 * Source type
 */
export type sourceType = 'webSearch' | 'library';

/**
 * Source type
 */
export const sourceType = {
  WEB_SEARCH: 'webSearch',
  LIBRARY: 'library',
} as const;

/**
 * Source selection
 */
export type SourceSelection = {
  /**
   * Selected xPath
   * @deprecated
   */
  xPath?: string;
  /**
   * Selected content
   */
  content: string;
  /**
   * Selection type
   */
  type: 'text' | 'table' | 'link' | 'image' | 'video' | 'audio';
};

/**
 * Selection type
 */
export type type2 = 'text' | 'table' | 'link' | 'image' | 'video' | 'audio';

/**
 * Selection type
 */
export const type2 = {
  TEXT: 'text',
  TABLE: 'table',
  LINK: 'link',
  IMAGE: 'image',
  VIDEO: 'video',
  AUDIO: 'audio',
} as const;

/**
 * Source of the message
 */
export type Source = {
  /**
   * Source URL
   */
  url?: string;
  /**
   * Source title
   */
  title?: string;
  /**
   * Source content
   */
  pageContent: string;
  /**
   * Relativity score
   */
  score?: number;
  /**
   * Source metadata
   */
  metadata?: SourceMeta;
  /**
   * Source selections
   */
  selections?: Array<SourceSelection>;
};

/**
 * Search step
 */
export type SearchStep = {
  /**
   * Search step name
   */
  step?: string;
  /**
   * Step duration in milliseconds
   */
  duration?: number;
  /**
   * Step-specific result data
   */
  result?: {
    [key: string]: unknown;
  };
};

/**
 * Model tier
 */
export type ModelTier = 't1' | 't2' | 'free';

/**
 * Model tier
 */
export const ModelTier = {
  T1: 't1',
  T2: 't2',
  FREE: 'free',
} as const;

/**
 * Token usage item
 */
export type TokenUsageItem = {
  /**
   * Model name
   */
  modelName: string;
  /**
   * Model provider
   */
  modelProvider: string;
  /**
   * Model label
   */
  modelLabel?: string;
  /**
   * Input tokens
   */
  inputTokens: number;
  /**
   * Output tokens
   */
  outputTokens: number;
  /**
   * Cache read tokens
   */
  cacheReadTokens?: number;
  /**
   * Cache write tokens
   */
  cacheWriteTokens?: number;
  /**
   * Provider item ID
   */
  providerItemId?: string;
  /**
   * Model tier
   * @deprecated
   */
  tier?: string;
  /**
   * Original model ID before routing (e.g., 'auto')
   */
  originalModelId?: string;
  /**
   * Complete model routing metadata (JSON)
   */
  modelRoutedData?: {
    /**
     * Whether this request was routed
     */
    isRouted?: boolean;
    /**
     * Original provider item ID before routing
     */
    originalItemId?: string;
    /**
     * Original model ID (e.g., 'auto')
     */
    originalModelId?: string;
    /**
     * Original model provider name
     */
    originalProvider?: string;
    /**
     * Original model name/label for display
     */
    originalModelName?: string;
    /**
     * Routing timestamp
     */
    routedAt?: string;
    /**
     * Routing strategy used (e.g., 'auto', 'load_balance', 'region')
     */
    routingStrategy?: string;
  };
};

/**
 * Action status
 */
export type ActionStatus = 'init' | 'waiting' | 'executing' | 'finish' | 'failed';

/**
 * Action status
 */
export const ActionStatus = {
  INIT: 'init',
  WAITING: 'waiting',
  EXECUTING: 'executing',
  FINISH: 'finish',
  FAILED: 'failed',
} as const;

/**
 * Action error type
 */
export type ActionErrorType = 'systemError' | 'userAbort';

/**
 * Action error type
 */
export const ActionErrorType = {
  SYSTEM_ERROR: 'systemError',
  USER_ABORT: 'userAbort',
} as const;

/**
 * Artifact type
 */
export type ArtifactType = 'document' | 'codeArtifact' | 'image' | 'video' | 'audio';

/**
 * Artifact type
 */
export const ArtifactType = {
  DOCUMENT: 'document',
  CODE_ARTIFACT: 'codeArtifact',
  IMAGE: 'image',
  VIDEO: 'video',
  AUDIO: 'audio',
} as const;

/**
 * Artifact status
 */
export type ArtifactStatus = 'waiting' | 'generating' | 'finish' | 'failed';

/**
 * Artifact status
 */
export const ArtifactStatus = {
  WAITING: 'waiting',
  GENERATING: 'generating',
  FINISH: 'finish',
  FAILED: 'failed',
} as const;

/**
 * Artifact
 */
export type Artifact = {
  /**
   * Artifact type
   */
  type: ArtifactType;
  /**
   * Entity ID
   */
  entityId: string;
  /**
   * Artifact title
   */
  title: string;
  /**
   * Artifact status
   */
  status?: ArtifactStatus;
  /**
   * Artifact content
   */
  content?: string;
  /**
   * Artifact metadata
   */
  metadata?: {
    [key: string]: unknown;
  };
  /**
   * Artifact creation time
   */
  createdAt?: string;
  /**
   * Artifact update time
   */
  updatedAt?: string;
};

/**
 * Action step metadata
 */
export type ActionStepMeta = {
  /**
   * Step name
   */
  name: string;
};

/**
 * Action log
 */
export type ActionLog = {
  /**
   * Log key
   */
  key: string;
  /**
   * Log title arguments
   */
  titleArgs?: {
    [key: string]: unknown;
  };
  /**
   * Log description arguments
   */
  descriptionArgs?: {
    [key: string]: unknown;
  };
};

/**
 * Action step
 */
export type ActionStep = {
  /**
   * Step name
   */
  name: string;
  /**
   * Step content
   */
  content?: string;
  /**
   * Step reasoning content
   */
  reasoningContent?: string;
  /**
   * Step artifacts
   */
  artifacts?: Array<Artifact>;
  /**
   * Step structured data output
   */
  structuredData?: {
    [key: string]: unknown;
  };
  /**
   * Action step logs
   */
  logs?: Array<ActionLog>;
  /**
   * Token usage
   */
  tokenUsage?: Array<TokenUsageItem>;
  /**
   * Tool calls in this step
   */
  toolCalls?: Array<ToolCallResult>;
};

/**
 * Code artifact type
 */
export type CodeArtifactType =
  | 'application/refly.artifacts.react'
  | 'image/svg+xml'
  | 'application/refly.artifacts.mermaid'
  | 'text/markdown'
  | 'application/refly.artifacts.code'
  | 'text/html'
  | 'application/refly.artifacts.mindmap'
  | 'text/csv'
  | 'application/json'
  | 'text/plain';

/**
 * Code artifact type
 */
export const CodeArtifactType = {
  APPLICATION_REFLY_ARTIFACTS_REACT: 'application/refly.artifacts.react',
  IMAGE_SVG_XML: 'image/svg+xml',
  APPLICATION_REFLY_ARTIFACTS_MERMAID: 'application/refly.artifacts.mermaid',
  TEXT_MARKDOWN: 'text/markdown',
  APPLICATION_REFLY_ARTIFACTS_CODE: 'application/refly.artifacts.code',
  TEXT_HTML: 'text/html',
  APPLICATION_REFLY_ARTIFACTS_MINDMAP: 'application/refly.artifacts.mindmap',
  TEXT_CSV: 'text/csv',
  APPLICATION_JSON: 'application/json',
  TEXT_PLAIN: 'text/plain',
} as const;

/**
 * Code artifact
 */
export type CodeArtifact = {
  /**
   * Artifact type
   */
  type: CodeArtifactType;
  /**
   * Artifact ID
   */
  artifactId: string;
  /**
   * Artifact title
   */
  title: string;
  /**
   * Code artifact content
   */
  content?: string;
  /**
   * Code artifact language
   */
  language?: string;
  /**
   * Action result ID
   */
  resultId?: string;
  /**
   * Action result version
   */
  resultVersion?: number;
  /**
   * Canvas ID to bind with
   */
  canvasId?: string;
  createdAt?: string;
  updatedAt?: string;
};

/**
 * Action message type
 */
export type ActionMessageType = 'ai' | 'tool';

/**
 * Action message type
 */
export const ActionMessageType = {
  AI: 'ai',
  TOOL: 'tool',
} as const;

/**
 * Action message
 */
export type ActionMessage = {
  /**
   * Action message ID
   */
  messageId: string;
  /**
   * Action message type
   */
  type: ActionMessageType;
  /**
   * Action message content
   */
  content?: string;
  /**
   * Action message reasoning content
   */
  reasoningContent?: string;
  /**
   * Action message tool call metadata
   */
  toolCallMeta?: ToolCallMeta;
  /**
   * Action message tool call ID
   */
  toolCallId?: string;
  /**
   * Tool call result
   */
  toolCallResult?: ToolCallResult;
  /**
   * Whether this is a PTC (Programmatic Tool Calling) internal tool call
   */
  isPtc?: boolean;
  /**
   * Action message creation time
   */
  createdAt?: string;
  /**
   * Action message update time
   */
  updatedAt?: string;
};

/**
 * Simplified tool call result for API
 */
export type ToolCallResultViaApi = {
  /**
   * Tool name
   */
  toolName?: string;
  /**
   * Tool input
   */
  input?: {
    [key: string]: unknown;
  };
  /**
   * Tool output
   */
  output?: {
    [key: string]: unknown;
  };
  /**
   * Tool execution error
   */
  error?: string;
  /**
   * Tool execution status
   */
  status?: 'executing' | 'completed' | 'failed';
  /**
   * Tool call creation timestamp
   */
  createdAt?: number;
};

/**
 * Tool execution status
 */
export type status2 = 'executing' | 'completed' | 'failed';

/**
 * Tool execution status
 */
export const status2 = {
  EXECUTING: 'executing',
  COMPLETED: 'completed',
  FAILED: 'failed',
} as const;

/**
 * Simplified action message for API
 */
export type ActionMessageViaApi = {
  /**
   * Action message ID
   */
  messageId: string;
  /**
   * Action message content
   */
  content?: string;
  /**
   * Action message reasoning content
   */
  reasoningContent?: string;
  /**
   * Action message type
   */
  type: ActionMessageType;
};

/**
 * Action result
 */
export type ActionResult = {
  /**
   * Action result ID
   */
  readonly resultId: string;
  /**
   * Action result version
   */
  version?: number;
  /**
   * Action result title
   * @deprecated
   */
  title?: string;
  /**
   * Action input
   */
  input?: SkillInput;
  /**
   * Model tier
   */
  tier?: ModelTier;
  /**
   * Step status
   */
  status?: ActionStatus;
  /**
   * Error type (defaults to systemError when omitted)
   */
  errorType?: ActionErrorType;
  /**
   * Action type
   */
  type?: ActionType;
  /**
   * Selected model
   */
  modelInfo?: ModelInfo;
  /**
   * Actual provider item ID used for execution after routing (e.g. routed from Auto)
   */
  actualProviderItemId?: string;
  /**
   * Whether the action execution was routed from the Auto model
   */
  isAutoModelRouted?: boolean;
  /**
   * Action target type
   */
  targetType?: EntityType;
  /**
   * Action target ID
   */
  targetId?: string;
  /**
   * Action metadata
   */
  actionMeta?: ActionMeta;
  /**
   * Action context
   */
  context?: SkillContext;
  /**
   * Action template config
   * @deprecated
   */
  tplConfig?: SkillTemplateConfig;
  /**
   * Action runtime config
   * @deprecated
   */
  runtimeConfig?: SkillRuntimeConfig;
  /**
   * Action result history
   */
  history?: Array<ActionResult>;
  /**
   * Action steps
   * @deprecated
   */
  steps?: Array<ActionStep>;
  /**
   * Action messages
   */
  messages?: Array<ActionMessage>;
  /**
   * Errors
   */
  errors?: Array<string>;
  /**
   * Action toolsets
   */
  toolsets?: Array<GenericToolset>;
  /**
   * Tool calls during action execution
   */
  toolCalls?: Array<ToolCallResult>;
  /**
   * Files generated by the action
   */
  files?: Array<DriveFile>;
  /**
   * Media generation output URL (for media type actions)
   */
  outputUrl?: string;
  /**
   * Media generation output storage key
   */
  storageKey?: string;
  /**
   * Pilot step ID
   */
  pilotStepId?: string;
  /**
   * Pilot session ID
   */
  pilotSessionId?: string;
  /**
   * Workflow execution ID for workflow context
   */
  workflowExecutionId?: string;
  /**
   * Workflow node execution ID for workflow context
   */
  workflowNodeExecutionId?: string;
  /**
   * Message creation time
   */
  createdAt?: string;
  /**
   * Message update time
   */
  updatedAt?: string;
};

/**
 * Resource index status
 */
export type IndexStatus =
  | 'init'
  | 'wait_parse'
  | 'wait_index'
  | 'finish'
  | 'parse_failed'
  | 'index_failed';

/**
 * Resource index status
 */
export const IndexStatus = {
  INIT: 'init',
  WAIT_PARSE: 'wait_parse',
  WAIT_INDEX: 'wait_index',
  FINISH: 'finish',
  PARSE_FAILED: 'parse_failed',
  INDEX_FAILED: 'index_failed',
} as const;

/**
 * Payment recurring interval
 */
export type SubscriptionInterval = 'monthly' | 'yearly';

/**
 * Payment recurring interval
 */
export const SubscriptionInterval = {
  MONTHLY: 'monthly',
  YEARLY: 'yearly',
} as const;

/**
 * Subscription plan type
 */
export type SubscriptionPlanType = 'free' | 'starter' | 'maker' | 'enterprise' | 'plus' | 'pro';

/**
 * Subscription plan type
 */
export const SubscriptionPlanType = {
  FREE: 'free',
  STARTER: 'starter',
  MAKER: 'maker',
  ENTERPRISE: 'enterprise',
  PLUS: 'plus',
  PRO: 'pro',
} as const;

/**
 * Subscription status
 */
export type SubscriptionStatus =
  | 'active'
  | 'canceled'
  | 'incomplete'
  | 'incomplete_expired'
  | 'past_due'
  | 'paused'
  | 'trialing'
  | 'unpaid';

/**
 * Subscription status
 */
export const SubscriptionStatus = {
  ACTIVE: 'active',
  CANCELED: 'canceled',
  INCOMPLETE: 'incomplete',
  INCOMPLETE_EXPIRED: 'incomplete_expired',
  PAST_DUE: 'past_due',
  PAUSED: 'paused',
  TRIALING: 'trialing',
  UNPAID: 'unpaid',
} as const;

export type Subscription = {
  /**
   * Subscription ID
   */
  subscriptionId: string;
  /**
   * Subscription lookup key
   */
  lookupKey?: string;
  /**
   * Subscription plan type
   */
  planType: SubscriptionPlanType;
  /**
   * Payment recurring interval
   */
  interval?: SubscriptionInterval;
  /**
   * Subscription status
   */
  status: SubscriptionStatus;
  /**
   * Whether the subscription is a trial
   */
  isTrial?: boolean;
  /**
   * Subscription cancel time
   */
  cancelAt?: string;
};

export type TokenUsageMeter = {
  /**
   * Token usage meter ID
   */
  meterId: string;
  /**
   * User ID
   */
  uid: string;
  /**
   * Subscription ID
   */
  subscriptionId?: string;
  /**
   * Token usage meter start time
   */
  startAt: string;
  /**
   * Token usage meter end time
   */
  endAt?: string;
  /**
   * Request count quota (T1)
   */
  t1CountQuota?: number;
  /**
   * Request count used (T1)
   */
  t1CountUsed?: number;
  /**
   * Token quota (T1)
   * @deprecated
   */
  t1TokenQuota: number;
  /**
   * Token used (T1)
   * @deprecated
   */
  t1TokenUsed: number;
  /**
   * Request count quota (T2)
   */
  t2CountQuota?: number;
  /**
   * Request count used (T2)
   */
  t2CountUsed?: number;
  /**
   * Token quota (T2)
   * @deprecated
   */
  t2TokenQuota: number;
  /**
   * Token used (T2)
   * @deprecated
   */
  t2TokenUsed: number;
};

export type StorageUsageMeter = {
  /**
   * Storage usage meter ID
   */
  meterId: string;
  /**
   * User ID
   */
  uid: string;
  /**
   * Subscription ID
   */
  subscriptionId?: string;
  /**
   * File count used
   */
  fileCountUsed?: number;
  /**
   * File count quota
   */
  fileCountQuota?: number;
  /**
   * Object storage quota (in bytes), including resource, canvas and static files
   * @deprecated
   */
  objectStorageQuota: string;
  /**
   * Resource storage size in use (in bytes)
   * @deprecated
   */
  resourceSize: string;
  /**
   * Canvas storage size in use (in bytes)
   * @deprecated
   */
  canvasSize: string;
  /**
   * Static file storage size in use (in bytes)
   * @deprecated
   */
  fileSize: string;
  /**
   * Vector storage quota (in bytes)
   * @deprecated
   */
  vectorStorageQuota: string;
  /**
   * Vector storage size used (in bytes)
   * @deprecated
   */
  vectorStorageUsed: string;
};

export type FileParsingMeter = {
  /**
   * File pages parsed
   */
  pagesParsed: number;
  /**
   * File pages limit
   */
  pagesLimit: number;
  /**
   * File upload limit (in MB)
   */
  fileUploadLimit?: number;
};

/**
 * Operation mode
 */
export type OperationMode = 'mouse' | 'touchpad';

/**
 * Operation mode
 */
export const OperationMode = {
  MOUSE: 'mouse',
  TOUCHPAD: 'touchpad',
} as const;

/**
 * Provider config
 */
export type ProviderConfig = {
  /**
   * Provider ID
   */
  providerId?: string;
  /**
   * Provider key
   */
  providerKey?: string;
};

/**
 * Model usage scene
 */
export type ModelScene =
  | 'chat'
  | 'copilot'
  | 'agent'
  | 'queryAnalysis'
  | 'titleGeneration'
  | 'image'
  | 'video'
  | 'audio';

/**
 * Model usage scene
 */
export const ModelScene = {
  CHAT: 'chat',
  COPILOT: 'copilot',
  AGENT: 'agent',
  QUERY_ANALYSIS: 'queryAnalysis',
  TITLE_GENERATION: 'titleGeneration',
  IMAGE: 'image',
  VIDEO: 'video',
  AUDIO: 'audio',
} as const;

/**
 * Default model config
 */
export type DefaultModelConfig = {
  /**
   * Default chat model to use
   */
  chat?: ProviderItem;
  /**
   * Default copilot model to use
   */
  copilot?: ProviderItem;
  /**
   * Default agent model to use
   */
  agent?: ProviderItem;
  /**
   * Query analysis and context processing model
   */
  queryAnalysis?: ProviderItem;
  /**
   * Title generation model for canvas and documents
   */
  titleGeneration?: ProviderItem;
  /**
   * Default image generation model
   */
  image?: ProviderItem;
  /**
   * Default video generation model
   */
  video?: ProviderItem;
  /**
   * Default audio generation model
   */
  audio?: ProviderItem;
};

/**
 * Provider mode
 */
export type ProviderMode = 'global' | 'custom';

/**
 * Provider mode
 */
export const ProviderMode = {
  GLOBAL: 'global',
  CUSTOM: 'custom',
} as const;

/**
 * User preferences
 */
export type UserPreferences = {
  /**
   * Operation mode
   */
  operationMode?: OperationMode;
  /**
   * Provider mode
   */
  providerMode?: ProviderMode;
  /**
   * Whether to disable hover tutorial
   */
  disableHoverCard?: boolean;
  /**
   * Whether the user has been invited
   */
  hasBeenInvited?: boolean;
  /**
   * Whether the user has filled the survey form
   */
  hasFilledForm?: boolean;
  /**
   * User identity in survey form
   */
  identity?: string;
  /**
   * Whether to require invitation code
   */
  requireInvitationCode?: boolean;
  /**
   * Whether this user needs onboarding
   */
  needOnboarding?: boolean;
  /**
   * Web search config
   */
  webSearch?: ProviderConfig;
  /**
   * URL parsing config
   */
  urlParsing?: ProviderConfig;
  /**
   * PDF parsing config
   */
  pdfParsing?: ProviderConfig;
  /**
   * Default model config
   */
  defaultModel?: DefaultModelConfig;
};

/**
 * Onboarding status
 */
export type OnboardingStatus = 'not_started' | 'skipped' | 'completed';

/**
 * Onboarding status
 */
export const OnboardingStatus = {
  NOT_STARTED: 'not_started',
  SKIPPED: 'skipped',
  COMPLETED: 'completed',
} as const;

export type OnboardingConfig = {
  /**
   * Settings onboarding status
   */
  settings?: OnboardingStatus;
  /**
   * Tour onboarding status
   */
  tour?: OnboardingStatus;
};

export type UserSettings = {
  /**
   * User ID
   */
  uid: string;
  /**
   * User avatar
   */
  avatar: string;
  /**
   * Username (can only contains letters, numbers, and underscores)
   */
  name: string;
  /**
   * User nickname
   */
  nickname?: string;
  /**
   * User email
   */
  email: string;
  /**
   * Whether email is verified
   */
  emailVerified?: boolean;
  /**
   * User UI locale
   */
  uiLocale?: string;
  /**
   * User output locale
   */
  outputLocale?: string;
  /**
   * Stripe customer ID
   */
  customerId?: string;
  /**
   * User subscription
   */
  subscription?: Subscription;
  /**
   * Whether the user has beta access
   */
  hasBetaAccess?: boolean;
  /**
   * User preferences
   */
  preferences?: UserPreferences;
  /**
   * User attributes
   */
  attributes?: {
    [key: string]: unknown;
  };
  /**
   * Onboarding config
   * @deprecated
   */
  onboarding?: OnboardingConfig;
};

/**
 * Auth provider
 */
export type AuthProvider = 'email' | 'google' | 'github' | 'invitation';

/**
 * Auth provider
 */
export const AuthProvider = {
  EMAIL: 'email',
  GOOGLE: 'google',
  GITHUB: 'github',
  INVITATION: 'invitation',
} as const;

export type AuthConfigItem = {
  /**
   * Auth provider
   */
  provider: AuthProvider;
};

export type AuthConfigResponse = BaseResponse & {
  /**
   * Auth providers
   */
  data?: Array<AuthConfigItem>;
  /**
   * Whether Cloudflare Turnstile is enabled
   */
  turnstileEnabled?: boolean;
};

/**
 * Email signup request
 */
export type EmailSignupRequest = {
  /**
   * Email
   */
  email: string;
  /**
   * Password
   */
  password: string;
  /**
   * Cloudflare Turnstile token
   */
  turnstileToken?: string;
};

export type EmailSignupData = {
  /**
   * Verification session ID
   */
  sessionId?: string;
  /**
   * Whether email verification is skipped
   */
  skipVerification?: boolean;
};

export type EmailSignupResponse = BaseResponse & {
  data?: EmailSignupData;
};

/**
 * Verification purpose
 */
export type VerificationPurpose = 'signup' | 'resetPassword';

/**
 * Verification purpose
 */
export const VerificationPurpose = {
  SIGNUP: 'signup',
  RESET_PASSWORD: 'resetPassword',
} as const;

/**
 * Create verification session request
 */
export type CreateVerificationRequest = {
  /**
   * Email
   */
  email: string;
  /**
   * Verification purpose
   */
  purpose: VerificationPurpose;
  /**
   * Password
   */
  password?: string;
};

export type CreateVerificationData = {
  /**
   * Verification session ID
   */
  sessionId?: string;
};

export type CreateVerificationResponse = BaseResponse & {
  data?: CreateVerificationData;
};

/**
 * Resend verification request
 */
export type ResendVerificationRequest = {
  /**
   * Verification session ID
   */
  sessionId: string;
};

/**
 * Check verification code request
 */
export type CheckVerificationRequest = {
  /**
   * Verification session ID
   */
  sessionId: string;
  /**
   * Verification code
   */
  code: string;
};

/**
 * Email login request
 */
export type EmailLoginRequest = {
  /**
   * Email
   */
  email: string;
  /**
   * Password
   */
  password: string;
  /**
   * Cloudflare Turnstile token
   */
  turnstileToken?: string;
};

export type EmailLoginData = {
  /**
   * Access token
   */
  accessToken?: string;
};

export type EmailLoginResponse = BaseResponse & {
  data?: EmailLoginData;
};

/**
 * Create CLI API key request
 */
export type CreateCliApiKeyRequest = {
  /**
   * API key name
   */
  name: string;
  /**
   * API key expiration in days
   */
  expiresInDays?: number;
};

/**
 * Update CLI API key request
 */
export type UpdateCliApiKeyRequest = {
  /**
   * API key name
   */
  name: string;
};

export type CliApiKeyInfo = {
  /**
   * API key ID
   */
  keyId: string;
  /**
   * API key name
   */
  name: string;
  /**
   * API key prefix
   */
  keyPrefix: string;
  /**
   * API key creation time
   */
  createdAt: string;
  /**
   * API key last used time
   */
  lastUsedAt?: string | null;
  /**
   * API key expiration time
   */
  expiresAt?: string | null;
};

export type CreateCliApiKeyData = {
  /**
   * API key ID
   */
  keyId: string;
  /**
   * API key value
   */
  apiKey: string;
  /**
   * API key name
   */
  name: string;
  /**
   * API key prefix
   */
  keyPrefix: string;
  /**
   * API key creation time
   */
  createdAt: string;
  /**
   * API key expiration time
   */
  expiresAt?: string | null;
};

export type CreateCliApiKeyResponse = BaseResponse & {
  data?: CreateCliApiKeyData;
};

export type ListCliApiKeysResponse = BaseResponse & {
  data?: Array<CliApiKeyInfo>;
};

export type GetUserSettingsResponse = BaseResponse & {
  data?: UserSettings;
};

export type CollabTokenData = {
  /**
   * Collab token
   */
  token: string;
  /**
   * Token expiration time (in unix milliseconds)
   */
  expiresAt?: number;
};

export type GetCollabTokenResponse = BaseResponse & {
  data?: CollabTokenData;
};

export type BaseResponse = {
  /**
   * Whether the operation was successful
   */
  success: boolean;
  /**
   * Error code
   */
  errCode?: string;
  /**
   * Error message
   */
  errMsg?: string;
  /**
   * Trace ID
   */
  traceId?: string;
  /**
   * Error stack (only returned in development environment)
   */
  stack?: string;
};

export type ErrorDetail = {
  /**
   * Error code identifier
   */
  code: string;
  /**
   * Human-readable error message
   */
  message: string;
};

export type BaseResponseV2 = {
  /**
   * Response status
   */
  status: 'success' | 'failed';
  /**
   * Response data (generic object, present when status is success)
   */
  data?: {
    [key: string]: unknown;
  };
  /**
   * Array of error objects (present when status is error)
   */
  errors?: Array<ErrorDetail>;
};

/**
 * Response status
 */
export type status3 = 'success' | 'failed';

/**
 * Response status
 */
export const status3 = {
  SUCCESS: 'success',
  FAILED: 'failed',
} as const;

export type ListCanvasResponse = BaseResponse & {
  /**
   * Canvas list
   */
  data?: Array<Canvas>;
};

export type GetCanvasDetailResponse = BaseResponse & {
  data?: Canvas;
};

export type CanvasHistoryVersion = {
  /**
   * Canvas version
   */
  version: string;
  /**
   * Canvas hash
   */
  hash: string;
  /**
   * Canvas timestamp (in unix milliseconds)
   */
  timestamp: number;
};

/**
 * Canvas data
 */
export type CanvasData = {
  /**
   * Canvas nodes
   */
  nodes: Array<CanvasNode>;
  /**
   * Canvas edges
   */
  edges: Array<CanvasEdge>;
};

/**
 * Canvas state
 */
export type CanvasState = CanvasData & {
  /**
   * Canvas version
   */
  version?: string;
  /**
   * Canvas state hash (sha256), calculated from nodes and edges
   */
  hash?: string;
  /**
   * Canvas transaction list
   */
  transactions?: Array<CanvasTransaction>;
  /**
   * Canvas history versions
   */
  history?: Array<CanvasHistoryVersion>;
  /**
   * Canvas creation timestamp (in unix milliseconds)
   */
  createdAt?: number;
  /**
   * Canvas last updated timestamp (in unix milliseconds)
   */
  updatedAt?: number;
};

/**
 * Raw canvas data
 */
export type RawCanvasData = CanvasData & {
  /**
   * Canvas ID
   */
  canvasId?: string;
  /**
   * Canvas title
   */
  title?: string;
  /**
   * Canvas owner
   */
  owner?: ShareUser;
  /**
   * Minimap URL
   */
  minimapUrl?: string;
  /**
   * Workflow variables
   */
  variables?: Array<WorkflowVariable>;
};

export type GetCanvasDataResponse = BaseResponse & {
  data?: RawCanvasData;
};

export type SharedCanvasData = RawCanvasData & {
  /**
   * Resources in the canvas
   * @deprecated
   */
  resources?: Array<Resource>;
  /**
   * Drive files in the canvas
   */
  files?: Array<DriveFile>;
};

export type ExportCanvasResponse = BaseResponse & {
  data?: {
    /**
     * Download URL for the canvas data
     */
    downloadUrl?: string;
  };
};

export type ImportCanvasRequest = {
  /**
   * File to import
   */
  file: Blob | File;
  /**
   * Canvas ID to specify
   */
  canvasId?: string;
};

export type DuplicateCanvasRequest = {
  /**
   * Canvas ID to duplicate
   */
  canvasId: string;
  /**
   * Custom canvas title
   */
  title?: string;
  /**
   * Project ID to bind with
   */
  projectId?: string;
  /**
   * Whether to duplicate entities within the canvas
   */
  duplicateEntities?: boolean;
};

export type DuplicateDocumentRequest = {
  /**
   * Document ID to duplicate
   */
  docId: string;
  /**
   * Custom document title for the duplicate
   */
  title?: string;
  /**
   * Target canvas ID
   */
  canvasId?: string;
};

export type DuplicateResourceRequest = {
  /**
   * Resource ID to duplicate
   */
  resourceId: string;
  /**
   * Custom resource title for the duplicate
   */
  title?: string;
  /**
   * Target canvas ID
   */
  canvasId?: string;
};

export type UpsertCanvasRequest = {
  /**
   * Canvas title
   */
  title?: string;
  /**
   * Canvas ID (only used for update)
   */
  canvasId?: string;
  /**
   * Project ID to bind with
   */
  projectId?: string;
  /**
   * Minimap storage key
   */
  minimapStorageKey?: string;
  /**
   * Workflow variables
   */
  variables?: Array<WorkflowVariable>;
  /**
   * Whether this canvas is visible in lists
   */
  visibility?: boolean;
};

export type UpsertCanvasResponse = BaseResponse & {
  data?: Canvas;
};

export type DeleteCanvasRequest = {
  /**
   * Canvas ID to delete
   */
  canvasId: string;
  /**
   * Whether to delete all files in the canvas
   */
  deleteAllFiles?: boolean;
};

export type AutoNameCanvasRequest = {
  /**
   * Canvas ID
   */
  canvasId: string;
  /**
   * Whether to directly update the canvas title
   */
  directUpdate?: boolean;
};

export type AutoNameCanvasResponse = BaseResponse & {
  /**
   * Auto name canvas result
   */
  data?: {
    /**
     * New canvas title
     */
    title?: string;
  };
};

export type GetCanvasStateResponse = BaseResponse & {
  data?: CanvasState;
};

export type SetCanvasStateRequest = {
  /**
   * Canvas ID
   */
  canvasId: string;
  /**
   * Canvas state to set
   */
  state: CanvasState;
};

export type GetCanvasTransactionsResponse = BaseResponse & {
  /**
   * Canvas diff list
   */
  data?: Array<CanvasTransaction>;
};

/**
 * Diff type
 */
export type DiffType = 'add' | 'update' | 'delete';

/**
 * Diff type
 */
export const DiffType = {
  ADD: 'add',
  UPDATE: 'update',
  DELETE: 'delete',
} as const;

export type NodeDiff = {
  /**
   * Node ID
   */
  id: string;
  /**
   * Node diff type
   */
  type: DiffType;
  /**
   * Node diff from (only the fields that are different will be included)
   */
  from?: {
    [key: string]: unknown;
  };
  /**
   * Node diff to (only the fields that are different will be included)
   */
  to?: {
    [key: string]: unknown;
  };
};

export type EdgeDiff = {
  /**
   * Edge ID
   */
  id: string;
  /**
   * Edge diff type
   */
  type: DiffType;
  /**
   * Edge diff from
   */
  from?: CanvasEdge;
  /**
   * Edge diff to
   */
  to?: CanvasEdge;
};

/**
 * Canvas transaction source
 */
export type CanvasTransactionSource = {
  /**
   * Source type
   */
  type: 'user' | 'system';
  /**
   * Source user ID
   */
  uid?: string;
};

/**
 * Source type
 */
export type type3 = 'user' | 'system';

/**
 * Source type
 */
export const type3 = {
  USER: 'user',
  SYSTEM: 'system',
} as const;

export type CanvasTransaction = {
  /**
   * Transaction ID
   */
  txId: string;
  /**
   * Node diffs
   */
  nodeDiffs: Array<NodeDiff>;
  /**
   * Edge diffs
   */
  edgeDiffs: Array<EdgeDiff>;
  /**
   * Whether the transaction is revoked
   */
  revoked?: boolean;
  /**
   * Transaction source
   */
  source?: CanvasTransactionSource;
  /**
   * Whether the transaction is deleted
   */
  deleted?: boolean;
  /**
   * Transaction creation timestamp (in unix milliseconds)
   */
  createdAt: number;
  /**
   * Transaction synchronization timestamp (in unix milliseconds)
   */
  syncedAt?: number;
};

export type SyncCanvasStateRequest = {
  /**
   * Canvas ID
   */
  canvasId: string;
  /**
   * Canvas state version
   */
  version?: string;
  /**
   * Transaction list
   */
  transactions: Array<CanvasTransaction>;
};

export type SyncCanvasStateResult = {
  /**
   * Transaction list
   */
  transactions: Array<CanvasTransaction>;
};

export type SyncCanvasStateResponse = BaseResponse & {
  /**
   * Apply canvas state result
   */
  data?: SyncCanvasStateResult;
};

export type CreateCanvasVersionRequest = {
  /**
   * Canvas ID
   */
  canvasId: string;
  /**
   * Canvas state
   */
  state: CanvasState;
};

export type VersionConflict = {
  /**
   * Local canvas state
   */
  localState: CanvasState;
  /**
   * Server canvas state
   */
  remoteState: CanvasState;
};

export type CreateCanvasVersionResult = {
  /**
   * Canvas ID
   */
  canvasId: string;
  /**
   * Version conflict (when there is a conflict)
   */
  conflict?: VersionConflict;
  /**
   * New canvas state (when there is no conflict)
   */
  newState?: CanvasState;
};

export type CreateCanvasVersionResponse = BaseResponse & {
  /**
   * Create canvas version result
   */
  data?: CreateCanvasVersionResult;
};

export type ListCanvasTemplateResponse = BaseResponse & {
  /**
   * Canvas template list
   */
  data?: Array<CanvasTemplate>;
};

export type CreateCanvasTemplateRequest = {
  /**
   * Canvas ID
   */
  canvasId: string;
  /**
   * Canvas template title
   */
  title: string;
  /**
   * Canvas template description
   */
  description: string;
  /**
   * Canvas template category ID
   */
  categoryId?: string;
  /**
   * Canvas template language code
   */
  language: string;
  /**
   * Cover storage key
   */
  coverStorageKey?: string;
};

export type UpdateCanvasTemplateRequest = {
  /**
   * Canvas template ID
   */
  templateId: string;
  /**
   * Canvas template title
   */
  title?: string;
  /**
   * Canvas template description
   */
  description?: string;
  /**
   * Canvas template category ID
   */
  categoryId?: string;
  /**
   * Canvas template language code
   */
  language?: string;
};

export type UpsertCanvasTemplateResponse = BaseResponse & {
  /**
   * Canvas template
   */
  data?: CanvasTemplate;
};

export type ListCanvasTemplateCategoryResponse = BaseResponse & {
  /**
   * Canvas template category list
   */
  data?: Array<CanvasTemplateCategory>;
};

export type UpsertResourceRequest = {
  /**
   * Resource title
   */
  title: string;
  /**
   * Resource type
   */
  resourceType: ResourceType;
  /**
   * Resource ID (only used for update)
   */
  resourceId?: string;
  /**
   * Project ID to bind with
   */
  projectId?: string;
  /**
   * Canvas ID to bind with
   */
  canvasId?: string;
  /**
   * Resource metadata
   */
  data?: ResourceMeta;
  /**
   * Storage key
   */
  storageKey?: string;
  /**
   * Resource content (this will be ignored if storageKey was set)
   */
  content?: string;
};

export type UpsertResourceResponse = BaseResponse & {
  data?: Resource;
};

export type BatchCreateResourceResponse = BaseResponse & {
  /**
   * Resource list
   */
  data?: Array<Resource>;
};

export type ReindexResourceRequest = {
  /**
   * Resource ID list
   */
  resourceIds: Array<string>;
};

export type ReindexResourceResponse = BaseResponse & {
  /**
   * Resource list
   */
  data?: Array<Resource>;
};

export type DeleteResourceRequest = {
  /**
   * Resource ID to delete
   */
  resourceId: string;
};

export type ListResourceResponse = BaseResponse & {
  /**
   * Resource list
   */
  data?: Array<Resource>;
};

export type GetResourceDetailResponse = BaseResponse & {
  /**
   * Resource data
   */
  data?: Resource;
};

export type ListDocumentResponse = BaseResponse & {
  /**
   * Canvas list
   */
  data?: Array<Document>;
};

export type GetDocumentDetailResponse = BaseResponse & {
  /**
   * Document data
   */
  data?: Document;
};

export type UpsertDocumentRequest = {
  /**
   * Canvas title
   */
  title?: string;
  /**
   * Document ID (only used for update)
   */
  docId?: string;
  /**
   * Project ID to bind with
   */
  projectId?: string;
  /**
   * Canvas ID to bind with
   */
  canvasId?: string;
  /**
   * Whether this document is read-only
   */
  readOnly?: boolean;
  /**
   * Document initial content
   */
  initialContent?: string;
  /**
   * Action result ID to bind with
   */
  resultId?: string;
};

export type UpsertDocumentResponse = BaseResponse & {
  data?: Document;
};

export type DeleteDocumentRequest = {
  /**
   * Document ID to delete
   */
  docId: string;
};

export type GetActionResultResponse = BaseResponse & {
  data?: ActionResult;
};

export type AbortActionRequest = {
  /**
   * Action result ID
   */
  resultId: string;
  /**
   * Action result version
   */
  version?: number;
};

/**
 * Skill event type
 */
export type SkillEventType =
  | 'start'
  | 'end'
  | 'stream'
  | 'log'
  | 'artifact'
  | 'structured_data'
  | 'token_usage'
  | 'create_node'
  | 'tool_call_start'
  | 'tool_call_end'
  | 'tool_call_error'
  | 'tool_call_stream'
  | 'error';

/**
 * Skill event type
 */
export const SkillEventType = {
  START: 'start',
  END: 'end',
  STREAM: 'stream',
  LOG: 'log',
  ARTIFACT: 'artifact',
  STRUCTURED_DATA: 'structured_data',
  TOKEN_USAGE: 'token_usage',
  CREATE_NODE: 'create_node',
  TOOL_CALL_START: 'tool_call_start',
  TOOL_CALL_END: 'tool_call_end',
  TOOL_CALL_ERROR: 'tool_call_error',
  TOOL_CALL_STREAM: 'tool_call_stream',
  ERROR: 'error',
} as const;

export type SkillEvent = {
  /**
   * Event type
   */
  event: SkillEventType;
  /**
   * Skill metadata
   */
  skillMeta?: SkillMeta;
  /**
   * Action step metadata
   * @deprecated
   */
  step?: ActionStepMeta;
  /**
   * Result ID
   */
  resultId: string;
  /**
   * Result version
   */
  version?: number;
  /**
   * Message ID
   */
  messageId?: string;
  /**
   * Event content. Only present when `event` is `stream`
   */
  content?: string;
  /**
   * Reasoning content. Only present when `event` is `stream`
   */
  reasoningContent?: string;
  /**
   * Token usage data. Only present when `event` is `token_usage`.
   */
  tokenUsage?: TokenUsageItem;
  /**
   * Log data. Only present when `event` is `log`.
   */
  log?: ActionLog;
  /**
   * Structured data. Only present when `event` is `structured_data`.
   */
  structuredData?: {
    [key: string]: unknown;
  };
  /**
   * Artifact data. Only present when `event` is `artifact`.
   */
  artifact?: Artifact;
  /**
   * Canvas node data. Only present when `event` is `create_node`.
   */
  node?: CanvasNode;
  /**
   * Error data. Only present when `event` is `error`.
   */
  error?: BaseResponse;
  /**
   * Original error message. Only present when `event` is `error`.
   */
  originError?: string;
  /**
   * Tool call metadata. Only present when `event` is `tool_call_start`, `tool_call_end`, or `tool_call_error`.
   */
  toolCallMeta?: ToolCallMeta;
  /**
   * Tool call result data.
   */
  toolCallResult?: ToolCallResult;
  /**
   * Whether this is a PTC (Programmatic Tool Calling) internal tool call. Only present when `event` is `tool_call_end` or `tool_call_error` for PTC internal calls.
   */
  isPtc?: boolean;
};

/**
 * Tool call status
 */
export type ToolCallStatus = 'executing' | 'completed' | 'failed';

/**
 * Tool call status
 */
export const ToolCallStatus = {
  EXECUTING: 'executing',
  COMPLETED: 'completed',
  FAILED: 'failed',
} as const;

export type ToolCallMeta = {
  /**
   * Tool name
   */
  toolName?: string;
  /**
   * Toolset ID
   */
  toolsetId?: string;
  /**
   * Toolset key
   */
  toolsetKey?: string;
  /**
   * Tool call ID
   */
  toolCallId?: string;
  /**
   * Tool call status
   */
  status?: ToolCallStatus;
  /**
   * Tool call start timestamp (milliseconds)
   */
  startTs?: number;
  /**
   * Tool call end timestamp (milliseconds)
   */
  endTs?: number;
  /**
   * Tool call error
   */
  error?: string;
};

export type ToolCallResult = {
  /**
   * Tool call ID (run_id from LangChain)
   */
  callId: string;
  /**
   * User ID
   */
  uid?: string;
  /**
   * Toolset ID (toolsetKey)
   */
  toolsetId?: string;
  /**
   * Tool name
   */
  toolName?: string;
  /**
   * Step name (the action step in which this tool was called)
   */
  stepName?: string;
  /**
   * Tool input arguments
   */
  input?:
    | {
        [key: string]: unknown;
      }
    | string;
  /**
   * Tool output result
   */
  output?:
    | {
        [key: string]: unknown;
      }
    | string;
  /**
   * Error message if tool execution failed
   */
  error?: string;
  /**
   * Tool call status
   */
  status: ToolCallStatus;
  /**
   * Tool call start timestamp (milliseconds)
   */
  createdAt: number;
  /**
   * Tool call last update timestamp (milliseconds)
   */
  updatedAt: number;
  /**
   * Tool call deletion timestamp (milliseconds)
   */
  deletedAt?: number;
};

export type ShareRecord = {
  /**
   * Share ID
   */
  shareId: string;
  /**
   * Share title
   */
  title?: string;
  /**
   * Entity type
   */
  entityType: EntityType;
  /**
   * Entity ID
   */
  entityId: string;
  /**
   * Whether to allow duplication of the shared entity
   */
  allowDuplication?: boolean;
  /**
   * Parent share ID
   */
  parentShareId?: string;
  /**
   * Canvas template ID
   */
  templateId?: string;
  /**
   * Create timestamp
   */
  createdAt?: string;
  /**
   * Update timestamp
   */
  updatedAt?: string;
};

export type UpsertCodeArtifactRequest = {
  /**
   * Code artifact ID (not needed for creation)
   */
  artifactId?: string;
  /**
   * Code artifact title
   */
  title?: string;
  /**
   * Code artifact type
   */
  type?: string;
  /**
   * Code artifact content
   */
  content?: string;
  /**
   * Code artifact language
   */
  language?: string;
  /**
   * Action result ID
   */
  resultId?: string;
  /**
   * Action result version
   */
  resultVersion?: number;
  /**
   * Canvas ID to bind with
   */
  canvasId?: string;
  /**
   * Code artifact preview storage key
   */
  previewStorageKey?: string;
  /**
   * Whether to create the code artifact if it does not exist
   */
  createIfNotExists?: boolean;
};

export type UpsertCodeArtifactResponse = BaseResponse & {
  data?: CodeArtifact;
};

export type ListCodeArtifactResponse = BaseResponse & {
  /**
   * Code artifact list
   */
  data?: Array<CodeArtifact>;
};

export type GetCodeArtifactDetailResponse = BaseResponse & {
  data?: CodeArtifact;
};

export type DuplicateCodeArtifactRequest = {
  /**
   * Code artifact ID to duplicate
   */
  artifactId: string;
  /**
   * Target canvas ID
   */
  canvasId?: string;
};

export type CreateShareRequest = {
  /**
   * Entity type
   */
  entityType: EntityType;
  /**
   * Entity ID
   */
  entityId: string;
  /**
   * Share title
   */
  title?: string;
  /**
   * Whether to allow duplication of the shared entity
   */
  allowDuplication?: boolean;
  /**
   * Parent share ID
   */
  parentShareId?: string;
  /**
   * Raw share data (JSON string)
   */
  shareData?: string;
  /**
   * Share data storage key
   */
  shareDataStorageKey?: string;
  /**
   * Cover storage key
   */
  coverStorageKey?: string;
  /**
   * Credit usage
   */
  creditUsage?: number;
};

export type CreateShareResponse = BaseResponse & {
  /**
   * Share created
   */
  data?: ShareRecord;
};

export type ListShareResponse = BaseResponse & {
  /**
   * Share record list
   */
  data?: Array<ShareRecord>;
};

export type DeleteShareRequest = {
  /**
   * Share ID
   */
  shareId: string;
};

export type DuplicateShareRequest = {
  /**
   * Share ID
   */
  shareId: string;
  /**
   * Project ID to duplicate the share to
   */
  projectId?: string;
  /**
   * Target canvas ID
   */
  canvasId?: string;
  /**
   * Custom title for the duplicated entity
   */
  title?: string;
};

export type DuplicateShareResponse = BaseResponse & {
  /**
   * Duplicated entity
   */
  data?: Entity;
};

/**
 * Skill input
 */
export type SkillInput = {
  /**
   * User query
   */
  query?: string;
  /**
   * Original user query
   */
  originalQuery?: string;
  /**
   * Image list (storage keys)
   * @deprecated
   */
  images?: Array<string>;
};

/**
 * Skill context resource item
 */
export type SkillContextResourceItem = {
  /**
   * Resource ID (if empty, this will be considered as external resource)
   */
  resourceId?: string;
  /**
   * Resource
   */
  resource?: Resource;
  /**
   * Whether this resource is current
   */
  isCurrent?: boolean;
  /**
   * Resource context metadata
   */
  metadata?: {
    [key: string]: unknown;
  };
};

/**
 * Skill context document item
 */
export type SkillContextDocumentItem = {
  /**
   * Document ID
   */
  docId?: string;
  /**
   * Document
   */
  document?: Document;
  /**
   * Whether this document is current
   */
  isCurrent?: boolean;
  /**
   * Canvas context metadata
   */
  metadata?: {
    [key: string]: unknown;
  };
};

/**
 * Skill context code artifact item
 */
export type SkillContextCodeArtifactItem = {
  /**
   * Artifact ID
   */
  artifactId?: string;
  /**
   * Code artifact
   */
  codeArtifact?: CodeArtifact;
  /**
   * Whether this code artifact is current
   */
  isCurrent?: boolean;
  /**
   * Code artifact context metadata
   */
  metadata?: {
    [key: string]: unknown;
  };
};

/**
 * Skill context content item
 */
export type SkillContextContentItem = {
  /**
   * Content
   */
  content: string;
  /**
   * Content context metadata
   */
  metadata?: {
    [key: string]: unknown;
  };
};

/**
 * Skill context url item
 */
export type SkillContextUrlItem = {
  /**
   * URL
   */
  url: string;
  /**
   * URL context metadata
   */
  metadata?: {
    [key: string]: unknown;
  };
};

/**
 * Skill context media item
 */
export type SkillContextMediaItem = {
  /**
   * Media type
   */
  mediaType: MediaType;
  /**
   * Media entity ID
   */
  entityId: string;
  /**
   * Media title
   */
  title: string;
  /**
   * Media URL
   */
  url: string;
  /**
   * Media storage key
   */
  storageKey: string;
  /**
   * Media context metadata
   */
  metadata?: {
    [key: string]: unknown;
  };
};

/**
 * Skill context file item
 */
export type SkillContextFileItem = {
  /**
   * File ID
   */
  fileId: string;
  /**
   * File object
   */
  file?: DriveFile;
  /**
   * Variable ID if this file is from a workflow variable
   */
  variableId?: string;
  /**
   * Variable name if this file is from a workflow variable
   */
  variableName?: string;
};

/**
 * Skill context result item
 */
export type SkillContextResultItem = {
  /**
   * Result ID
   */
  resultId?: string;
  /**
   * Result
   */
  result?: ActionResult;
};

/**
 * Skill invocation context
 */
export type SkillContext = {
  /**
   * Context resources
   */
  resources?: Array<SkillContextResourceItem>;
  /**
   * Context documents
   */
  documents?: Array<SkillContextDocumentItem>;
  /**
   * Context code artifacts
   */
  codeArtifacts?: Array<SkillContextCodeArtifactItem>;
  /**
   * Context content list
   */
  contentList?: Array<SkillContextContentItem>;
  /**
   * List of URLs
   * @deprecated
   */
  urls?: Array<SkillContextUrlItem>;
  /**
   * List of media
   */
  mediaList?: Array<SkillContextMediaItem>;
  /**
   * List of files
   */
  files?: Array<SkillContextFileItem>;
  /**
   * List of results
   */
  results?: Array<SkillContextResultItem>;
};

export type SelectionKey =
  | 'documentSelection'
  | 'resourceSelection'
  | 'skillResponseSelection'
  | 'extensionWeblinkSelection'
  | 'documentCursorSelection'
  | 'documentBeforeCursorSelection'
  | 'documentAfterCursorSelection';

export const SelectionKey = {
  DOCUMENT_SELECTION: 'documentSelection',
  RESOURCE_SELECTION: 'resourceSelection',
  SKILL_RESPONSE_SELECTION: 'skillResponseSelection',
  EXTENSION_WEBLINK_SELECTION: 'extensionWeblinkSelection',
  DOCUMENT_CURSOR_SELECTION: 'documentCursorSelection',
  DOCUMENT_BEFORE_CURSOR_SELECTION: 'documentBeforeCursorSelection',
  DOCUMENT_AFTER_CURSOR_SELECTION: 'documentAfterCursorSelection',
} as const;

export type ActionType = 'skill' | 'tool' | 'media';

export const ActionType = {
  SKILL: 'skill',
  TOOL: 'tool',
  MEDIA: 'media',
} as const;

export type AgentMode = 'copilot_agent' | 'node_agent';

export const AgentMode = {
  COPILOT_AGENT: 'copilot_agent',
  NODE_AGENT: 'node_agent',
} as const;

export type InvokeSkillRequest = {
  /**
   * Skill input
   */
  input?: SkillInput;
  /**
   * Agent title
   */
  title?: string;
  /**
   * Skill invocation context
   */
  context?: SkillContext;
  /**
   * Skill result history
   * @deprecated
   */
  resultHistory?: Array<ActionResult>;
  /**
   * Skill runtime config
   * @deprecated
   */
  runtimeConfig?: SkillRuntimeConfig;
  /**
   * Skill template config
   * @deprecated
   */
  tplConfig?: SkillTemplateConfig;
  /**
   * Skill name (if not provided, commonQnA will be used)
   * @deprecated
   */
  skillName?: string;
  /**
   * Skill invocation target
   */
  target?: Entity;
  /**
   * Result ID associated with this invocation.
   * 1) If not provided, a new resultId will be generated.
   * 2) If there is no existing result with this resultId, it will be created and run.
   * 3) If there is an existing result with this resultId, it will be rerun.
   *
   */
  resultId?: string;
  /**
   * Selected output locale
   */
  locale?: string;
  /**
   * Selected model
   * @deprecated
   */
  modelName?: string;
  /**
   * Selected model item ID
   */
  modelItemId?: string;
  /**
   * Skill ID
   */
  skillId?: string;
  /**
   * Trigger ID
   */
  triggerId?: string;
  /**
   * Selected MCP servers (deprecated, use `tools` instead)
   * @deprecated
   */
  selectedMcpServers?: Array<string>;
  /**
   * Selected toolsets
   */
  toolsets?: Array<GenericToolset>;
  /**
   * Agent mode
   */
  mode?: AgentMode;
  /**
   * Copilot session ID
   */
  copilotSessionId?: string;
  /**
   * Workflow execution ID for workflow context
   */
  workflowExecutionId?: string;
  /**
   * Workflow node execution ID for workflow context
   */
  workflowNodeExecutionId?: string;
};

export type InvokeSkillResponse = BaseResponse & {
  /**
   * Skill result ID
   */
  resultId?: string;
};

/**
 * media type
 */
export type MediaType = 'image' | 'video' | 'audio';

/**
 * media type
 */
export const MediaType = {
  IMAGE: 'image',
  VIDEO: 'video',
  AUDIO: 'audio',
} as const;

export type MediaGenerateRequest = {
  mediaType: MediaType;
  /**
   * Model name for content generation
   */
  model?: string;
  /**
   * Title of the generated media
   */
  title?: string;
  /**
   * Target type
   */
  targetType?: EntityType;
  /**
   * Target ID
   */
  targetId?: string;
  /**
   * Provider item ID
   */
  providerItemId?: string;
  /**
   * Optional provider selection (use providerItemId instead)
   */
  provider?: string | null;
  /**
   * Text prompt for content generation
   */
  prompt: string;
  /**
   * Whether to wait for the generation to complete
   */
  wait?: boolean;
  /**
   * Media generation result ID
   */
  resultId?: string;
  /**
   * Parent result ID for the media generation (usually the actor agent result ID)
   */
  parentResultId?: string;
  /**
   * Parent result version for the media generation (usually the actor agent result version)
   */
  parentResultVersion?: number;
  /**
   * API key for the provider
   */
  apiKey?: string;
  /**
   * Input parameter configurations
   */
  inputParameters?: Array<MediaModelParameter>;
  /**
   * Flexible key-value pairs for additional input parameters
   */
  input?: {
    [key: string]: unknown;
  };
  /**
   * Unit cost for the media generation
   */
  unitCost?: number;
};

export type MediaGenerationResult = {
  /**
   * Media generation result ID
   */
  resultId: string;
  /**
   * Generated file
   */
  file?: DriveFile;
  /**
   * Media generation output URL (only available when `wait` is true)
   * @deprecated
   */
  outputUrl?: string;
  /**
   * Media generation output storage key (only available when `wait` is true)
   * @deprecated
   */
  storageKey?: string;
  /**
   * Media generation original result from provider
   */
  originalResult?: {
    [key: string]: unknown;
  };
};

export type MediaGenerateResponse = BaseResponse & {
  data?: MediaGenerationResult;
};

export type FishAudioTextToSpeechRequest = MediaGenerateRequest & {
  /**
   * Text to convert to speech
   */
  text: string;
  /**
   * Voice model reference ID (optional, uses default if not specified)
   */
  referenceId?: string;
  /**
   * Reference audio files for voice cloning (alternative to referenceId). Provide uploaded audio files with optional transcripts.
   */
  references?: Array<{
    /**
     * Entity ID of the uploaded audio file from file upload
     */
    entityId: string;
    /**
     * Optional transcript text of the audio. If not provided, will be automatically transcribed using speech-to-text.
     */
    text?: string;
  }>;
  /**
   * Output audio format
   */
  format?: 'mp3' | 'wav' | 'opus' | 'pcm';
  /**
   * MP3 bitrate (only for mp3 format)
   */
  mp3Bitrate?: 64 | 128 | 192;
  /**
   * Sample rate in Hz
   */
  sampleRate?: number;
  /**
   * Controls randomness (0-1)
   */
  temperature?: number;
  /**
   * Nucleus sampling diversity control (0-1)
   */
  topP?: number;
  /**
   * Whether to normalize audio
   */
  normalize?: boolean;
  /**
   * Chunk length for processing
   */
  chunkLength?: number;
  wait?: boolean;
};

/**
 * Output audio format
 */
export type format = 'mp3' | 'wav' | 'opus' | 'pcm';

/**
 * Output audio format
 */
export const format = {
  MP3: 'mp3',
  WAV: 'wav',
  OPUS: 'opus',
  PCM: 'pcm',
} as const;

/**
 * MP3 bitrate (only for mp3 format)
 */
export type mp3Bitrate = 64 | 128 | 192;

/**
 * MP3 bitrate (only for mp3 format)
 */
export const mp3Bitrate = {
  _64: 64,
  _128: 128,
  _192: 192,
} as const;

export type FishAudioTextToSpeechResponse = BaseResponseV2 & {
  /**
   * TTS response data (present when status is success)
   */
  data?: {
    /**
     * Public URL of the generated audio
     */
    audioUrl?: string;
    /**
     * Entity ID of the generated audio file
     */
    entityId?: string;
    /**
     * Audio duration in seconds
     */
    duration?: number;
    /**
     * Audio format
     */
    format?: string;
    /**
     * File size in bytes
     */
    size?: number;
    /**
     * Audio generation result ID
     */
    resultId?: string;
    /**
     * Storage key for the generated audio (only available when wait is true)
     */
    storageKey?: string;
  };
};

export type FishAudioSpeechToTextRequest = {
  /**
   * Entity ID of the uploaded audio file to transcribe
   */
  entityId: string;
  /**
   * Language code for speech recognition (e.g., "zh", "en")
   */
  language?: string;
  /**
   * Whether to ignore timestamps (increases latency for audio shorter than 30s)
   */
  ignoreTimestamps?: boolean;
};

export type FishAudioSpeechToTextResponse = BaseResponseV2 & {
  /**
   * STT response data (present when status is success)
   */
  data?: {
    /**
     * Transcribed text
     */
    text?: string;
    /**
     * Audio duration in seconds
     */
    duration?: number;
    /**
     * Text segments with timestamps
     */
    segments?: Array<{
      /**
       * Segment text
       */
      text?: string;
      /**
       * Start time in seconds
       */
      start?: number;
      /**
       * End time in seconds
       */
      end?: number;
    }>;
  };
};

export type HeyGenGenerateVideoRequest = {
  /**
   * Video scenes (1-50 items)
   */
  scenes: Array<{
    character?: {
      /**
       * Character type
       */
      type?: 'avatar' | 'talking_photo';
      /**
       * Avatar ID from HeyGen
       */
      avatarId: string;
      /**
       * Avatar display style
       */
      avatarStyle?: 'normal' | 'circle' | 'closeUp';
      /**
       * Avatar scale
       */
      scale?: number;
      /**
       * Avatar position offset
       */
      offset?: {
        x?: number;
        y?: number;
      };
    };
    voice: {
      /**
       * Voice type
       */
      type: 'text' | 'audio' | 'silence';
      /**
       * Voice ID (for text type)
       */
      voiceId?: string;
      /**
       * Text to speak (for text type)
       */
      inputText?: string;
      /**
       * Audio URL (for audio type, lowest priority)
       */
      audioUrl?: string;
      /**
       * Storage key of the audio file (format "static/{uuid}", for audio type, takes priority over audioUrl)
       */
      storageKey?: string;
      /**
       * Speech speed
       */
      speed?: number;
      /**
       * Voice pitch
       */
      pitch?: number;
      /**
       * Voice emotion
       */
      emotion?: string;
    };
    /**
     * Scene background
     */
    background?: {
      /**
       * Background type
       */
      type?: 'color' | 'image' | 'video';
      /**
       * Background image/video URL (lowest priority)
       */
      url?: string;
      /**
       * Storage key of the background file (format "static/{uuid}", takes priority over url)
       */
      storageKey?: string;
      /**
       * Background color (hex)
       */
      color?: string;
      /**
       * Video playback mode (only for type "video")
       */
      playStyle?: 'freeze' | 'loop' | 'fit_to_scene' | 'once';
    };
  }>;
  /**
   * Video dimensions
   */
  dimension?: {
    width?: number;
    height?: number;
  };
  /**
   * Video aspect ratio
   */
  aspectRatio?: string;
  /**
   * Test mode (adds watermark)
   */
  test?: boolean;
  /**
   * Video title
   */
  title?: string;
  /**
   * Custom callback identifier
   */
  callbackId?: string;
  /**
   * Add captions
   */
  caption?: boolean;
  /**
   * Parent action result ID for context inheritance
   */
  parentResultId?: string;
};

export type HeyGenGenerateVideoResponse = BaseResponseV2 & {
  data?: {
    /**
     * Generated video ID
     */
    videoId?: string;
    /**
     * Video generation status
     */
    status?: 'pending' | 'processing' | 'completed' | 'failed';
    /**
     * Video URL (when completed)
     */
    videoUrl?: string;
    /**
     * Thumbnail URL
     */
    thumbnailUrl?: string;
    /**
     * Video duration in seconds
     */
    duration?: number;
    /**
     * Error details (when failed)
     */
    error?: {
      code?: string;
      message?: string;
    };
  };
};

/**
 * Video generation status
 */
export type status4 = 'pending' | 'processing' | 'completed' | 'failed';

/**
 * Video generation status
 */
export const status4 = {
  PENDING: 'pending',
  PROCESSING: 'processing',
  COMPLETED: 'completed',
  FAILED: 'failed',
} as const;

export type SandboxExecuteParams = {
  /**
   * Code to execute in the sandbox
   */
  code: string;
  /**
   * Programming language for code execution
   */
  language: 'python' | 'javascript' | 'shell';
};

/**
 * Programming language for code execution
 */
export type language = 'python' | 'javascript' | 'shell';

/**
 * Programming language for code execution
 */
export const language = {
  PYTHON: 'python',
  JAVASCRIPT: 'javascript',
  SHELL: 'shell',
} as const;

export type SandboxExecuteContext = {
  /**
   * Parent action result ID for context inheritance
   */
  parentResultId?: string;
  /**
   * Canvas ID for context
   */
  canvasId?: string;
  /**
   * Target entity ID
   */
  targetId?: string;
  /**
   * Target entity type
   */
  targetType?: string;
  /**
   * Model name for credit tracking
   */
  model?: string;
  /**
   * Provider item ID for credit tracking
   */
  providerItemId?: string;
  /**
   * Result version for file registration
   */
  version?: number;
  /**
   * Whether PTC (Programmatic Tool Calling) is enabled
   */
  ptcEnabled?: boolean;
  /**
   * Tool call ID (execute_code's toolCallId) for PTC context tracking
   */
  toolCallId?: string;
  /**
   * Environment variables for execution
   */
  env?: {
    [key: string]: string;
  };
};

export type SandboxExecuteRequest = {
  params: SandboxExecuteParams;
  context?: SandboxExecuteContext;
};

export type SandboxExecuteResponse = BaseResponseV2 & {
  /**
   * Execution result data. Present when status is 'success'.
   * - exitCode=0: Code executed successfully
   * - exitCode!=0: Code error (syntax error, runtime exception, etc.)
   *
   */
  data?: {
    /**
     * Combined output from stdout and execution result text
     */
    output?: string;
    /**
     * Error message extracted from stderr/traceback (ANSI stripped, truncated if too long)
     */
    error?: string;
    /**
     * Exit code of the execution (0=success, non-zero=code error)
     */
    exitCode?: number;
    /**
     * Execution time in milliseconds
     */
    executionTime?: number;
    /**
     * List of files generated by the code execution (available even when exitCode!=0)
     */
    files?: Array<DriveFile>;
    /**
     * System warnings from sandbox (e.g., file rename due to conflict, temporary directory creation)
     */
    warnings?: Array<string>;
  };
};

export type CopilotSession = {
  /**
   * Copilot session ID
   */
  sessionId?: string;
  /**
   * Copilot session title
   */
  title?: string;
  /**
   * Copilot session canvas ID
   */
  canvasId?: string;
  /**
   * Copilot session created at
   */
  createdAt?: string;
  /**
   * Copilot session updated at
   */
  updatedAt?: string;
  /**
   * Copilot session results (only returned in detail API)
   */
  results?: Array<ActionResult>;
};

export type ListCopilotSessionsResponse = BaseResponse & {
  /**
   * Copilot session list
   */
  data?: Array<CopilotSession>;
};

export type GetCopilotSessionDetailResponse = BaseResponse & {
  /**
   * Copilot session detail
   */
  data?: CopilotSession;
};

export type UpdateUserSettingsRequest = {
  /**
   * User name
   */
  name?: string;
  /**
   * User nickname
   */
  nickname?: string;
  /**
   * User avatar
   */
  avatar?: string;
  /**
   * User avatar storage key
   */
  avatarStorageKey?: string;
  /**
   * UI locale
   */
  uiLocale?: string;
  /**
   * Output locale
   */
  outputLocale?: string;
  /**
   * User preferences
   */
  preferences?: UserPreferences;
  /**
   * Onboarding config
   */
  onboarding?: OnboardingConfig;
};

export type CheckSettingsFieldResult = {
  /**
   * Settings field
   */
  field: string;
  /**
   * Settings field value
   */
  value: string;
  /**
   * Whether the field value is available
   */
  available: boolean;
};

export type CheckSettingsFieldResponse = BaseResponse & {
  /**
   * Settings field check result
   */
  data?: CheckSettingsFieldResult;
};

export type CreateCheckoutSessionRequest = {
  /**
   * Subscription plan type
   */
  planType: SubscriptionPlanType;
  /**
   * Subscription billing interval
   */
  interval?: SubscriptionInterval;
  /**
   * Optional voucher ID to apply discount
   */
  voucherId?: string;
  /**
   * Entry point where voucher was applied (e.g., claimed_popup, discount_popup, credit_insufficient_modal, pricing_page)
   */
  voucherEntryPoint?: string;
  /**
   * User type when voucher was applied (e.g., new, returning)
   */
  voucherUserType?: string;
  /**
   * Current plan
   */
  currentPlan?: string;
  /**
   * Source
   */
  source?: string;
};

export type CreateCreditPackCheckoutSessionRequest = {
  /**
   * Credit pack identifier
   */
  packId: string;
  /**
   * Current plan
   */
  currentPlan?: string;
  /**
   * Source
   */
  source?: string;
};

export type CreateCheckoutSessionResponse = BaseResponse & {
  /**
   * Checkout session
   */
  data?: {
    /**
     * Checkout session URL
     */
    url?: string;
  };
};

export type CreatePortalSessionResponse = BaseResponse & {
  /**
   * Portal session
   */
  data?: {
    /**
     * Portal session URL
     */
    url?: string;
  };
};

export type SubmitFormRequest = {
  /**
   * Form submission
   */
  formSubmission: FormSubmission;
};

export type GetFormDefinitionResponse = BaseResponse & {
  /**
   * Form definition
   */
  data?: FormDefinition;
};

export type GetCreditRechargeResponse = BaseResponse & {
  /**
   * Credit recharge data with pagination
   */
  data?: {
    /**
     * Credit recharge list
     */
    data?: Array<CreditRecharge>;
    /**
     * Total number of records
     */
    total?: number;
    /**
     * Current page number
     */
    page?: number;
    /**
     * Number of items per page
     */
    pageSize?: number;
  };
};

export type GetCreditUsageResponse = BaseResponse & {
  /**
   * Credit usage data with pagination
   */
  data?: {
    /**
     * Credit usage list
     */
    data?: Array<CreditUsage>;
    /**
     * Total number of records
     */
    total?: number;
    /**
     * Current page number
     */
    page?: number;
    /**
     * Number of items per page
     */
    pageSize?: number;
  };
};

export type getCreditBalanceResponse = BaseResponse & {
  /**
   * Credit balance
   */
  data?: {
    /**
     * Credit balance
     */
    creditBalance?: number;
    /**
     * Credit amount
     */
    creditAmount?: number;
    /**
     * Regular credits (from purchases, gifts, subscriptions)
     */
    regularCredits?: number;
    /**
     * Template earnings credits
     */
    templateEarningsCredits?: number;
    /**
     * Cumulative earnings credits
     */
    cumulativeEarningsCredits?: number;
  };
};

export type GetCreditUsageByResultIdResponse = BaseResponse & {
  /**
   * Credit usage by result ID
   */
  data?: {
    /**
     * Total credit usage by result ID
     */
    total?: number;
    /**
     * Credit usage list by result ID
     */
    usages?: Array<CreditUsage>;
  };
};

export type GetCreditUsageByExecutionIdResponse = BaseResponse & {
  /**
   * Credit usage by execution ID
   */
  data?: {
    /**
     * Total credit usage by execution ID
     */
    total?: number;
    /**
     * Credit usage list by execution ID
     */
    usages?: Array<CreditUsage>;
  };
};

export type GetCreditUsageByCanvasIdResponse = BaseResponse & {
  /**
   * Credit usage by canvas ID
   */
  data?: {
    /**
     * Total credit usage by canvas ID
     */
    total?: number;
    /**
     * Credit usage list by canvas ID
     */
    usages?: Array<CreditUsage>;
  };
};

export type GetCanvasCommissionByCanvasIdResponse = BaseResponse & {
  /**
   * Canvas commission by canvas ID
   */
  data?: {
    /**
     * Total canvas commission by canvas ID
     */
    total?: number;
  };
};

export type InvitationCode = {
  /**
   * Invitation code
   */
  code?: string;
  /**
   * Inviter UID
   */
  inviterUid?: string;
  /**
   * Invitee UID
   */
  inviteeUid?: string;
  /**
   * Invitation status
   */
  status?: string;
  /**
   * Invitation creation time
   */
  createdAt?: string;
  /**
   * Invitation update time
   */
  updatedAt?: string;
};

export type ActivateInvitationCodeRequest = {
  /**
   * Invitation code
   */
  code?: string;
};

export type ListInvitationCodesResponse = BaseResponse & {
  /**
   * Invitation code list
   */
  data?: Array<InvitationCode>;
};

export type SubscriptionPlan = {
  /**
   * Subscription plan type
   */
  planType?: string;
  /**
   * Credit quota per month
   */
  creditQuota?: number;
  /**
   * Daily gift credit quota
   */
  dailyGiftCreditQuota?: number;
  /**
   * Token quota per month (T1)
   */
  t1TokenQuota?: number;
  /**
   * Token quota per month (T2)
   */
  t2TokenQuota?: number;
  /**
   * Object storage quota (in bytes)
   */
  objectStorageQuota?: string;
  /**
   * Vector storage quota (in bytes)
   */
  vectorStorageQuota?: string;
};

export type GetSubscriptionPlansResponse = BaseResponse & {
  /**
   * Subscription plans
   */
  data?: Array<SubscriptionPlan>;
};

export type SubscriptionUsageData = {
  /**
   * Token usage meter
   */
  token?: TokenUsageMeter;
  /**
   * Storage usage meter
   */
  storage?: StorageUsageMeter;
  /**
   * File parsing meter
   */
  fileParsing?: FileParsingMeter;
};

export type GetSubscriptionUsageResponse = BaseResponse & {
  /**
   * Subscription usage
   */
  data?: SubscriptionUsageData;
};

export type WebSearchRequest = {
  /**
   * Search query
   */
  q?: string;
  /**
   * Language/locale code
   */
  hl?: string;
  /**
   * Country/region code
   */
  gl?: string;
  /**
   * Location string
   */
  location?: string;
  /**
   * Web search result limit
   */
  limit?: number;
};

export type BatchWebSearchRequest = {
  /**
   * Web search result limit
   */
  limit?: number;
  /**
   * Web search queries
   */
  queries?: Array<WebSearchRequest>;
};

export type MultiLingualWebSearchRequest = {
  /**
   * Search query
   */
  query: string;
  /**
   * List of search locales
   */
  searchLocaleList: Array<string>;
  /**
   * Display locale
   */
  displayLocale?: string;
  /**
   * Web search result limit per locale
   */
  searchLimit?: number;
  /**
   * Whether to enable reranking of search results
   */
  enableRerank?: boolean;
  /**
   * Limit for reranked results
   */
  rerankLimit?: number;
  /**
   * Relevance threshold for reranking
   */
  rerankRelevanceThreshold?: number;
};

export type MultiLingualWebSearchResponse = BaseResponse & {
  /**
   * Multilingual web search results
   */
  data?: {
    /**
     * Search result sources
     */
    sources: Array<Source>;
    /**
     * Search steps
     */
    searchSteps: Array<SearchStep>;
  };
};

export type WebSearchResult = {
  /**
   * Web search result name
   */
  name?: string;
  /**
   * Web search result url
   */
  url?: string;
  /**
   * Web search result snippet
   */
  snippet?: string;
  /**
   * Web search result locale
   */
  locale?: string;
};

export type WebSearchResponse = BaseResponse & {
  /**
   * Web search results
   */
  data?: Array<WebSearchResult>;
};

export type RerankResponse = BaseResponse & {
  /**
   * Reranked results
   */
  data?: Array<SearchResult>;
};

/**
 * Search options for internal use
 */
export type SearchOptions = {
  /**
   * Whether to enable reranker
   */
  enableReranker?: boolean;
};

export type SearchDomain = 'resource' | 'document' | 'canvas';

export const SearchDomain = {
  RESOURCE: 'resource',
  DOCUMENT: 'document',
  CANVAS: 'canvas',
} as const;

export type SearchMode = 'keyword' | 'vector' | 'hybrid';

export const SearchMode = {
  KEYWORD: 'keyword',
  VECTOR: 'vector',
  HYBRID: 'hybrid',
} as const;

export type SearchRequest = {
  /**
   * Search query (if empty, return last updated data)
   */
  query: string;
  /**
   * Search domains (if not specified, return all domains)
   */
  domains?: Array<SearchDomain>;
  /**
   * Search entities
   */
  entities?: Array<Entity>;
  /**
   * Search mode
   */
  mode?: SearchMode;
  /**
   * Project ID
   */
  projectId?: string;
  /**
   * Search result limit for each domain
   */
  limit?: number;
};

export type SearchResultSnippet = {
  /**
   * Search result content text
   */
  text?: string;
  /**
   * Search result highlighted content text with em html tags
   */
  highlightedText?: string;
};

export type SearchResult = {
  /**
   * Search result ID to navigate to
   */
  id: string;
  /**
   * Search result domain
   */
  domain: SearchDomain;
  /**
   * Search result title
   */
  title: string;
  /**
   * Search result highlighted title with em html tags
   */
  highlightedTitle?: string;
  /**
   * Search result content preview
   */
  contentPreview?: string;
  /**
   * Search result content list with highlight marks
   */
  snippets?: Array<SearchResultSnippet>;
  /**
   * Search result relevance score
   */
  relevanceScore?: number;
  /**
   * Search result metadata
   */
  metadata?: {
    [key: string]: unknown;
  };
  /**
   * Data creation time
   */
  createdAt?: string;
  /**
   * Data update time
   */
  updatedAt?: string;
};

export type SearchResponse = BaseResponse & {
  /**
   * Search result
   */
  data?: Array<SearchResult>;
};

export type ScrapeWeblinkRequest = {
  /**
   * Weblink URL
   */
  url: string;
};

export type ScrapeWeblinkResult = {
  /**
   * Weblink title
   */
  title?: string;
  /**
   * Weblink description
   */
  description?: string;
  /**
   * Weblink image
   */
  image?: string;
};

export type ScrapeWeblinkResponse = BaseResponse & {
  /**
   * Weblink scrape result
   */
  data?: ScrapeWeblinkResult;
};

export type FileVisibility = 'public' | 'private';

export const FileVisibility = {
  PUBLIC: 'public',
  PRIVATE: 'private',
} as const;

export type UploadRequest = {
  /**
   * File to upload
   */
  file: Blob | File;
  /**
   * Entity ID
   */
  entityId?: string;
  /**
   * Entity type
   */
  entityType?: EntityType;
  /**
   * File visibility (default is private)
   */
  visibility?: FileVisibility;
  /**
   * Storage key (if provided, the file will be replaced if it already exists)
   */
  storageKey?: string;
};

export type UploadResponse = BaseResponse & {
  /**
   * File upload result
   */
  data?: {
    /**
     * File URL
     */
    url: string;
    /**
     * Storage key
     */
    storageKey: string;
  };
};

export type ConvertRequest = {
  /**
   * The file to convert
   */
  file: Blob | File;
  /**
   * Source format (e.g., html)
   */
  from?: string;
  /**
   * Target format (e.g., markdown)
   */
  to?: string;
};

export type ConvertResponse = BaseResponse & {
  data?: {
    /**
     * Converted markdown content
     */
    content?: string;
  };
};

/**
 * Prompt suggestion
 */
export type PromptSuggestion = {
  /**
   * Prompt (JSON map, key is language code, value is prompt)
   */
  prompt: {
    [key: string]: string;
  };
};

export type GetPromptSuggestionsResponse = BaseResponse & {
  /**
   * Prompt suggestions
   */
  data?: Array<PromptSuggestion>;
};

export type MediaGenerationModelCapabilities = {
  /**
   * Whether this model supports image generation
   */
  image?: boolean;
  /**
   * Whether this model supports video generation
   */
  video?: boolean;
  /**
   * Whether this model supports audio generation
   */
  audio?: boolean;
};

export type ModelCapabilities = {
  /**
   * Whether this model supports function calling
   */
  functionCall?: boolean;
  /**
   * Whether this model can take images as input
   */
  vision?: boolean;
  /**
   * Whether this model includes reasoning content
   */
  reasoning?: boolean;
  /**
   * Whether this model supports context caching
   */
  contextCaching?: boolean;
  /**
   * Whether this model supports tool_choice parameter
   */
  supportToolChoice?: boolean;
  /**
   * Whether this model supports image generation
   */
  image?: boolean;
  /**
   * Whether this model supports video generation
   */
  video?: boolean;
  /**
   * Whether this model supports audio generation
   */
  audio?: boolean;
};

export type ModelInfo = {
  /**
   * Model name
   */
  name: string;
  /**
   * Model label
   */
  label: string;
  /**
   * Model provider
   */
  provider: string;
  /**
   * Model provider item ID
   */
  providerItemId?: string;
  /**
   * Model tier
   */
  tier?: ModelTier;
  /**
   * Model context limit (in tokens)
   */
  contextLimit: number;
  /**
   * Model max output length (in tokens)
   */
  maxOutput: number;
  /**
   * Model capabilities
   */
  capabilities?: ModelCapabilities;
  /**
   * Whether this model is the default model
   */
  isDefault?: boolean;
  /**
   * Model group
   */
  group?: string;
  /**
   * Model category
   */
  category?: ProviderCategory;
  /**
   * Credit billing info
   */
  creditBilling?: CreditBilling;
  /**
   * Tooltip text for the model (e.g., "Smart Routing")
   */
  tooltip?: string;
  /**
   * Input parameter configurations
   */
  inputParameters?: Array<MediaModelParameter>;
};

export type ListModelsResponse = BaseResponse & {
  /**
   * Model list
   */
  data?: Array<ModelInfo>;
};

export type ProviderCategory =
  | 'llm'
  | 'embedding'
  | 'reranker'
  | 'webSearch'
  | 'urlParsing'
  | 'pdfParsing'
  | 'mediaGeneration';

export const ProviderCategory = {
  LLM: 'llm',
  EMBEDDING: 'embedding',
  RERANKER: 'reranker',
  WEB_SEARCH: 'webSearch',
  URL_PARSING: 'urlParsing',
  PDF_PARSING: 'pdfParsing',
  MEDIA_GENERATION: 'mediaGeneration',
} as const;

/**
 * General provider info
 */
export type Provider = {
  /**
   * Provider ID
   */
  providerId: string;
  /**
   * Provider key
   */
  providerKey: string;
  /**
   * Provider name
   */
  name: string;
  /**
   * Provider categories
   */
  categories: Array<ProviderCategory>;
  /**
   * Provider base URL
   */
  baseUrl?: string;
  /**
   * Whether the provider is enabled
   */
  enabled: boolean;
  /**
   * Whether the provider is global
   */
  isGlobal?: boolean;
  /**
   * Provider API key (this will never be exposed to the frontend)
   */
  apiKey?: string;
};

/**
 * Provider config for LLMs
 */
export type LLMModelConfig = {
  /**
   * Model ID
   */
  modelId: string;
  /**
   * Model name
   */
  modelName: string;
  /**
   * Model context limit (in tokens)
   */
  contextLimit?: number;
  /**
   * Model max output length (in tokens)
   */
  maxOutput?: number;
  /**
   * Whether the model disallow setting custom temperature
   */
  disallowTemperature?: boolean;
  /**
   * Model capabilities
   */
  capabilities?: ModelCapabilities;
  /**
   * Tooltip text for the model (e.g., "Smart Routing")
   */
  tooltip?: string;
};

/**
 * Media generation parameter configuration
 */
export type MediaModelParameter = {
  /**
   * Parameter name
   */
  name: string;
  /**
   * Parameter type
   */
  type: 'url' | 'text' | 'option';
  value?: string | Array<string> | number | boolean;
  /**
   * Available options for option type
   */
  options?: Array<string | number | boolean>;
  /**
   * Parameter description
   */
  description?: string;
  /**
   * Whether this parameter is required
   */
  required: boolean;
  /**
   * Whether this parameter should be displayed in UI
   */
  visible: boolean;
};

/**
 * Parameter type
 */
export type type4 = 'url' | 'text' | 'option';

/**
 * Parameter type
 */
export const type4 = {
  URL: 'url',
  TEXT: 'text',
  OPTION: 'option',
} as const;

/**
 * Provider config for media generation
 */
export type MediaGenerationModelConfig = {
  /**
   * Model ID
   */
  modelId: string;
  /**
   * Model name
   */
  modelName: string;
  /**
   * Model capabilities
   */
  capabilities?: MediaGenerationModelCapabilities;
  /**
   * Model description
   */
  description?: string;
  /**
   * Tooltip text for the model (e.g., "Smart Routing")
   */
  tooltip?: string;
  /**
   * Supported languages for translation
   */
  supportedLanguages?: Array<string>;
  /**
   * Input parameter configurations
   */
  inputParameters?: Array<MediaModelParameter>;
  /**
   * Output parameter configurations
   */
  outputParameters?: Array<MediaModelParameter>;
  /**
   * Base model for the model
   */
  baseModel?: string;
};

/**
 * Provider config for embeddings
 */
export type EmbeddingModelConfig = {
  /**
   * Embedding model ID
   */
  modelId: string;
  /**
   * Embedding model name
   */
  modelName?: string;
  /**
   * Embedding model dimension
   */
  dimensions: number;
  /**
   * Embedding model batch size
   */
  batchSize?: number;
};

/**
 * Provider config for rerankers
 */
export type RerankerModelConfig = {
  /**
   * Reranking model ID
   */
  modelId: string;
  /**
   * Reranking model name
   */
  modelName?: string;
  /**
   * Number of top results to return
   */
  topN?: number;
  /**
   * Minimum relevance score threshold (0.0-1.0)
   */
  relevanceThreshold?: number;
};

export type ProviderItemConfig =
  | LLMModelConfig
  | EmbeddingModelConfig
  | RerankerModelConfig
  | MediaGenerationModelConfig;

/**
 * Credit billing configuration for provider items
 */
export type CreditBilling = {
  /**
   * Measurement unit (e.g., token, product, second)
   */
  unit: string;
  /**
   * Credit consumption per unit for input tokens
   */
  inputCost: number;
  /**
   * Credit consumption per unit for output tokens
   */
  outputCost: number;
  /**
   * Credit consumption per unit for cache read tokens (typically 10% of input cost)
   */
  cacheReadCost?: number;
  /**
   * Credit consumption per unit for cache write tokens (typically higher than input cost)
   */
  cacheWriteCost?: number;
  /**
   * Minimum credit charge per request
   */
  minCharge: number;
  /**
   * Whether this billing is free for early bird users
   */
  isEarlyBirdFree?: boolean;
};

export type ProviderItemOption = {
  /**
   * Provider item name
   */
  name?: string;
  /**
   * Provider category
   */
  category?: ProviderCategory;
  /**
   * Provider item tier
   */
  tier?: ModelTier;
  /**
   * Provider item config
   */
  config?: ProviderItemConfig;
};

export type ProviderItem = {
  /**
   * Provider item ID
   */
  itemId: string;
  /**
   * Provider item name
   */
  name: string;
  /**
   * Whether the provider item is enabled
   */
  enabled: boolean;
  /**
   * Provider category
   */
  category: ProviderCategory;
  /**
   * Provider item tier
   */
  tier?: ModelTier;
  /**
   * Provider ID
   */
  providerId: string;
  /**
   * Provider detail info
   */
  provider?: Provider;
  /**
   * Provider item config
   */
  config?: ProviderItemConfig;
  /**
   * Provider item order
   */
  order?: number;
  /**
   * Provider item group
   */
  group?: string;
  /**
   * Credit billing info
   */
  creditBilling?: CreditBilling;
};

/**
 * Credit recharge record for user balance management
 */
export type CreditRecharge = {
  /**
   * Unique recharge record ID
   */
  rechargeId: string;
  /**
   * User UID who owns this recharge record
   */
  uid: string;
  /**
   * Original recharge amount in credits
   */
  amount: number;
  /**
   * Remaining balance for this recharge record
   */
  balance: number;
  /**
   * Whether this recharge record is enabled (false after 30 days)
   */
  enabled: boolean;
  /**
   * Recharge source type
   */
  source?: 'subscription' | 'purchase' | 'gift' | 'promotion' | 'refund' | 'commission';
  /**
   * Optional description for this recharge
   */
  description?: string;
  /**
   * Related app ID (if applicable)
   */
  appId?: string;
  /**
   * Extra data for this recharge (JSON)
   */
  extraData?: CreditRechargeExtraData;
  /**
   * Related share ID (if applicable)
   */
  shareId?: string;
  /**
   * Related share title (if applicable)
   */
  title?: string;
  /**
   * Expiration timestamp (30 days from creation)
   */
  expiresAt: string;
  /**
   * Record creation timestamp
   */
  createdAt: string;
  /**
   * Record last update timestamp
   */
  updatedAt: string;
};

/**
 * Recharge source type
 */
export type source = 'subscription' | 'purchase' | 'gift' | 'promotion' | 'refund' | 'commission';

/**
 * Recharge source type
 */
export const source = {
  SUBSCRIPTION: 'subscription',
  PURCHASE: 'purchase',
  GIFT: 'gift',
  PROMOTION: 'promotion',
  REFUND: 'refund',
  COMMISSION: 'commission',
} as const;

/**
 * Credit usage record for tracking consumption
 */
export type CreditUsage = {
  /**
   * Unique usage record ID
   */
  usageId: string;
  /**
   * User UID who consumed the credits
   */
  uid: string;
  /**
   * Amount of credits consumed
   */
  amount: number;
  /**
   * Provider item ID that consumed the credits
   */
  providerItemId?: string;
  /**
   * Model name used for this consumption
   */
  modelName?: string;
  /**
   * Type of usage that consumed credits
   */
  usageType: 'model_call' | 'media_generation' | 'embedding' | 'reranking' | 'commission' | 'other';
  /**
   * Related action result ID (if applicable)
   */
  actionResultId?: string;
  /**
   * Related pilot session ID (if applicable)
   */
  pilotSessionId?: string;
  /**
   * Optional description for this usage
   */
  description?: string;
  /**
   * Model usage details for skill execution (JSON array of model usage)
   */
  modelUsageDetails?: string;
  /**
   * Related app ID (if applicable)
   */
  appId?: string;
  /**
   * Extra data for this usage (JSON)
   */
  extraData?: CreditUsageExtraData;
  /**
   * Related share ID (if applicable)
   */
  shareId?: string;
  /**
   * Related share title (if applicable)
   */
  title?: string;
  /**
   * Usage record creation timestamp
   */
  createdAt: string;
};

/**
 * Type of usage that consumed credits
 */
export type usageType =
  | 'model_call'
  | 'media_generation'
  | 'embedding'
  | 'reranking'
  | 'commission'
  | 'other';

/**
 * Type of usage that consumed credits
 */
export const usageType = {
  MODEL_CALL: 'model_call',
  MEDIA_GENERATION: 'media_generation',
  EMBEDDING: 'embedding',
  RERANKING: 'reranking',
  COMMISSION: 'commission',
  OTHER: 'other',
} as const;

/**
 * Extra data for credit recharge
 */
export type CreditRechargeExtraData = {
  /**
   * Related app ID
   */
  appId?: string;
  /**
   * Related execution ID
   */
  executionId?: string;
  /**
   * Related share ID
   */
  shareId?: string;
  /**
   * Related share title
   */
  title?: string;
  /**
   * Commission rate
   */
  commissionRate?: number;
};

/**
 * Extra data for credit usage
 */
export type CreditUsageExtraData = {
  /**
   * Related app ID (if applicable)
   */
  appId?: string;
  /**
   * Related execution ID
   */
  executionId?: string;
  /**
   * Related share ID
   */
  shareId?: string;
  /**
   * Related share title
   */
  title?: string;
  /**
   * Commission rate
   */
  commissionRate?: number;
  /**
   * Related toolset key
   */
  toolsetKey?: string;
  /**
   * Related toolset name
   */
  toolsetName?: string;
  /**
   * Related tool key
   */
  toolKey?: string;
  /**
   * Related tool name
   */
  toolName?: string;
};

export type ListProvidersResponse = BaseResponse & {
  data?: Array<Provider>;
};

export type UpsertProviderRequest = {
  /**
   * Provider ID (only for update)
   */
  providerId?: string;
  /**
   * Provider key
   */
  providerKey?: string;
  /**
   * Provider name
   */
  name?: string;
  /**
   * Provider categories
   */
  categories?: Array<ProviderCategory>;
  /**
   * Provider API key
   */
  apiKey?: string;
  /**
   * Provider base URL
   */
  baseUrl?: string;
  /**
   * Whether the provider is enabled
   */
  enabled?: boolean;
};

export type UpsertProviderResponse = BaseResponse & {
  data?: Provider;
};

export type DeleteProviderRequest = {
  /**
   * Provider ID
   */
  providerId: string;
};

export type TestProviderConnectionRequest = {
  /**
   * Provider ID to test
   */
  providerId: string;
  /**
   * Provider category to test (optional)
   */
  category?: ProviderCategory;
};

export type ProviderTestResult = {
  /**
   * Provider ID
   */
  providerId?: string;
  /**
   * Provider key
   */
  providerKey?: string;
  /**
   * Provider name
   */
  name?: string;
  /**
   * Provider base URL
   */
  baseUrl?: string;
  /**
   * Provider categories
   */
  categories?: Array<string>;
  /**
   * Test result status
   */
  status?: 'success' | 'failed' | 'unknown';
  /**
   * Test result message
   */
  message?: string;
  /**
   * Detailed test results
   */
  details?: {
    [key: string]: unknown;
  };
  /**
   * Test timestamp
   */
  timestamp?: string;
};

/**
 * Test result status
 */
export type status5 = 'success' | 'failed' | 'unknown';

/**
 * Test result status
 */
export const status5 = {
  SUCCESS: 'success',
  FAILED: 'failed',
  UNKNOWN: 'unknown',
} as const;

export type TestProviderConnectionResponse = BaseResponse & {
  data?: ProviderTestResult;
};

export type ListProviderItemOptionsResponse = BaseResponse & {
  data?: Array<ProviderItemOption>;
};

export type ListProviderItemsResponse = BaseResponse & {
  data?: Array<ProviderItem>;
};

export type UpsertProviderItemRequest = {
  /**
   * Provider item ID (only for update)
   */
  itemId?: string;
  /**
   * Provider ID
   */
  providerId?: string;
  /**
   * Global provider item ID
   */
  globalItemId?: string;
  /**
   * Provider item name
   */
  name?: string;
  /**
   * Provider category
   */
  category?: ProviderCategory;
  /**
   * Whether the provider item is enabled
   */
  enabled?: boolean;
  /**
   * Provider item config
   */
  config?: ProviderItemConfig;
  /**
   * Provider item order
   */
  order?: number;
  /**
   * Provider item group
   */
  group?: string;
};

export type UpsertProviderItemResponse = BaseResponse & {
  data?: ProviderItem;
};

export type BatchUpsertProviderItemsRequest = {
  /**
   * Provider items to upsert
   */
  items: Array<UpsertProviderItemRequest>;
};

export type BatchUpsertProviderItemsResponse = BaseResponse & {
  /**
   * Upserted provider items
   */
  data?: Array<ProviderItem>;
};

export type DeleteProviderItemRequest = {
  /**
   * Provider item ID
   */
  itemId: string;
};

/**
 * Toolset auth type
 */
export type ToolsetAuthType = 'credentials' | 'oauth' | 'config_based';

/**
 * Toolset auth type
 */
export const ToolsetAuthType = {
  CREDENTIALS: 'credentials',
  OAUTH: 'oauth',
  CONFIG_BASED: 'config_based',
} as const;

export type ToolDefinition = {
  /**
   * Tool name
   */
  name: string;
  /**
   * Tool description dictionary for humans
   */
  descriptionDict: {
    [key: string]: unknown;
  };
  /**
   * Whether the tool is only visible to model
   */
  modelOnly?: boolean;
};

export type AuthPattern = {
  /**
   * Auth pattern type
   */
  type: ToolsetAuthType;
  /**
   * Credential items, only for `credentials` type
   */
  credentialItems?: Array<DynamicConfigItem>;
  /**
   * Auth provider, only for `oauth` type
   */
  provider?: string;
  /**
   * Auth scope, only for `oauth` type
   */
  scope?: Array<string>;
};

export type ToolsetDefinition = {
  /**
   * Toolset key
   */
  key: string;
  /**
   * Toolset type (regular, mcp, external_oauth)
   */
  type?: GenericToolsetType;
  /**
   * Whether this is a builtin toolset
   */
  builtin?: boolean;
  /**
   * Whether this is an internal toolset (cannot be selected manually)
   */
  internal?: boolean;
  /**
   * Toolset domain (used for display icon)
   */
  domain?: string;
  /**
   * Toolset label dictionary
   */
  labelDict: {
    [key: string]: unknown;
  };
  /**
   * Toolset description dictionary for humans
   */
  descriptionDict: {
    [key: string]: unknown;
  };
  /**
   * Toolset tools
   */
  tools?: Array<ToolDefinition>;
  /**
   * Whether the toolset requires auth
   */
  requiresAuth?: boolean;
  /**
   * Toolset auth patterns
   */
  authPatterns?: Array<AuthPattern>;
  /**
   * Toolset config items
   */
  configItems?: Array<DynamicConfigItem>;
};

export type ToolsetInstance = {
  /**
   * Toolset ID
   */
  toolsetId: string;
  /**
   * Toolset name
   */
  name: string;
  /**
   * Toolset key
   */
  key: string;
  /**
   * Whether the toolset is global
   */
  isGlobal?: boolean;
  /**
   * Whether the toolset is enabled
   */
  enabled?: boolean;
  /**
   * Toolset auth type
   */
  authType?: ToolsetAuthType;
  /**
   * Toolset auth data
   */
  authData?: {
    [key: string]: unknown;
  };
  /**
   * Toolset config
   */
  config?: {
    [key: string]: unknown;
  };
  /**
   * Toolset definition
   */
  definition?: ToolsetDefinition;
  /**
   * Toolset creation timestamp
   */
  createdAt?: string;
  /**
   * Toolset update timestamp
   */
  updatedAt?: string;
};

export type ListToolsetInventoryResponse = BaseResponse & {
  data?: Array<ToolsetDefinition>;
};

export type ListToolsetsResponse = BaseResponse & {
  data?: Array<ToolsetInstance>;
};

export type UpsertToolsetRequest = {
  /**
   * Toolset ID (only for update)
   */
  toolsetId?: string;
  /**
   * Toolset name
   */
  name?: string;
  /**
   * Toolset key
   */
  key?: string;
  /**
   * Whether the toolset is enabled
   */
  enabled?: boolean;
  /**
   * Toolset auth type
   */
  authType?: ToolsetAuthType;
  /**
   * Toolset auth data
   */
  authData?: {
    [key: string]: unknown;
  };
  /**
   * Toolset config
   */
  config?: {
    [key: string]: unknown;
  };
  /**
   * OAuth toolset provider
   */
  provider?: string;
  /**
   * OAuth toolset scope
   */
  scope?: Array<string>;
};

export type UpsertToolsetResponse = BaseResponse & {
  data?: ToolsetInstance;
};

export type InitiateComposioConnectionResponse = {
  /**
   * OAuth redirect URL provided by Composio.
   */
  redirectUrl: string;
  /**
   * Connection request identifier from Composio.
   */
  connectionRequestId: string;
  /**
   * Composio app slug (e.g., gmail, slack).
   */
  app: string;
};

/**
 * Current status of the Composio connection.
 */
export type ComposioConnectionStatus = 'active' | 'revoked';

/**
 * Current status of the Composio connection.
 */
export const ComposioConnectionStatus = {
  ACTIVE: 'active',
  REVOKED: 'revoked',
} as const;

export type ComposioConnectionStatusResponse = {
  status: ComposioConnectionStatus;
  /**
   * Connected account identifier returned by Composio, if available.
   */
  connectedAccountId?: string | null;
  /**
   * Composio integration identifier (app slug).
   */
  integrationId: string;
};

export type ComposioRevokeResponse = {
  /**
   * Whether the connection was revoked successfully.
   */
  success: boolean;
  /**
   * Human-readable message describing the outcome.
   */
  message: string;
};

/**
 * Context for post-processing tool execution results
 */
export type PostHandlerContext = {
  /**
   * User who executed the tool
   */
  user: User;
  /**
   * Tool name that was executed
   */
  toolName: string;
  /**
   * Toolset display name
   */
  toolsetName: string;
  /**
   * Toolset unique identifier/key
   */
  toolsetKey: string;
  /**
   * Credit cost for this tool execution
   */
  creditCost: number;
  /**
   * File name title from input params
   */
  fileNameTitle?: string;
  /**
   * Result ID from execution context
   */
  resultId?: string;
  /**
   * Result version from execution context
   */
  version?: number;
};

/**
 * Result from post-processing tool execution
 */
export type PostHandlerResult = {
  /**
   * Processed data (may be uploaded to OSS)
   */
  data: unknown;
  /**
   * Files uploaded during post-processing
   */
  files?: Array<DriveFile>;
  /**
   * Credit cost recorded
   */
  creditCost?: number;
  /**
   * Metadata about processing
   */
  metadata?: {
    [key: string]: unknown;
  };
};

/**
 * Composio connected account structure from API response
 */
export type ComposioConnectedAccount = {
  /**
   * Connected account ID
   */
  id: string;
  /**
   * Connection status
   */
  status?: string;
  toolkit?: {
    /**
     * Toolkit slug identifier
     */
    slug?: string;
  };
};

/**
 * Composio tool JSON schema structure
 */
export type ComposioToolSchema = {
  /**
   * Schema type
   */
  type?: string;
  /**
   * Schema properties
   */
  properties?: {
    [key: string]: ComposioSchemaProperty;
  };
  /**
   * Required property names
   */
  required?: Array<string>;
  [key: string]: unknown | string | ComposioSchemaProperty;
};

/**
 * Composio schema property definition
 */
export type ComposioSchemaProperty = {
  /**
   * Property type
   */
  type?: string;
  /**
   * Property description
   */
  description?: string;
  /**
   * Whether property is deprecated
   */
  deprecated?: boolean;
  [key: string]: unknown | string | boolean;
};

/**
 * Context for creating a DynamicStructuredTool. User/userId comes from getCurrentUser() at runtime.
 */
export type ToolCreationContext = {
  /**
   * Connected account ID from Composio
   */
  connectedAccountId: string;
  /**
   * Authentication type
   */
  authType: 'oauth' | 'apikey';
  /**
   * Credit cost for tool execution
   */
  creditCost: number;
  /**
   * Toolset type identifier
   */
  toolsetType: GenericToolsetType;
  /**
   * Toolset key
   */
  toolsetKey: string;
  /**
   * Toolset display name
   */
  toolsetName: string;
};

/**
 * Authentication type
 */
export type authType = 'oauth' | 'apikey';

/**
 * Authentication type
 */
export const authType = {
  OAUTH: 'oauth',
  APIKEY: 'apikey',
} as const;

export type GenericToolsetType = 'regular' | 'mcp' | 'external_oauth';

export const GenericToolsetType = {
  REGULAR: 'regular',
  MCP: 'mcp',
  EXTERNAL_OAUTH: 'external_oauth',
} as const;

export type GenericToolset = {
  /**
   * Toolset type
   */
  type: GenericToolsetType;
  /**
   * Toolset ID (toolsetId for regular toolset, name for MCP toolset)
   */
  id: string;
  /**
   * Toolset name
   */
  name: string;
  /**
   * Whether the toolset is builtin
   */
  builtin?: boolean;
  /**
   * Whether the toolset is uninstalled
   */
  uninstalled?: boolean;
  /**
   * Toolset detail
   */
  toolset?: ToolsetInstance;
  /**
   * MCP server
   */
  mcpServer?: McpServerDTO;
  /**
   * Selected tools (used for skill invocation)
   */
  selectedTools?: Array<string>;
};

export type ListToolsResponse = BaseResponse & {
  data?: Array<GenericToolset>;
};

export type ListUserToolsResponse = BaseResponse & {
  data?: Array<UserTool>;
};

export type UserTool = {
  /**
   * Toolset ID (toolsetId for installed, key for uninstalled)
   */
  toolsetId?: string;
  /**
   * Toolset key
   */
  key?: string;
  /**
   * Tool name
   */
  name?: string;
  /**
   * Tool description
   */
  description?: string;
  /**
   * Whether the tool is authorized/installed
   */
  authorized?: boolean;
  /**
   * Tool domain for favicon
   */
  domain?: string;
  /**
   * Full toolset data (only for authorized tools)
   */
  toolset?: GenericToolset;
  /**
   * Toolset definition (for unauthorized tools)
   */
  definition?: ToolsetDefinition;
};

export type DeleteToolsetRequest = {
  /**
   * Toolset ID
   */
  toolsetId: string;
};

export type ExecuteToolRequest = {
  /**
   * Toolset key
   */
  toolsetKey: string;
  /**
   * Tool method name to execute
   */
  toolName: string;
  /**
   * Tool arguments
   */
  arguments: {
    [key: string]: unknown;
  };
};

export type ExecuteToolResponse = BaseResponse & {
  /**
   * Tool execution result data
   */
  data?: {
    [key: string]: unknown;
  };
};

export type ExportToolsetDefinitionsResponse = BaseResponse & {
  data?: Array<ToolsetExportDefinition>;
};

export type ToolsetExportDefinition = {
  /**
   * Toolset unique key
   */
  key?: string;
  /**
   * Toolset display name
   */
  name?: string;
  /**
   * Toolset description
   */
  description?: string;
  tools?: Array<ToolExportDefinition>;
};

export type ToolExportDefinition = {
  /**
   * Tool method name
   */
  name?: string;
  /**
   * Tool description
   */
  description?: string;
  /**
   * JSON Schema format input parameter definition
   */
  inputSchema?: {
    [key: string]: unknown;
  };
};

export type GetToolCallResultResponse = BaseResponse & {
  data?: {
    result?: ToolCallResult;
  };
};

export type DocumentInterface = {
  /**
   * An optional identifier for the document. Ideally this should be unique across the document collection and formatted as a UUID.
   */
  id?: string;
  /**
   * The main content of the document.
   */
  pageContent?: string;
  /**
   * Metadata associated with the document.
   */
  metadata?: {
    [key: string]: unknown;
  };
};

export type InMemorySearchResponse = BaseResponse & {
  data?: Array<DocumentInterface>;
};

export type CanvasNodeType =
  | 'document'
  | 'codeArtifact'
  | 'website'
  | 'resource'
  | 'skill'
  | 'file'
  | 'tool'
  | 'skillResponse'
  | 'toolResponse'
  | 'memo'
  | 'group'
  | 'image'
  | 'video'
  | 'audio'
  | 'mediaSkill'
  | 'mediaSkillResponse'
  | 'start';

export const CanvasNodeType = {
  DOCUMENT: 'document',
  CODE_ARTIFACT: 'codeArtifact',
  WEBSITE: 'website',
  RESOURCE: 'resource',
  SKILL: 'skill',
  FILE: 'file',
  TOOL: 'tool',
  SKILL_RESPONSE: 'skillResponse',
  TOOL_RESPONSE: 'toolResponse',
  MEMO: 'memo',
  GROUP: 'group',
  IMAGE: 'image',
  VIDEO: 'video',
  AUDIO: 'audio',
  MEDIA_SKILL: 'mediaSkill',
  MEDIA_SKILL_RESPONSE: 'mediaSkillResponse',
  START: 'start',
} as const;

/**
 * Node data
 */
export type CanvasNodeData = {
  /**
   * Node title
   */
  title: string;
  /**
   * Node edited title
   * @deprecated
   */
  editedTitle?: string;
  /**
   * Node entity ID
   */
  entityId: string;
  /**
   * Node content preview
   */
  contentPreview?: string;
  /**
   * Node metadata
   */
  metadata?: {
    [key: string]: unknown;
  };
};

export type XYPosition = {
  /**
   * Node position x
   */
  x: number;
  /**
   * Node position y
   */
  y: number;
};

export type CanvasNode = {
  /**
   * Node ID
   */
  id: string;
  /**
   * Node type
   */
  type: CanvasNodeType;
  /**
   * Node position
   */
  position: XYPosition;
  /**
   * Node offset position
   */
  offsetPosition?: XYPosition;
  /**
   * Node data
   */
  data: CanvasNodeData;
  /**
   * Node style
   */
  style?: {
    [key: string]: unknown;
  };
  /**
   * Whether the node is selected
   */
  selected?: boolean;
  /**
   * Whether the node is being dragged
   */
  dragging?: boolean;
  /**
   * Parent node ID
   */
  parentId?: string;
};

export type CanvasEdge = {
  /**
   * Edge ID
   */
  id: string;
  /**
   * Edge source node ID
   */
  source: string;
  /**
   * Edge target node ID
   */
  target: string;
  /**
   * Edge type
   */
  type: string;
};

export type InitializeWorkflowRequest = {
  /**
   * Canvas ID to initialize workflow for
   */
  canvasId: string;
  /**
   * Source canvas ID
   */
  sourceCanvasId?: string;
  /**
   * Source canvas data
   */
  sourceCanvasData?: RawCanvasData;
  /**
   * Whether to create a new canvas
   */
  createNewCanvas?: boolean;
  /**
   * Node behavior when executing workflow
   */
  nodeBehavior?: 'create' | 'update';
  /**
   * Workflow variables
   */
  variables?: Array<WorkflowVariable>;
  /**
   * Start node IDs
   */
  startNodes?: Array<string>;
};

/**
 * Node behavior when executing workflow
 */
export type nodeBehavior = 'create' | 'update';

/**
 * Node behavior when executing workflow
 */
export const nodeBehavior = {
  CREATE: 'create',
  UPDATE: 'update',
} as const;

export type InitializeWorkflowResponse = BaseResponse & {
  data?: {
    /**
     * Workflow execution ID
     */
    workflowExecutionId: string;
  };
};

export type AbortWorkflowRequest = {
  /**
   * Workflow execution ID to abort
   */
  executionId: string;
};

export type WorkflowNodeExecution = {
  /**
   * Node execution ID
   */
  nodeExecutionId?: string;
  /**
   * Node ID
   */
  nodeId: string;
  /**
   * Node type
   */
  nodeType?: string;
  /**
   * Node data
   */
  nodeData?: string;
  /**
   * Node entity ID
   */
  entityId?: string;
  /**
   * New node entity ID
   */
  newEntityId?: string;
  /**
   * Node title
   */
  title?: string;
  /**
   * Node status
   */
  status?: ActionStatus;
  /**
   * Node progress
   */
  progress?: number;
  /**
   * Node error message
   */
  errorMessage?: string;
  /**
   * Node creation timestamp
   */
  createdAt?: string;
  /**
   * Node update timestamp
   */
  updatedAt?: string;
};

export type WorkflowNodeExecutionViaApi = {
  /**
   * Node ID
   */
  nodeId: string;
  /**
   * Node title
   */
  title?: string;
  /**
   * Node status
   */
  status?: ActionStatus;
  /**
   * Node error message
   */
  errorMessage?: string;
  /**
   * Node execution start time
   */
  startTime?: string;
  /**
   * Node execution end time
   */
  endTime?: string;
};

export type WorkflowNodeExecutionStatusViaApi = {
  /**
   * Node ID
   */
  nodeId: string;
  /**
   * Node status
   */
  status?: ActionStatus;
  /**
   * Node title
   */
  title?: string;
  /**
   * Node error message
   */
  errorMessage?: string;
};

export type WorkflowExecutionStatus = 'init' | 'executing' | 'finish' | 'failed';

export const WorkflowExecutionStatus = {
  INIT: 'init',
  EXECUTING: 'executing',
  FINISH: 'finish',
  FAILED: 'failed',
} as const;

export type WorkflowExecution = {
  /**
   * Workflow execution ID
   */
  executionId: string;
  /**
   * Canvas ID
   */
  canvasId?: string;
  /**
   * Workflow title
   */
  title?: string;
  /**
   * Workflow status
   */
  status?: WorkflowExecutionStatus;
  /**
   * Whether the workflow was aborted by user
   */
  abortedByUser?: boolean;
  /**
   * Node executions
   */
  nodeExecutions?: Array<WorkflowNodeExecution>;
  /**
   * Workflow app ID
   */
  appId?: string;
  /**
   * Workflow creation timestamp
   */
  createdAt?: string;
  /**
   * Workflow update timestamp
   */
  updatedAt?: string;
};

export type ListWorkflowExecutionsResponse = BaseResponse & {
  /**
   * List of workflow executions
   */
  data?: Array<WorkflowExecution>;
};

export type WorkflowTask = {
  /**
   * Unique ID for the task
   */
  id: string;
  /**
   * Display title for the task
   */
  title: string;
  /**
   * The prompt or instruction for this task
   */
  prompt: string;
  /**
   * Toolsets selected for this task
   */
  toolsets: Array<string>;
  /**
   * Tasks that must be executed before this task
   */
  dependentTasks?: Array<string>;
};

export type WorkflowPlan = {
  /**
   * Title of the workflow plan
   */
  title: string;
  /**
   * Array of workflow tasks to be executed
   */
  tasks: Array<WorkflowTask>;
  /**
   * Array of variables (aka User inputs) defined for the workflow plan
   */
  variables?: Array<WorkflowVariable>;
};

export type WorkflowPlanRecord = WorkflowPlan & {
  /**
   * Workflow plan ID
   */
  planId?: string;
  /**
   * Workflow plan version
   */
  version?: number;
  /**
   * Workflow plan creation timestamp
   */
  createdAt?: string;
  /**
   * Workflow plan update timestamp
   */
  updatedAt?: string;
};

export type GetWorkflowPlanDetailResponse = BaseResponse & {
  data?: WorkflowPlanRecord;
};

export type GetWorkflowDetailResponse = BaseResponse & {
  data?: WorkflowExecution;
};

export type CreateWorkflowAppRequest = {
  /**
   * Canvas ID
   */
  canvasId: string;
  /**
   * Workflow app title
   */
  title: string;
  /**
   * Workflow app description
   */
  description: string;
  /**
   * Workflow app query
   */
  query: string;
  /**
   * Workflow app variables
   */
  variables: Array<WorkflowVariable>;
  /**
   * Result node IDs
   */
  resultNodeIds?: Array<string>;
  /**
   * Cover image storage key
   */
  coverStorageKey: string;
  /**
   * Whether remix is enabled for this app
   */
  remixEnabled?: boolean;
  /**
   * Whether to publish this app to the community
   */
  publishToCommunity?: boolean;
};

export type DeleteWorkflowAppRequest = {
  /**
   * Workflow app ID
   */
  appId: string;
};

export type WorkflowApp = {
  /**
   * Workflow app ID
   */
  appId: string;
  /**
   * Share ID for public access and URL generation
   */
  shareId?: string;
  /**
   * Workflow app title
   */
  title?: string;
  /**
   * Workflow app description
   */
  description?: string;
  /**
   * Workflow app owner
   */
  owner?: ShareUser;
  /**
   * Canvas ID
   */
  canvasId: string;
  /**
   * Workflow app query
   */
  query?: string;
  /**
   * Workflow app variables
   */
  variables: Array<WorkflowVariable>;
  /**
   * Result node IDs
   */
  resultNodeIds?: Array<string>;
  /**
   * Whether remix is enabled for this app
   */
  remixEnabled?: boolean;
  /**
   * Cover image URL
   */
  coverUrl?: string;
  /**
   * Whether to publish this app to the community
   */
  publishToCommunity?: boolean;
  /**
   * Community publish review status
   */
  publishReviewStatus?: string;
  /**
   * Workflow app creation timestamp
   */
  createdAt?: string;
  /**
   * Workflow app update timestamp
   */
  updatedAt?: string;
  /**
   * Voucher trigger result when publishing to community
   */
  voucherTriggerResult?: VoucherTriggerResult;
};

export type CreateWorkflowAppResponse = BaseResponse & {
  data?: WorkflowApp;
};

export type GetWorkflowAppDetailResponse = BaseResponse & {
  data?: WorkflowApp;
};

export type ListWorkflowAppsResponse = BaseResponse & {
  /**
   * List of workflow apps
   */
  data?: Array<WorkflowApp>;
};

/**
 * Template generation status
 */
export type TemplateGenerationStatus = 'idle' | 'pending' | 'generating' | 'completed' | 'failed';

/**
 * Template generation status
 */
export const TemplateGenerationStatus = {
  IDLE: 'idle',
  PENDING: 'pending',
  GENERATING: 'generating',
  COMPLETED: 'completed',
  FAILED: 'failed',
} as const;

export type GetTemplateGenerationStatusResponse = BaseResponse & {
  data: {
    status: TemplateGenerationStatus;
    /**
     * Generated template content
     */
    templateContent?: string | null;
    /**
     * Error message if generation failed
     */
    error?: string | null;
    /**
     * Last update time
     */
    updatedAt: string;
    /**
     * Creation time
     */
    createdAt: string;
  };
};

export type ExecuteWorkflowAppRequest = {
  /**
   * Workflow app share ID for execution
   */
  shareId: string;
  /**
   * Workflow app variables
   */
  variables: Array<WorkflowVariable>;
};

export type ExecuteWorkflowAppResult = {
  /**
   * Workflow execution ID
   */
  executionId: string;
};

export type ExecuteWorkflowAppResponse = BaseResponse & {
  data?: ExecuteWorkflowAppResult;
};

export type ValueType = 'text' | 'resource';

export const ValueType = {
  TEXT: 'text',
  RESOURCE: 'resource',
} as const;

export type ResourceValue = {
  /**
   * Resource name
   */
  name: string;
  /**
   * Resource file type
   */
  fileType: VariableResourceType;
  /**
   * DriveFile ID (primary identifier for resource)
   */
  fileId?: string;
  /**
   * Resource storage key (legacy, for backward compatibility)
   */
  storageKey?: string;
  /**
   * Resource ID (deprecated, use fileId instead)
   */
  entityId?: string;
};

export type VariableValue = {
  /**
   * Variable type
   */
  type: ValueType;
  /**
   * Variable text value (for text type)
   */
  text?: string;
  /**
   * Variable resource value (for resource type)
   */
  resource?: ResourceValue;
};

export type VariableResourceType = 'document' | 'image' | 'video' | 'audio';

export const VariableResourceType = {
  DOCUMENT: 'document',
  IMAGE: 'image',
  VIDEO: 'video',
  AUDIO: 'audio',
} as const;

/**
 * Workflow variable definition
 */
export type WorkflowVariable = {
  /**
   * Variable ID, unique and readonly
   */
  variableId: string;
  /**
   * Variable name used in the workflow
   */
  name: string;
  /**
   * Variable values
   */
  value: Array<VariableValue>;
  /**
   * Variable description
   */
  description?: string;
  /**
   * Variable created at
   */
  createdAt?: string;
  /**
   * Variable updated at
   */
  updatedAt?: string;
  /**
   * Variable type
   */
  variableType?: 'string' | 'option' | 'resource';
  /**
   * Whether the variable is required. Defaults to false.
   */
  required?: boolean;
  /**
   * Whether the variable value is single (not multiple)
   */
  isSingle?: boolean;
  /**
   * Array of options (only valid when variable type is `option`)
   */
  options?: Array<string>;
  /**
   * Supported resource types (only valid when variable type is resource)
   */
  resourceTypes?: Array<VariableResourceType>;
};

/**
 * Variable type
 */
export type variableType = 'string' | 'option' | 'resource';

/**
 * Variable type
 */
export const variableType = {
  STRING: 'string',
  OPTION: 'option',
  RESOURCE: 'resource',
} as const;

export type GetWorkflowVariablesResponse = BaseResponse & {
  /**
   * List of workflow variables
   */
  data?: Array<WorkflowVariable>;
};

export type UpdateWorkflowVariablesRequest = {
  /**
   * Canvas ID
   */
  canvasId: string;
  /**
   * List of workflow variables
   */
  variables: Array<WorkflowVariable>;
  /**
   * Whether to archive existing drive files associated with old resource variables before updating
   */
  archiveOldFiles?: boolean;
};

export type UpdateWorkflowVariablesResponse = BaseResponse & {
  /**
   * Updated list of workflow variables
   */
  data?: Array<WorkflowVariable>;
};

export type DriveFileCategory = 'document' | 'image' | 'video' | 'audio' | 'others';

export const DriveFileCategory = {
  DOCUMENT: 'document',
  IMAGE: 'image',
  VIDEO: 'video',
  AUDIO: 'audio',
  OTHERS: 'others',
} as const;

export type DriveFileSource = 'manual' | 'variable' | 'agent';

export const DriveFileSource = {
  MANUAL: 'manual',
  VARIABLE: 'variable',
  AGENT: 'agent',
} as const;

export type DriveFileScope = 'present' | 'archive';

export const DriveFileScope = {
  PRESENT: 'present',
  ARCHIVE: 'archive',
} as const;

export type DriveFile = {
  /**
   * Drive file ID
   */
  fileId: string;
  /**
   * Canvas ID
   */
  canvasId: string;
  /**
   * Drive file name
   */
  name: string;
  /**
   * Drive file type
   */
  type: string;
  /**
   * Drive file category
   */
  category?: DriveFileCategory;
  /**
   * Drive file source
   */
  source?: DriveFileSource;
  /**
   * Drive file scope
   */
  scope?: DriveFileScope;
  /**
   * Drive file size
   */
  size?: number;
  /**
   * Drive file summary
   */
  summary?: string;
  /**
   * Object storage key for the file
   */
  storageKey?: string;
  /**
   * Related variable ID
   */
  variableId?: string;
  /**
   * Action result ID
   */
  resultId?: string;
  /**
   * Action result version
   */
  resultVersion?: number;
  /**
   * Drive file content (only used for model input)
   */
  content?: string;
  /**
   * Drive file creation timestamp
   */
  createdAt?: string;
  /**
   * Drive file update timestamp
   */
  updatedAt?: string;
  /**
   * Private access URL for the file (requires authentication)
   */
  url?: string;
};

/**
 * Status of an export job
 */
export type ExportJobStatus = 'pending' | 'processing' | 'completed' | 'failed';

/**
 * Status of an export job
 */
export const ExportJobStatus = {
  PENDING: 'pending',
  PROCESSING: 'processing',
  COMPLETED: 'completed',
  FAILED: 'failed',
} as const;

export type ExportJob = {
  /**
   * Export job ID
   */
  jobId: string;
  /**
   * Source file ID being exported
   */
  fileId?: string;
  status: ExportJobStatus;
  /**
   * Export format
   */
  format?: 'pdf' | 'docx';
  /**
   * Output file name
   */
  name?: string;
  /**
   * Error message if job failed
   */
  error?: string;
  /**
   * Job creation timestamp
   */
  createdAt?: string;
};

/**
 * Export format
 */
export type format2 = 'pdf' | 'docx';

/**
 * Export format
 */
export const format2 = {
  PDF: 'pdf',
  DOCX: 'docx',
} as const;

export type StartExportJobRequest = {
  /**
   * File ID to export
   */
  fileId: string;
  /**
   * Target export format
   */
  format: 'pdf' | 'docx';
};

export type StartExportJobResponse = BaseResponse & {
  data?: ExportJob;
};

export type GetExportJobStatusResponse = BaseResponse & {
  data?: ExportJob;
};

export type ListDriveFilesResponse = BaseResponse & {
  /**
   * List of drive files
   */
  data?: Array<DriveFile>;
};

export type UpsertDriveFileRequest = {
  /**
   * File ID (required for update)
   */
  fileId?: string;
  /**
   * Canvas ID
   */
  canvasId: string;
  /**
   * Drive file name
   */
  name: string;
  /**
   * Drive file type (MIME type)
   */
  type?: string;
  /**
   * Brief summary for this file
   */
  summary?: string;
  /**
   * File content (for plain text files)
   */
  content?: string;
  /**
   * File storage key (for uploaded files)
   */
  storageKey?: string;
  /**
   * External URL to download from
   */
  externalUrl?: string;
  /**
   * File source
   */
  source?: DriveFileSource;
  /**
   * Related variable ID
   */
  variableId?: string;
  /**
   * Related agent result ID
   */
  resultId?: string;
  /**
   * Related agent result version
   */
  resultVersion?: number;
  /**
   * Whether to archive existing files with the same variableId or resultId before creating new file
   */
  archiveFiles?: boolean;
};

export type BatchCreateDriveFilesRequest = {
  /**
   * Canvas ID
   */
  canvasId: string;
  /**
   * List of drive files
   */
  files: Array<UpsertDriveFileRequest>;
};

export type BatchCreateDriveFilesResponse = BaseResponse & {
  /**
   * List of drive files
   */
  data?: Array<DriveFile>;
};

export type UpsertDriveFileResponse = BaseResponse & {
  data?: DriveFile;
};

export type DeleteDriveFileRequest = {
  /**
   * Drive file ID
   */
  fileId: string;
};

export type SendEmailRequest = {
  /**
   * Email subject
   */
  subject: string;
  /**
   * Email HTML content
   */
  html: string;
  /**
   * Email recipient. If not specified, the email will be sent to current user.
   */
  to?: string;
  /**
   * Email sender. If not specified, server will use the default sender.
   */
  from?: string;
  /**
   * Email attachments, should be array of URLs.
   */
  attachments?: Array<string>;
};

export type GenerateAppTemplateRequest = {
  /**
   * Canvas ID to generate template for
   */
  canvasId: string;
};

export type AppTemplateResult = {
  /**
   * Template with placeholders for user interaction.
   * Variables are represented using handlebars syntax (e.g., {{variableName}}).
   *
   */
  templateContent: string;
  /**
   * List of related workflow variables used in the template
   */
  variables: Array<WorkflowVariable>;
  metadata: {
    /**
     * Template generation timestamp (for version control)
     */
    extractedAt: number;
    /**
     * Total variable count (for frontend statistics display)
     */
    variableCount: number;
    /**
     * Original prompt count (for quality assessment)
     */
    promptCount?: number;
    /**
     * Canvas complexity level
     */
    canvasComplexity?: 'simple' | 'medium' | 'complex';
    /**
     * Workflow type (for template classification and display)
     */
    workflowType?: string;
    /**
     * Template version number (supports template iteration)
     */
    templateVersion?: number;
    /**
     * Workflow title for display
     */
    workflowTitle?: string;
    /**
     * Workflow description
     */
    workflowDescription?: string;
    /**
     * Estimated execution time
     */
    estimatedExecutionTime?: string;
    /**
     * Skill tags for categorization
     */
    skillTags?: Array<string>;
  };
};

/**
 * Canvas complexity level
 */
export type canvasComplexity = 'simple' | 'medium' | 'complex';

/**
 * Canvas complexity level
 */
export const canvasComplexity = {
  SIMPLE: 'simple',
  MEDIUM: 'medium',
  COMPLEX: 'complex',
} as const;

export type FormDefinition = {
  /**
   * Form ID
   */
  formId: string;
  /**
   * Form title
   */
  title: string;
  /**
   * Form description
   */
  description?: string;
  /**
   * JSON Schema definition (RJSF compatible)
   */
  schema: string;
  /**
   * UI Schema definition (RJSF compatible for controlling UI elements like emoji, layout, helper text)
   */
  uiSchema?: string;
  /**
   * Form status
   */
  status?: 'draft' | 'published' | 'archived';
  /**
   * Creation timestamp
   */
  createdAt: string;
  /**
   * Last update timestamp
   */
  updatedAt: string;
  /**
   * Soft delete timestamp
   */
  deletedAt?: string;
};

/**
 * Form status
 */
export type status6 = 'draft' | 'published' | 'archived';

/**
 * Form status
 */
export const status6 = {
  DRAFT: 'draft',
  PUBLISHED: 'published',
  ARCHIVED: 'archived',
} as const;

export type FormSubmission = {
  /**
   * Submission ID
   */
  submissionId?: string;
  /**
   * Associated form ID
   */
  formId: string;
  /**
   * User ID who submitted the form
   */
  uid: string;
  /**
   * Submission answers (JSON object with field values)
   */
  answers: string;
  /**
   * Submission status
   */
  status?: 'draft' | 'submitted' | 'reviewed';
  /**
   * Creation timestamp
   */
  createdAt: string;
  /**
   * Last update timestamp
   */
  updatedAt: string;
};

/**
 * Submission status
 */
export type status7 = 'draft' | 'submitted' | 'reviewed';

/**
 * Submission status
 */
export const status7 = {
  DRAFT: 'draft',
  SUBMITTED: 'submitted',
  REVIEWED: 'reviewed',
} as const;

/**
 * RJSF compatible field schema definition
 */
export type FormFieldSchema = {
  /**
   * Field type
   */
  type?: 'string' | 'number' | 'integer' | 'boolean' | 'object' | 'array';
  /**
   * Field display title
   */
  title?: string;
  /**
   * Field description/helper text
   */
  description?: string;
  /**
   * Enumeration values for radio/select fields
   */
  enum?: Array<string>;
  /**
   * Display names for enum values
   */
  enumNames?: Array<string>;
  /**
   * Default value for the field
   */
  default?: unknown;
  /**
   * Minimum string length
   */
  minLength?: number;
  /**
   * Maximum string length
   */
  maxLength?: number;
  /**
   * Regex pattern for validation
   */
  pattern?: string;
  /**
   * Minimum numeric value
   */
  minimum?: number;
  /**
   * Maximum numeric value
   */
  maximum?: number;
  /**
   * Whether this field is required
   */
  required?: boolean;
};

/**
 * Field type
 */
export type type5 = 'string' | 'number' | 'integer' | 'boolean' | 'object' | 'array';

/**
 * Field type
 */
export const type5 = {
  STRING: 'string',
  NUMBER: 'number',
  INTEGER: 'integer',
  BOOLEAN: 'boolean',
  OBJECT: 'object',
  ARRAY: 'array',
} as const;

/**
 * RJSF UI schema for controlling form appearance and behavior
 */
export type FormUiSchema = {
  /**
   * Widget type override
   */
  'ui:widget'?:
    | 'text'
    | 'textarea'
    | 'select'
    | 'radio'
    | 'checkbox'
    | 'checkboxes'
    | 'date'
    | 'email'
    | 'password';
  /**
   * Input placeholder text
   */
  'ui:placeholder'?: string;
  /**
   * Help text displayed below the field
   */
  'ui:help'?: string;
  /**
   * Widget-specific options (can include emoji, layout settings, etc.)
   */
  'ui:options'?: {
    /**
     * Emoji to display with the field
     */
    emoji?: string;
    /**
     * Layout style
     */
    layout?: 'horizontal' | 'vertical';
    /**
     * Number of rows for textarea
     */
    rows?: number;
    /**
     * Whether to display radio/checkbox options inline
     */
    inline?: boolean;
  };
};

/**
 * Widget type override
 */
export type ui_widget =
  | 'text'
  | 'textarea'
  | 'select'
  | 'radio'
  | 'checkbox'
  | 'checkboxes'
  | 'date'
  | 'email'
  | 'password';

/**
 * Widget type override
 */
export const ui_widget = {
  TEXT: 'text',
  TEXTAREA: 'textarea',
  SELECT: 'select',
  RADIO: 'radio',
  CHECKBOX: 'checkbox',
  CHECKBOXES: 'checkboxes',
  DATE: 'date',
  EMAIL: 'email',
  PASSWORD: 'password',
} as const;

/**
 * Layout style
 */
export type layout = 'horizontal' | 'vertical';

/**
 * Layout style
 */
export const layout = {
  HORIZONTAL: 'horizontal',
  VERTICAL: 'vertical',
} as const;

/**
 * Type of billing for a tool method
 */
export type BillingType = 'per_call' | 'per_quantity';

/**
 * Type of billing for a tool method
 */
export const BillingType = {
  PER_CALL: 'per_call',
  PER_QUANTITY: 'per_quantity',
} as const;

export type BillingConfig = {
  /**
   * Whether billing is enabled
   */
  enabled: boolean;
  type: BillingType;
  /**
   * Credits per call (for PER_CALL type)
   */
  creditsPerCall?: number;
  /**
   * Credits per unit (for PER_QUANTITY type)
   */
  creditsPerUnit?: number;
  /**
   * Field name to extract quantity from (for PER_QUANTITY type)
   */
  quantityField?: string;
  /**
   * Maximum credits per single call
   */
  maxCredits?: number;
  /**
   * Transform function name for custom quantity calculation
   */
  quantityTransform?: string;
};

/**
 * JSON Schema property type
 */
export type SchemaPropertyType = 'string' | 'number' | 'boolean' | 'object' | 'array';

/**
 * JSON Schema property type
 */
export const SchemaPropertyType = {
  STRING: 'string',
  NUMBER: 'number',
  BOOLEAN: 'boolean',
  OBJECT: 'object',
  ARRAY: 'array',
} as const;

/**
 * Resource type for tool operations (subset of ResourceType)
 */
export type ToolResourceType = 'audio' | 'video' | 'image' | 'document';

/**
 * Resource type for tool operations (subset of ResourceType)
 */
export const ToolResourceType = {
  AUDIO: 'audio',
  VIDEO: 'video',
  IMAGE: 'image',
  DOCUMENT: 'document',
} as const;

export type SchemaProperty = {
  type: SchemaPropertyType;
  /**
   * Property description
   */
  description?: string;
  /**
   * Whether this property is a resource reference
   */
  isResource?: boolean;
  /**
   * Format for the property value. For resources: base64, url, binary, text. For strings: date-time, uri, email, etc.
   */
  format?: string;
  /**
   * Whether this field accepts file uploads (Composio-specific marker)
   */
  file_uploadable?: boolean;
  /**
   * Constant value for discriminator matching in oneOf/anyOf
   */
  const?: unknown;
  /**
   * One of the listed schemas must match
   */
  oneOf?: Array<SchemaProperty>;
  /**
   * Any of the listed schemas can match
   */
  anyOf?: Array<SchemaProperty>;
  /**
   * Minimum length (for string)
   */
  minLength?: number;
  /**
   * Maximum length (for string)
   */
  maxLength?: number;
  /**
   * Minimum value (for number)
   */
  min?: number;
  /**
   * Maximum value (for number)
   */
  max?: number;
  /**
   * Enum values
   */
  enum?: Array<string>;
  /**
   * Default value
   */
  default?: unknown;
  /**
   * Whether this property is optional
   */
  optional?: boolean;
  /**
   * Nested properties (for object type)
   */
  properties?: {
    [key: string]: SchemaProperty;
  };
  items?: SchemaProperty;
  /**
   * Required properties (for object type)
   */
  required?: Array<string>;
};

/**
 * JSON schema definition for request/response with resource field markers
 */
export type JsonSchema = {
  /**
   * Schema type
   */
  type: 'object';
  /**
   * Schema properties
   */
  properties: {
    [key: string]: SchemaProperty;
  };
  /**
   * Required property names
   */
  required?: Array<string>;
  /**
   * Field names to omit from the response (e.g., ['thoughtSignature'])
   */
  omitFields?: Array<string>;
};

/**
 * Schema type
 */
export type type6 = 'object';

/**
 * Schema type
 */
export const type6 = {
  OBJECT: 'object',
} as const;

export type ResponseSchema = JsonSchema;

export type ResourceField = {
  /**
   * JSONPath to the resource field
   */
  fieldPath: string;
  /**
   * Resource type hint (optional, can be inferred from file MIME type)
   */
  type?: ToolResourceType;
  /**
   * Whether this field is an array of resources
   */
  isArray: boolean;
  /**
   * Format to convert resource content to (default is binary). Options: base64, url, binary, text
   */
  format?: string;
};

/**
 * HTTP method
 */
export type HttpMethod = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';

/**
 * HTTP method
 */
export const HttpMethod = {
  GET: 'GET',
  POST: 'POST',
  PUT: 'PUT',
  DELETE: 'DELETE',
  PATCH: 'PATCH',
} as const;

export type ToolMethodConfig = {
  /**
   * Method name (e.g., 'text_to_speech')
   */
  name: string;
  /**
   * Version number (incremental integer, derived from pk or timestamp)
   */
  version?: number;
  /**
   * Human-readable display name
   */
  displayName?: string;
  /**
   * Method description for LLM
   */
  description: string;
  /**
   * API endpoint URL
   */
  endpoint: string;
  method?: HttpMethod;
  /**
   * Input parameter schema (JSON string)
   */
  schema: string;
  /**
   * Response schema for resource identification (JSON string)
   */
  responseSchema: string;
  billing?: BillingConfig;
  /**
   * Custom handler class name (optional)
   */
  customHandler?: string;
  /**
   * Whether to use SDK instead of HTTP (optional)
   */
  useSdk?: boolean;
  /**
   * SDK package name (if useSdk is true)
   */
  sdkPackage?: string;
  /**
   * SDK method path (e.g., 'client.textToSpeech.convert')
   */
  sdkMethod?: string;
  /**
   * Request timeout in milliseconds
   */
  timeout?: number;
  /**
   * Maximum retries on failure
   */
  maxRetries?: number;
};

/**
 * Credential configuration
 */
export type CredentialConfig = {
  /**
   * API key
   */
  apiKey?: string;
  /**
   * API secret
   */
  apiSecret?: string;
  /**
   * OAuth access token
   */
  accessToken?: string;
  /**
   * OAuth refresh token
   */
  refreshToken?: string;
  [key: string]: string | undefined;
};

export type ToolsetConfig = {
  /**
   * Toolset inventory key (e.g., 'fish_audio', 'heygen')
   */
  inventoryKey: string;
  /**
   * Tool domain (e.g., 'fish.audio')
   */
  domain: string;
  /**
   * Display name
   */
  name?: string;
  credentials?: CredentialConfig;
  /**
   * Tool methods
   */
  methods: Array<ToolMethodConfig>;
  /**
   * Configuration version
   */
  version?: number;
  /**
   * Configuration metadata
   */
  metadata?: {
    [key: string]: unknown;
  };
};

export type ParsedMethodConfig = {
  /**
   * Method name
   */
  name: string;
  /**
   * Version number
   */
  version?: number;
  /**
   * Human-readable display name
   */
  displayName?: string;
  /**
   * Method description for LLM
   */
  description: string;
  /**
   * API endpoint URL
   */
  endpoint: string;
  method?: HttpMethod;
  schema: JsonSchema;
  responseSchema: JsonSchema;
  billing?: BillingConfig;
  /**
   * Custom handler class name
   */
  customHandler?: string;
  /**
   * Whether to use SDK instead of HTTP
   */
  useSdk?: boolean;
  /**
   * SDK package name
   */
  sdkPackage?: string;
  /**
   * SDK method path
   */
  sdkMethod?: string;
  /**
   * Request timeout in milliseconds
   */
  timeout?: number;
  /**
   * Maximum retries on failure
   */
  maxRetries?: number;
  /**
   * Whether to use multipart/form-data encoding
   */
  useFormData?: boolean;
};

export type ParsedToolsetConfig = {
  /**
   * Toolset inventory key (e.g., 'fish_audio', 'heygen')
   */
  inventoryKey: string;
  /**
   * Tool domain
   */
  domain: string;
  /**
   * Display name
   */
  name?: string;
  credentials?: CredentialConfig;
  /**
   * Parsed methods with JSON schemas
   */
  methods: Array<ParsedMethodConfig>;
  /**
   * Configuration version
   */
  version?: number;
  /**
   * Configuration metadata
   */
  metadata?: {
    [key: string]: unknown;
  };
};

export type ConfigChangeEvent = {
  /**
   * Toolset key
   */
  toolsetKey: string;
  /**
   * Configuration MD5 hash
   */
  md5: string;
  config: ToolsetConfig;
  /**
   * Event timestamp
   */
  timestamp: string;
};

export type AdapterRequest = {
  /**
   * API endpoint or SDK method path
   */
  endpoint: string;
  method?: HttpMethod;
  /**
   * Request parameters
   */
  params: {
    [key: string]: unknown;
  };
  /**
   * Request headers (for HTTP adapter)
   */
  headers?: {
    [key: string]: string;
  };
  /**
   * Credentials for authentication
   */
  credentials?: {
    [key: string]: unknown;
  };
  /**
   * Request timeout in milliseconds
   */
  timeout?: number;
  /**
   * Whether to use multipart/form-data (for HTTP adapter)
   */
  useFormData?: boolean;
};

export type AdapterResponse = {
  /**
   * Response data
   */
  data: unknown;
  /**
   * HTTP status code (for HTTP adapter)
   */
  status?: number;
  /**
   * Response headers (for HTTP adapter)
   */
  headers?: {
    [key: string]: string;
  };
  /**
   * Raw response body (for debugging)
   */
  raw?: unknown;
};

export type HttpAdapterConfig = {
  /**
   * Base URL for the API
   */
  baseUrl?: string;
  /**
   * Default headers
   */
  defaultHeaders?: {
    [key: string]: string;
  };
  /**
   * Request timeout in milliseconds
   */
  timeout?: number;
  /**
   * Maximum retries
   */
  maxRetries?: number;
  /**
   * Retry delay in milliseconds
   */
  retryDelay?: number;
  /**
   * HTTP proxy URL
   */
  proxy?: string;
  /**
   * Polling configuration for async task tracking
   */
  polling?: PollingConfig;
};

export type PollingConfig = {
  /**
   * Status check endpoint template (e.g., "/v1/tasks/{id}" or "/v1/video_status.get?video_id={id}")
   */
  statusUrl: string;
  /**
   * HTTP method for status check (GET or POST)
   */
  statusMethod?: 'GET' | 'POST';
  /**
   * Request body template for POST status check. Supports placeholders like {task_id}, {req_key}
   */
  statusBody?: {
    [key: string]: unknown;
  };
  /**
   * JSON path to extract task ID from initial response (e.g., "data.task_id")
   */
  taskIdPath?: string;
  /**
   * JSON path to extract status from polling response (e.g., "data.status")
   */
  statusPath?: string;
  /**
   * JSON path to extract result data from completed response (e.g., "data.resp_data")
   */
  resultPath?: string;
  /**
   * List of status values indicating completion (e.g., ["done", "completed"])
   */
  completedStatuses?: Array<string>;
  /**
   * List of status values indicating failure (e.g., ["failed", "error"])
   */
  failedStatuses?: Array<string>;
  /**
   * Maximum wait time in seconds
   */
  maxWaitSeconds?: number;
  /**
   * Poll interval in seconds
   */
  intervalSeconds?: number;
};

/**
 * HTTP method for status check (GET or POST)
 */
export type statusMethod = 'GET' | 'POST';

/**
 * HTTP method for status check (GET or POST)
 */
export const statusMethod = {
  GET: 'GET',
  POST: 'POST',
} as const;

export type SdkAdapterConfig = {
  /**
   * NPM package name
   */
  packageName: string;
  /**
   * Method path in the SDK (e.g., 'client.textToSpeech.convert')
   */
  methodPath: string;
  /**
   * SDK client initialization function (runtime only, not serializable)
   */
  clientFactory?: unknown;
  /**
   * Parameter transformer function (runtime only, not serializable)
   */
  paramTransformer?: unknown;
};

export type RetryConfig = {
  /**
   * Maximum number of retries
   */
  maxRetries: number;
  /**
   * Initial retry delay in milliseconds
   */
  initialDelay: number;
  /**
   * Maximum retry delay in milliseconds
   */
  maxDelay: number;
  /**
   * Backoff multiplier
   */
  backoffMultiplier: number;
  /**
   * Status codes that should trigger a retry
   */
  retryableStatusCodes?: Array<number>;
  /**
   * Error codes that should trigger a retry
   */
  retryableErrorCodes?: Array<string>;
};

/**
 * Circuit breaker state
 */
export type CircuitBreakerState = 'closed' | 'open' | 'half_open';

/**
 * Circuit breaker state
 */
export const CircuitBreakerState = {
  CLOSED: 'closed',
  OPEN: 'open',
  HALF_OPEN: 'half_open',
} as const;

export type CircuitBreakerConfig = {
  /**
   * Failure threshold to open the circuit
   */
  failureThreshold: number;
  /**
   * Success threshold to close the circuit from half-open
   */
  successThreshold: number;
  /**
   * Timeout in milliseconds before attempting to close
   */
  timeout: number;
  /**
   * Rolling window size for failure counting
   */
  rollingWindowSize: number;
};

export type HandlerRequest = {
  /**
   * Provider/toolset identifier
   */
  provider: string;
  /**
   * Method name
   */
  method: string;
  /**
   * Input parameters
   */
  params: {
    [key: string]: unknown;
  };
  user?: User;
  /**
   * Request metadata
   */
  metadata?: {
    [key: string]: unknown;
  };
};

export type UploadResultMetadata = {
  /**
   * File size in bytes
   */
  size?: number;
  /**
   * MIME type
   */
  mimeType?: string;
  /**
   * Duration (for audio/video)
   */
  duration?: number;
  /**
   * Width (for images/video)
   */
  width?: number;
  /**
   * Height (for images/video)
   */
  height?: number;
  /**
   * File format
   */
  format?: string;
};

export type UploadResult = {
  /**
   * File ID in database (DriveService)
   */
  fileId: string;
  resourceType: ToolResourceType;
  metadata?: UploadResultMetadata;
};

export type HandlerResponse = {
  /**
   * Success status
   */
  success: boolean;
  /**
   * Response data (object or array of objects)
   */
  data?:
    | {
        [key: string]: unknown;
      }
    | Array<{
        [key: string]: unknown;
      }>;
  /**
   * Local file path (if file was saved)
   */
  localPath?: string;
  /**
   * Storage key (if file was uploaded)
   */
  storageKey?: string;
  /**
   * Entity ID (if resource was created)
   */
  entityId?: string;
  /**
   * File ID in database
   */
  fileId?: string;
  /**
   * List of drive files generated by the tool
   */
  files?: Array<DriveFile>;
  /**
   * CDN/public URL
   */
  url?: string;
  /**
   * Error information
   */
  error?: string;
  /**
   * Error code
   */
  errorCode?: string;
  /**
   * Response metadata
   */
  metadata?: {
    [key: string]: unknown;
  };
};

export type HandlerContext = {
  /**
   * User information for billing and tracking
   */
  user?: User;
  /**
   * Credentials for authentication
   */
  credentials?: {
    [key: string]: unknown;
  };
  /**
   * Response schema for identifying resource fields via traversal
   */
  responseSchema?: JsonSchema;
  /**
   * Request start timestamp
   */
  startTime: number;
};

export type HandlerConfig = {
  /**
   * API endpoint URL
   */
  endpoint: string;
  method?: HttpMethod;
  /**
   * Credentials
   */
  credentials?: {
    [key: string]: unknown;
  };
  /**
   * Response schema for identifying resource fields via traversal
   */
  responseSchema?: JsonSchema;
  /**
   * Request timeout (ms)
   */
  timeout?: number;
  /**
   * Maximum retries
   */
  maxRetries?: number;
  /**
   * Whether to use multipart/form-data
   */
  useFormData?: boolean;
};

export type FileMetadata = {
  /**
   * Entity ID
   */
  entityId: string;
  /**
   * Storage key
   */
  storageKey: string;
  /**
   * File type
   */
  type: string;
  /**
   * MIME type
   */
  mimeType?: string;
  /**
   * Visibility
   */
  visibility: 'public' | 'private';
  /**
   * File size in bytes
   */
  size?: number;
  /**
   * Additional metadata
   */
  metadata?: {
    [key: string]: unknown;
  };
};

/**
 * Visibility
 */
export type visibility = 'public' | 'private';

/**
 * Visibility
 */
export const visibility = {
  PUBLIC: 'public',
  PRIVATE: 'private',
} as const;

export type UploadMetadata = {
  /**
   * Provider name
   */
  provider: string;
  /**
   * Method name
   */
  method: string;
  type: ToolResourceType;
  /**
   * MIME type
   */
  mimeType?: string;
  /**
   * User ID
   */
  userId?: string;
};

export type HandlerExecutionResult = {
  /**
   * Success status
   */
  success: boolean;
  /**
   * Result data
   */
  data?: unknown;
  error?: {
    /**
     * Error code
     */
    code?: string;
    /**
     * Error message
     */
    message?: string;
    /**
     * Error details
     */
    details?: {
      [key: string]: unknown;
    };
  };
  metrics?: {
    /**
     * Execution duration in milliseconds
     */
    duration?: number;
    /**
     * Number of retries
     */
    retries?: number;
  };
};

export type ToolMetadataBilling = {
  /**
   * Whether billing is enabled
   */
  enabled: boolean;
  /**
   * Billing type
   */
  type: 'per_call' | 'per_quantity';
  /**
   * Credits per call
   */
  creditsPerCall?: number;
  /**
   * Credits per unit
   */
  creditsPerUnit?: number;
};

/**
 * Billing type
 */
export type type7 = 'per_call' | 'per_quantity';

/**
 * Billing type
 */
export const type7 = {
  PER_CALL: 'per_call',
  PER_QUANTITY: 'per_quantity',
} as const;

export type ToolMetadata = {
  /**
   * Version number (incremental integer for version tracking)
   */
  version: number;
  /**
   * Toolset key
   */
  toolsetKey: string;
  /**
   * Method name
   */
  methodName: string;
  billing?: ToolMetadataBilling;
  /**
   * Resource types handled by this tool
   */
  resourceTypes?: Array<string>;
  /**
   * Supported file extensions for each resource type
   */
  resourceExtensions?: {
    [key: string]: Array<string>;
  };
};

export type ToolInstantiationContextUser = {
  /**
   * User ID
   */
  uid: string;
  /**
   * User name
   */
  name?: string;
  /**
   * User email
   */
  email?: string;
};

export type ToolInstantiationContext = {
  user: ToolInstantiationContextUser;
  /**
   * Toolset ID
   */
  toolsetId: string;
  /**
   * Configuration ID (for versioned configs)
   */
  configId?: string;
  /**
   * Additional context
   */
  metadata?: {
    [key: string]: unknown;
  };
};

export type ToolExecutionContextUser = {
  /**
   * User ID
   */
  uid: string;
  /**
   * User name
   */
  name?: string;
  /**
   * User email
   */
  email?: string;
};

export type ToolExecutionContext = {
  user: ToolExecutionContextUser;
  /**
   * Parent result ID (for workflow chaining)
   */
  parentResultId?: string;
  /**
   * Action step PK (for workflow tracking)
   */
  actionStepPk?: number;
  /**
   * Canvas node ID
   */
  canvasNodeId?: string;
  /**
   * Additional metadata
   */
  metadata?: {
    [key: string]: unknown;
  };
};

export type ToolExecutionResult = {
  /**
   * Success status
   */
  success: boolean;
  /**
   * Result data
   */
  data?: unknown;
  error?: {
    /**
     * Error code
     */
    code?: string;
    /**
     * Error message
     */
    message?: string;
    /**
     * Error details
     */
    details?: {
      [key: string]: unknown;
    };
  };
  metrics?: {
    /**
     * Execution duration in milliseconds
     */
    duration?: number;
    /**
     * Credits cost
     */
    creditsCost?: number;
  };
};

export type DynamicToolDefinition = {
  /**
   * Tool name (unique identifier)
   */
  name: string;
  /**
   * Tool description for LLM
   */
  description: string;
  /**
   * Zod schema for parameters (runtime only, not serializable)
   */
  schema?: unknown;
  metadata: ToolMetadata;
};

export type InstantiatedTool = {
  /**
   * LangChain DynamicStructuredTool instance (runtime only, not serializable)
   */
  tool?: unknown;
  metadata: ToolMetadata;
  /**
   * Configuration version
   */
  configVersion?: number;
};

export type ToolCacheEntry = {
  /**
   * Configuration MD5 hash
   */
  configHash: string;
  /**
   * Cache timestamp
   */
  timestamp: string;
  /**
   * Cache expiration time
   */
  expiresAt: string;
};

export type ToolRegistryEntry = {
  /**
   * Toolset key
   */
  toolsetKey: string;
  /**
   * Tool definitions
   */
  definitions: Array<DynamicToolDefinition>;
  /**
   * Configuration version
   */
  configVersion: number;
  /**
   * Last update timestamp
   */
  updatedAt: string;
};

/**
 * Voucher status
 */
export type VoucherStatus = 'unused' | 'used' | 'expired' | 'invalid';

/**
 * Voucher status
 */
export const VoucherStatus = {
  UNUSED: 'unused',
  USED: 'used',
  EXPIRED: 'expired',
  INVALID: 'invalid',
} as const;

/**
 * Voucher source
 */
export type VoucherSource = 'template_publish' | 'invitation_claim' | 'run_workflow';

/**
 * Voucher source
 */
export const VoucherSource = {
  TEMPLATE_PUBLISH: 'template_publish',
  INVITATION_CLAIM: 'invitation_claim',
  RUN_WORKFLOW: 'run_workflow',
} as const;

/**
 * Invitation status
 */
export type InvitationStatus = 'unclaimed' | 'claimed' | 'expired';

/**
 * Invitation status
 */
export const InvitationStatus = {
  UNCLAIMED: 'unclaimed',
  CLAIMED: 'claimed',
  EXPIRED: 'expired',
} as const;

export type Voucher = {
  /**
   * Unique voucher ID
   */
  voucherId: string;
  /**
   * User ID who owns the voucher
   */
  uid: string;
  /**
   * Discount percentage (10-90)
   */
  discountPercent: number;
  status: VoucherStatus;
  source: VoucherSource;
  /**
   * Source entity ID (template ID or invitation ID)
   */
  sourceId?: string;
  /**
   * LLM scoring result (0-100)
   */
  llmScore?: number;
  /**
   * Voucher expiration time
   */
  expiresAt: string;
  /**
   * Voucher usage time
   */
  usedAt?: string;
  /**
   * Subscription ID if voucher was used
   */
  subscriptionId?: string;
  /**
   * Creation timestamp
   */
  createdAt: string;
  /**
   * Update timestamp
   */
  updatedAt: string;
};

export type VoucherInvitation = {
  /**
   * Unique invitation ID
   */
  invitationId: string;
  /**
   * Inviter user ID
   */
  inviterUid: string;
  /**
   * Invitee user ID
   */
  inviteeUid?: string;
  /**
   * Short invitation code for sharing
   */
  inviteCode: string;
  /**
   * Source voucher ID
   */
  voucherId: string;
  /**
   * Discount percentage
   */
  discountPercent: number;
  status: InvitationStatus;
  /**
   * Claim timestamp
   */
  claimedAt?: string;
  /**
   * Whether inviter reward has been granted
   */
  rewardGranted: boolean;
  /**
   * Creation timestamp
   */
  createdAt: string;
  /**
   * Update timestamp
   */
  updatedAt: string;
};

export type VoucherTriggerResult = {
  voucher: Voucher;
  /**
   * LLM score (0-100)
   */
  score: number;
  /**
   * LLM feedback for improvement
   */
  feedback?: string;
  /**
   * Whether daily trigger limit was reached
   */
  triggerLimitReached?: boolean;
};

export type VoucherAvailableResult = {
  /**
   * Whether user has available vouchers
   */
  hasAvailableVoucher: boolean;
  /**
   * List of available vouchers
   */
  vouchers: Array<Voucher>;
  /**
   * Best available voucher (highest discount)
   */
  bestVoucher?: Voucher;
};

export type VoucherValidateResult = {
  /**
   * Whether voucher is valid
   */
  valid: boolean;
  /**
   * Voucher details
   */
  voucher?: Voucher;
  /**
   * Reason if not valid
   */
  reason?: string;
};

export type CreateInvitationResult = {
  /**
   * Created invitation
   */
  invitation: VoucherInvitation;
};

export type ClaimInvitationResult = {
  /**
   * Whether claim was successful
   */
  success: boolean;
  /**
   * Created voucher for invitee
   */
  voucher?: Voucher;
  /**
   * Name of the user who sent the invitation
   */
  inviterName?: string;
  /**
   * Error message if failed
   */
  message?: string;
};

export type ValidateVoucherRequest = {
  /**
   * Voucher ID to validate
   */
  voucherId: string;
};

export type CreateVoucherInvitationRequest = {
  /**
   * Voucher ID to create invitation for
   */
  voucherId: string;
};

export type ClaimVoucherInvitationRequest = {
  /**
   * Invitation code to claim
   */
  inviteCode: string;
};

export type GetAvailableVouchersResponse = BaseResponse & {
  data?: VoucherAvailableResult;
};

export type ListUserVouchersResponse = BaseResponse & {
  data?: Array<Voucher>;
};

export type ValidateVoucherResponse = BaseResponse & {
  data?: VoucherValidateResult;
};

export type CreateVoucherInvitationResponse = BaseResponse & {
  data?: CreateInvitationResult;
};

export type VerifyInvitationResult = {
  /**
   * Whether the invitation is valid and can be claimed
   */
  valid: boolean;
  invitation?: VoucherInvitation;
  /**
   * The original voucher being shared (for unclaimed invitations)
   */
  voucher?: Voucher;
  /**
   * If already claimed, the UID of the user who claimed it
   */
  claimedByUid?: string;
  /**
   * Inviter's name (for display)
   */
  inviterName?: string;
  /**
   * Error or status message
   */
  message?: string;
};

export type VerifyVoucherInvitationResponse = BaseResponse & {
  data?: VerifyInvitationResult;
};

export type ClaimVoucherInvitationResponse = BaseResponse & {
  data?: ClaimInvitationResult;
};

export type TriggerVoucherRequest = {
  /**
   * Canvas ID of the template being published
   */
  canvasId: string;
  /**
   * Optional template ID (defaults to canvasId if not provided)
   */
  templateId?: string;
  /**
   * Type of trigger event
   */
  triggerType: 'template_publish';
};

/**
 * Type of trigger event
 */
export type triggerType = 'template_publish';

/**
 * Type of trigger event
 */
export const triggerType = {
  TEMPLATE_PUBLISH: 'template_publish',
} as const;

export type TriggerVoucherResponse = BaseResponse & {
  data?: VoucherTriggerResult;
};

/**
 * Request body for webhook trigger.
 *
 * **IMPORTANT**: If you need to pass workflow variables, they MUST be wrapped under the "variables" field.
 * Do NOT pass variables directly at the top level.
 *
 * Valid examples:
 * - Empty body (for workflows without variables): {}
 * - With variables: { "variables": { "input": "value", "count": 10 } }
 *
 * Invalid example:
 * - { "input": "value" }  (variables not wrapped)
 *
 */
export type WebhookRunRequest = {
  /**
   * Workflow variables as key-value pairs. Each key is a variable name defined in the workflow.
   */
  variables?: {
    [key: string]: unknown;
  };
};

export type WebhookRunResponse = BaseResponse & {
  data?: {
    /**
     * Whether the webhook request was accepted
     */
    received?: boolean;
  };
};

export type OpenapiUploadedFile = {
  /**
   * File key used as workflow variable value
   */
  fileKey: string;
  /**
   * Original file name
   */
  fileName: string;
};

export type OpenapiFileUploadResponse = BaseResponse & {
  data?: {
    /**
     * Uploaded files
     */
    files: Array<OpenapiUploadedFile>;
  };
};

/**
 * Webhook error codes:
 * - WEBHOOK_NOT_FOUND: Webhook does not exist or has been deleted
 * - WEBHOOK_DISABLED: Webhook is disabled
 * - WEBHOOK_RATE_LIMITED: Request rate exceeds the limit
 * - INVALID_REQUEST_BODY: Request body format is invalid
 * - CANVAS_NOT_FOUND: Associated canvas cannot be found
 * - INSUFFICIENT_CREDITS: Insufficient credits
 *
 */
export type WebhookErrorCode =
  | 'WEBHOOK_NOT_FOUND'
  | 'WEBHOOK_DISABLED'
  | 'WEBHOOK_RATE_LIMITED'
  | 'INVALID_REQUEST_BODY'
  | 'CANVAS_NOT_FOUND'
  | 'INSUFFICIENT_CREDITS';

/**
 * Webhook error codes:
 * - WEBHOOK_NOT_FOUND: Webhook does not exist or has been deleted
 * - WEBHOOK_DISABLED: Webhook is disabled
 * - WEBHOOK_RATE_LIMITED: Request rate exceeds the limit
 * - INVALID_REQUEST_BODY: Request body format is invalid
 * - CANVAS_NOT_FOUND: Associated canvas cannot be found
 * - INSUFFICIENT_CREDITS: Insufficient credits
 *
 */
export const WebhookErrorCode = {
  WEBHOOK_NOT_FOUND: 'WEBHOOK_NOT_FOUND',
  WEBHOOK_DISABLED: 'WEBHOOK_DISABLED',
  WEBHOOK_RATE_LIMITED: 'WEBHOOK_RATE_LIMITED',
  INVALID_REQUEST_BODY: 'INVALID_REQUEST_BODY',
  CANVAS_NOT_FOUND: 'CANVAS_NOT_FOUND',
  INSUFFICIENT_CREDITS: 'INSUFFICIENT_CREDITS',
} as const;

export type EnableWebhookRequest = {
  /**
   * Canvas ID to enable webhook for
   */
  canvasId: string;
  /**
   * Timeout in seconds
   */
  timeout?: number;
};

export type EnableWebhookResponse = BaseResponse & {
  data?: {
    /**
     * Webhook ID
     */
    webhookId?: string;
    /**
     * Webhook URL
     */
    webhookUrl?: string;
    /**
     * Whether webhook is enabled
     */
    isEnabled?: boolean;
  };
};

export type DisableWebhookRequest = {
  /**
   * Webhook ID to disable
   */
  webhookId: string;
};

export type ResetWebhookRequest = {
  /**
   * Webhook ID to reset
   */
  webhookId: string;
};

export type ResetWebhookResponse = BaseResponse & {
  data?: {
    /**
     * New webhook ID
     */
    webhookId?: string;
    /**
     * New webhook URL
     */
    webhookUrl?: string;
  };
};

export type UpdateOpenapiConfigRequest = {
  /**
   * Canvas ID
   */
  canvasId: string;
  /**
   * Output node IDs
   */
  resultNodeIds?: Array<string> | null;
};

export type OpenapiConfigResponse = BaseResponse & {
  data?: {
    /**
     * Canvas ID
     */
    canvasId?: string;
    /**
     * Output node IDs
     */
    resultNodeIds?: Array<string> | null;
  };
};

export type UpdateWebhookRequest = {
  /**
   * Webhook ID to update
   */
  webhookId: string;
  /**
   * Whether webhook is enabled
   */
  isEnabled?: boolean;
  /**
   * Timeout in seconds
   */
  timeout?: number;
};

export type GetWebhookConfigResponse = BaseResponse & {
  data?: {
    /**
     * Webhook ID
     */
    webhookId?: string;
    /**
     * Whether webhook is enabled
     */
    isEnabled?: boolean;
    /**
     * Timeout in seconds
     */
    timeout?: number;
  };
};

export type GetWebhookHistoryResponse = BaseResponse & {
  data?: {
    records?: Array<WebhookCallRecord>;
    /**
     * Total number of records
     */
    total?: number;
    /**
     * Current page number
     */
    page?: number;
    /**
     * Page size
     */
    pageSize?: number;
  };
};

export type WebhookCallRecord = {
  /**
   * Record ID
   */
  recordId?: string;
  /**
   * Webhook ID
   */
  apiId?: string;
  /**
   * Canvas ID
   */
  canvasId?: string;
  /**
   * Workflow execution ID
   */
  workflowExecutionId?: string;
  /**
   * Request URL
   */
  requestUrl?: string;
  /**
   * Request method
   */
  requestMethod?: string;
  /**
   * HTTP status code
   */
  httpStatus?: number;
  /**
   * Response time in milliseconds
   */
  responseTime?: number;
  /**
   * Execution status
   */
  status?: string;
  /**
   * Failure reason if failed
   */
  failureReason?: string;
  /**
   * Created timestamp
   */
  createdAt?: string;
  /**
   * Completed timestamp
   */
  completedAt?: string;
};

export type DriveFileViaApi = {
  /**
   * Drive file name
   */
  name: string;
  /**
   * Drive file type
   */
  type: string;
  /**
   * Drive file size
   */
  size?: number;
  /**
   * Node ID that produced the file
   */
  nodeId?: string;
  /**
   * Access URL for the file
   */
  url?: string;
};

export type RunWorkflowApiResponse = BaseResponse & {
  data?: {
    /**
     * Workflow execution ID for tracking status
     */
    executionId?: string;
    /**
     * Initial execution status (usually "executing")
     */
    status?: WorkflowExecutionStatus;
  };
};

/**
 * Request body for running a workflow via API.
 *
 * **IMPORTANT**: If you need to pass workflow variables, they MUST be wrapped under the "variables" field.
 * Do NOT pass variables directly at the top level.
 *
 * Each key in variables is a workflow variable name. Values can be:
 * - Strings, numbers, booleans, objects, or arrays
 * - For file variables: pass fileKey (string) or array of fileKey returned by /openapi/files/upload
 *
 * Valid examples:
 * - Empty body (for workflows without variables): {}
 * - With variables: { "variables": { "input": "Hello", "files": ["of_xxx", "of_yyy"] } }
 *
 * Invalid example:
 * - { "input": "Hello" }  (variables not wrapped)
 *
 */
export type OpenapiWorkflowRunRequest = {
  /**
   * Workflow variables as key-value pairs. Each key is a variable name defined in the workflow.
   */
  variables?: {
    [key: string]: unknown;
  };
};

/**
 * Copilot workflow generation request.
 */
export type OpenapiCopilotGenerateRequest = {
  /**
   * Natural language prompt describing the desired workflow (supports multiple languages).
   */
  query: string;
  /**
   * Optional canvas ID to overwrite. This will replace the existing workflow and cannot be undone.
   */
  canvasId?: string;
  /**
   * Output locale. Supported: en, zh-CN, ja, zh-Hant, fr, de-DE, ko, hi, es, ru, de, it, tr, pt, vi, id, th, ar, mn, fa.
   */
  locale?: string;
};

export type OpenapiCopilotGenerateResponse = BaseResponse & {
  data?: {
    /**
     * Canvas/Workflow ID
     */
    canvasId?: string;
    workflowPlan?: OpenapiWorkflowPlan;
  };
};

/**
 * Error response when workflow generation fails.
 */
export type OpenapiCopilotGenerateErrorResponse = {
  /**
   * HTTP status code
   */
  statusCode: number;
  /**
   * Readable error message
   */
  message: string;
  /**
   * Error type
   */
  error: string;
  /**
   * Original AI response (may be empty, length-limited)
   */
  modelResponse?: string;
};

export type OpenapiWorkflowSummary = {
  /**
   * Canvas/Workflow ID
   */
  canvasId: string;
  /**
   * Workflow title
   */
  title: string;
};

export type OpenapiWorkflowSearchResponse = BaseResponse & {
  /**
   * Workflow search results
   */
  data?: Array<OpenapiWorkflowSummary>;
};

export type OpenapiWorkflowDetailResponse = BaseResponse & {
  data?: OpenapiWorkflowPlan;
};

export type OpenapiWorkflowPlan = {
  /**
   * Title of the workflow plan
   */
  title: string;
  /**
   * Array of workflow tasks to be executed
   */
  tasks: Array<WorkflowTask>;
  /**
   * Array of variables (aka User inputs) defined for the workflow plan
   */
  variables?: Array<OpenapiWorkflowVariable>;
};

/**
 * Workflow variable definition (public fields)
 */
export type OpenapiWorkflowVariable = {
  /**
   * Variable name used in the workflow
   */
  name: string;
  /**
   * Variable type
   */
  variableType?: 'string' | 'option' | 'resource';
  /**
   * Whether the variable is required. Defaults to false.
   */
  required?: boolean;
  /**
   * Array of options (only valid when variable type is `option`)
   */
  options?: Array<string>;
};

export type GetWorkflowStatusViaApiResponse = BaseResponse & {
  data?: {
    /**
     * Workflow execution ID
     */
    executionId?: string;
    /**
     * Workflow execution status
     */
    status?: WorkflowExecutionStatus;
    /**
     * Node execution status list
     */
    nodeExecutions?: Array<WorkflowNodeExecutionStatusViaApi>;
    /**
     * Workflow execution created time
     */
    createdAt?: string;
  };
};

export type GetWorkflowOutputResponse = BaseResponse & {
  data?: {
    /**
     * Output node results
     */
    output?: Array<
      WorkflowNodeExecutionViaApi & {
        /**
         * Output messages
         */
        messages?: Array<ActionMessageViaApi>;
      }
    >;
    /**
     * Output files
     */
    files?: Array<DriveFileViaApi>;
  };
};

export type ExtractVariablesData = {
  body: ExtractVariablesRequest;
};

export type ExtractVariablesResponse = VariableExtractionResult;

export type ExtractVariablesError = unknown;

export type GenerateAppTemplateData = {
  body: GenerateAppTemplateRequest;
};

export type GenerateAppTemplateResponse = AppTemplateResult;

export type GenerateAppTemplateError = unknown;

export type ListMcpServersData = {
  query?: {
    /**
     * Filter by enabled status
     */
    enabled?: boolean;
    /**
     * Filter by isGlobal status. If not passed, return both global and user-specific MCP servers.
     */
    isGlobal?: boolean;
    /**
     * MCP server type
     */
    type?: 'sse' | 'streamable' | 'stdio';
  };
};

export type ListMcpServersResponse2 = ListMcpServersResponse;

export type ListMcpServersError = unknown;

export type CreateMcpServerData = {
  body: UpsertMcpServerRequest;
};

export type CreateMcpServerResponse = UpsertMcpServerResponse;

export type CreateMcpServerError = unknown;

export type UpdateMcpServerData = {
  body: UpsertMcpServerRequest;
};

export type UpdateMcpServerResponse = UpsertMcpServerResponse;

export type UpdateMcpServerError = unknown;

export type DeleteMcpServerData = {
  body: DeleteMcpServerRequest;
};

export type DeleteMcpServerResponse2 = DeleteMcpServerResponse;

export type DeleteMcpServerError = unknown;

export type ValidateMcpServerData = {
  body: UpsertMcpServerRequest;
};

export type ValidateMcpServerResponse2 = ValidateMcpServerResponse;

export type ValidateMcpServerError = unknown;

export type GetAuthConfigResponse = AuthConfigResponse;

export type GetAuthConfigError = unknown;

export type RefreshTokenResponse = unknown;

export type RefreshTokenError = unknown;

export type EmailSignupData2 = {
  body: EmailSignupRequest;
};

export type EmailSignupResponse2 = EmailSignupResponse;

export type EmailSignupError = unknown;

export type EmailLoginData2 = {
  body: EmailLoginRequest;
};

export type EmailLoginResponse2 = EmailLoginResponse;

export type EmailLoginError = unknown;

export type CreateVerificationData2 = {
  body: CreateVerificationRequest;
};

export type CreateVerificationResponse2 = CreateVerificationResponse;

export type CreateVerificationError = unknown;

export type ResendVerificationData = {
  body: ResendVerificationRequest;
};

export type ResendVerificationResponse = BaseResponse;

export type ResendVerificationError = unknown;

export type CheckVerificationData = {
  body: CheckVerificationRequest;
};

export type CheckVerificationResponse = BaseResponse;

export type CheckVerificationError = unknown;

export type ListAccountsData = {
  query?: {
    /**
     * Auth provider
     */
    provider?: string;
    /**
     * Auth type
     */
    type?: AuthType;
  };
};

export type ListAccountsResponse2 = ListAccountsResponse;

export type ListAccountsError = unknown;

export type LogoutResponse = unknown;

export type LogoutError = unknown;

export type CheckToolOauthStatusData = {
  query: {
    /**
     * OAuth provider (e.g., google, github)
     */
    provider: string;
    /**
     * Comma-separated list of required OAuth scopes
     */
    scope: string;
  };
};

export type CheckToolOauthStatusResponse = CheckToolOAuthStatusResponse;

export type CheckToolOauthStatusError = unknown;

export type CreateCliApiKeyData2 = {
  body: CreateCliApiKeyRequest;
};

export type CreateCliApiKeyResponse2 = CreateCliApiKeyResponse;

export type CreateCliApiKeyError = unknown;

export type ListCliApiKeysResponse2 = ListCliApiKeysResponse;

export type ListCliApiKeysError = unknown;

export type RevokeCliApiKeyData = {
  path: {
    keyId: string;
  };
};

export type RevokeCliApiKeyResponse = BaseResponse;

export type RevokeCliApiKeyError = unknown;

export type UpdateCliApiKeyData = {
  body: UpdateCliApiKeyRequest;
  path: {
    keyId: string;
  };
};

export type UpdateCliApiKeyResponse = BaseResponse;

export type UpdateCliApiKeyError = unknown;

export type GetCollabTokenResponse2 = GetCollabTokenResponse;

export type GetCollabTokenError = unknown;

export type ListCanvasesData = {
  query?: {
    /**
     * Search keyword
     */
    keyword?: string;
    /**
     * Order
     */
    order?: ListOrder;
    /**
     * Page number
     */
    page?: number;
    /**
     * Page size
     */
    pageSize?: number;
    /**
     * Related project ID
     */
    projectId?: string;
  };
};

export type ListCanvasesResponse = ListCanvasResponse;

export type ListCanvasesError = unknown;

export type GetCanvasDetailData = {
  query: {
    /**
     * Canvas ID
     */
    canvasId: string;
  };
};

export type GetCanvasDetailResponse2 = GetCanvasDetailResponse;

export type GetCanvasDetailError = unknown;

export type GetCanvasDataData = {
  query: {
    /**
     * Canvas ID
     */
    canvasId: string;
  };
};

export type GetCanvasDataResponse2 = GetCanvasDataResponse;

export type GetCanvasDataError = unknown;

export type ExportCanvasData = {
  query: {
    /**
     * Canvas ID
     */
    canvasId: string;
  };
};

export type ExportCanvasResponse2 = ExportCanvasResponse;

export type ExportCanvasError = unknown;

export type ImportCanvasData = {
  body: ImportCanvasRequest;
};

export type ImportCanvasResponse = UpsertCanvasResponse;

export type ImportCanvasError = unknown;

export type CreateCanvasData = {
  body: UpsertCanvasRequest;
};

export type CreateCanvasResponse = UpsertCanvasResponse;

export type CreateCanvasError = unknown;

export type DuplicateCanvasData = {
  body: DuplicateCanvasRequest;
};

export type DuplicateCanvasResponse = UpsertCanvasResponse;

export type DuplicateCanvasError = unknown;

export type UpdateCanvasData = {
  body: UpsertCanvasRequest;
};

export type UpdateCanvasResponse = UpsertCanvasResponse;

export type UpdateCanvasError = unknown;

export type DeleteCanvasData = {
  body: DeleteCanvasRequest;
};

export type DeleteCanvasResponse = BaseResponse;

export type DeleteCanvasError = unknown;

export type AutoNameCanvasData = {
  body: AutoNameCanvasRequest;
};

export type AutoNameCanvasResponse2 = AutoNameCanvasResponse;

export type AutoNameCanvasError = unknown;

export type GetCanvasStateData = {
  query: {
    /**
     * Canvas ID
     */
    canvasId: string;
    /**
     * Canvas state version
     */
    version?: string;
  };
};

export type GetCanvasStateResponse2 = GetCanvasStateResponse;

export type GetCanvasStateError = unknown;

export type SetCanvasStateData = {
  body: SetCanvasStateRequest;
};

export type SetCanvasStateResponse = BaseResponse;

export type SetCanvasStateError = unknown;

export type GetCanvasTransactionsData = {
  query: {
    /**
     * Canvas ID
     */
    canvasId: string;
    /**
     * Since timestamp
     */
    since?: number;
    /**
     * Canvas state version
     */
    version?: string;
  };
};

export type GetCanvasTransactionsResponse2 = GetCanvasTransactionsResponse;

export type GetCanvasTransactionsError = unknown;

export type SyncCanvasStateData = {
  body: SyncCanvasStateRequest;
};

export type SyncCanvasStateResponse2 = SyncCanvasStateResponse;

export type SyncCanvasStateError = unknown;

export type CreateCanvasVersionData = {
  body: CreateCanvasVersionRequest;
};

export type CreateCanvasVersionResponse2 = CreateCanvasVersionResponse;

export type CreateCanvasVersionError = unknown;

export type GetWorkflowVariablesData = {
  query: {
    /**
     * Canvas ID
     */
    canvasId: string;
  };
};

export type GetWorkflowVariablesResponse2 = GetWorkflowVariablesResponse;

export type GetWorkflowVariablesError = unknown;

export type UpdateWorkflowVariablesData = {
  body: UpdateWorkflowVariablesRequest;
};

export type UpdateWorkflowVariablesResponse2 = UpdateWorkflowVariablesResponse;

export type UpdateWorkflowVariablesError = unknown;

export type ListDriveFilesData = {
  query: {
    /**
     * Canvas ID
     */
    canvasId: string;
    /**
     * Order
     */
    order?: ListOrder;
    /**
     * Page number
     */
    page?: number;
    /**
     * Page size
     */
    pageSize?: number;
    /**
     * Drive file scope
     */
    scope?: DriveFileScope;
    /**
     * Drive file source
     */
    source?: DriveFileSource;
  };
};

export type ListDriveFilesResponse2 = ListDriveFilesResponse;

export type ListDriveFilesError = unknown;

export type CreateDriveFileData = {
  body: UpsertDriveFileRequest;
};

export type CreateDriveFileResponse = UpsertDriveFileResponse;

export type CreateDriveFileError = unknown;

export type BatchCreateDriveFilesData = {
  body: BatchCreateDriveFilesRequest;
};

export type BatchCreateDriveFilesResponse2 = BatchCreateDriveFilesResponse;

export type BatchCreateDriveFilesError = unknown;

export type UpdateDriveFileData = {
  body: UpsertDriveFileRequest;
};

export type UpdateDriveFileResponse = UpsertDriveFileResponse;

export type UpdateDriveFileError = unknown;

export type DeleteDriveFileData = {
  body: DeleteDriveFileRequest;
};

export type DeleteDriveFileResponse = BaseResponse;

export type DeleteDriveFileError = unknown;

export type ListCanvasTemplatesData = {
  query?: {
    /**
     * Canvas template category ID
     */
    categoryId?: string;
    /**
     * Language code
     */
    language?: string;
    /**
     * Page number
     */
    page?: number;
    /**
     * Page size
     */
    pageSize?: number;
    /**
     * Scope
     */
    scope?: 'public' | 'private';
  };
};

export type ListCanvasTemplatesResponse = ListCanvasTemplateResponse;

export type ListCanvasTemplatesError = unknown;

export type CreateCanvasTemplateData = {
  body: CreateCanvasTemplateRequest;
};

export type CreateCanvasTemplateResponse = UpsertCanvasTemplateResponse;

export type CreateCanvasTemplateError = unknown;

export type UpdateCanvasTemplateData = {
  body: UpdateCanvasTemplateRequest;
};

export type UpdateCanvasTemplateResponse = UpsertCanvasTemplateResponse;

export type UpdateCanvasTemplateError = unknown;

export type ListCanvasTemplateCategoriesResponse = ListCanvasTemplateCategoryResponse;

export type ListCanvasTemplateCategoriesError = unknown;

export type ListResourcesData = {
  query?: {
    /**
     * Related canvas ID
     */
    canvasId?: string;
    /**
     * Order
     */
    order?: ListOrder;
    /**
     * Page number
     */
    page?: number;
    /**
     * Page size
     */
    pageSize?: number;
    /**
     * Related project ID
     */
    projectId?: string;
    /**
     * Resource ID
     */
    resourceId?: string;
    /**
     * Resource type
     */
    resourceType?: ResourceType;
  };
};

export type ListResourcesResponse = ListResourceResponse;

export type ListResourcesError = unknown;

export type GetResourceDetailData = {
  query: {
    /**
     * Whether to generate public URL for the resource
     */
    genPublicUrl?: boolean;
    /**
     * Resource ID to retrieve
     */
    resourceId: string;
  };
};

export type GetResourceDetailResponse2 = GetResourceDetailResponse;

export type GetResourceDetailError = unknown;

export type UpdateResourceData = {
  /**
   * Resource update request
   */
  body: UpsertResourceRequest;
};

export type UpdateResourceResponse = UpsertResourceResponse;

export type UpdateResourceError = unknown;

export type CreateResourceData = {
  /**
   * Resource creation request
   */
  body: UpsertResourceRequest;
};

export type CreateResourceResponse = UpsertResourceResponse;

export type CreateResourceError = unknown;

export type CreateResourceWithFileData = {
  body: {
    /**
     * File to upload
     */
    file: Blob | File;
    /**
     * Resource title
     */
    title: string;
    /**
     * Resource type
     */
    resourceType: ResourceType;
    /**
     * Resource ID (only used for update)
     */
    resourceId?: string;
    /**
     * Resource metadata
     */
    data?: ResourceMeta;
  };
};

export type CreateResourceWithFileResponse = UpsertResourceResponse;

export type CreateResourceWithFileError = unknown;

export type BatchCreateResourceData = {
  /**
   * Resource creation request
   */
  body: Array<UpsertResourceRequest>;
};

export type BatchCreateResourceResponse2 = BatchCreateResourceResponse;

export type BatchCreateResourceError = unknown;

export type ReindexResourceData = {
  body: ReindexResourceRequest;
};

export type ReindexResourceResponse2 = ReindexResourceResponse;

export type ReindexResourceError = unknown;

export type DeleteResourceData = {
  body: DeleteResourceRequest;
};

export type DeleteResourceResponse = BaseResponse;

export type DeleteResourceError = unknown;

export type ListDocumentsData = {
  query?: {
    /**
     * Related canvas ID
     */
    canvasId?: string;
    /**
     * Order by
     */
    order?: ListOrder;
    /**
     * Page number
     */
    page?: number;
    /**
     * Page size
     */
    pageSize?: number;
    /**
     * Related project ID
     */
    projectId?: string;
  };
};

export type ListDocumentsResponse = ListDocumentResponse;

export type ListDocumentsError = unknown;

export type GetDocumentDetailData = {
  query: {
    /**
     * Document ID to retrieve
     */
    docId: string;
  };
};

export type GetDocumentDetailResponse2 = GetDocumentDetailResponse;

export type GetDocumentDetailError = unknown;

export type ExportDocumentData = {
  query: {
    /**
     * Export file ID to retrieve
     */
    fileId: string;
    /**
     * Export format
     */
    format?: 'markdown' | 'docx' | 'pdf';
  };
};

export type ExportDocumentResponse = Blob | File;

export type ExportDocumentError = unknown;

export type StartExportJobData = {
  /**
   * Export job request
   */
  body: StartExportJobRequest;
};

export type StartExportJobResponse2 = StartExportJobResponse;

export type StartExportJobError = unknown;

export type GetExportJobStatusData = {
  path: {
    /**
     * Export job ID
     */
    jobId: string;
  };
};

export type GetExportJobStatusResponse2 = GetExportJobStatusResponse;

export type GetExportJobStatusError = unknown;

export type DownloadExportJobResultData = {
  path: {
    /**
     * Export job ID
     */
    jobId: string;
  };
};

export type DownloadExportJobResultResponse = Blob | File;

export type DownloadExportJobResultError = unknown;

export type UpdateDocumentData = {
  /**
   * Document update request
   */
  body: UpsertDocumentRequest;
};

export type UpdateDocumentResponse = UpsertDocumentResponse;

export type UpdateDocumentError = unknown;

export type CreateDocumentData = {
  /**
   * Document creation request
   */
  body: UpsertDocumentRequest;
};

export type CreateDocumentResponse = UpsertDocumentResponse;

export type CreateDocumentError = unknown;

export type DeleteDocumentData = {
  body: DeleteDocumentRequest;
};

export type DeleteDocumentResponse = BaseResponse;

export type DeleteDocumentError = unknown;

export type BatchUpdateDocumentData = {
  body: Array<UpsertDocumentRequest>;
};

export type BatchUpdateDocumentResponse = BaseResponse;

export type BatchUpdateDocumentError = unknown;

export type ListCodeArtifactsData = {
  query?: {
    /**
     * Related canvas ID
     */
    canvasId?: string;
    /**
     * Whether to include content
     */
    needContent?: boolean;
    /**
     * Page number
     */
    page?: number;
    /**
     * Page size
     */
    pageSize?: number;
    /**
     * Action result ID
     */
    resultId?: string;
    /**
     * Action result version
     */
    resultVersion?: number;
  };
};

export type ListCodeArtifactsResponse = ListCodeArtifactResponse;

export type ListCodeArtifactsError = unknown;

export type GetCodeArtifactDetailData = {
  query: {
    /**
     * Artifact ID
     */
    artifactId: string;
  };
};

export type GetCodeArtifactDetailResponse2 = GetCodeArtifactDetailResponse;

export type GetCodeArtifactDetailError = unknown;

export type CreateCodeArtifactData = {
  body: UpsertCodeArtifactRequest;
};

export type CreateCodeArtifactResponse = UpsertCodeArtifactResponse;

export type CreateCodeArtifactError = unknown;

export type UpdateCodeArtifactData = {
  body: UpsertCodeArtifactRequest;
};

export type UpdateCodeArtifactResponse = UpsertCodeArtifactResponse;

export type UpdateCodeArtifactError = unknown;

export type CreateShareData = {
  body: CreateShareRequest;
};

export type CreateShareResponse2 = CreateShareResponse;

export type CreateShareError = unknown;

export type ListSharesData = {
  query?: {
    /**
     * Entity ID
     */
    entityId?: string;
    /**
     * Entity type
     */
    entityType?: EntityType;
    /**
     * Share ID
     */
    shareId?: string;
  };
};

export type ListSharesResponse = ListShareResponse;

export type ListSharesError = unknown;

export type DeleteShareData = {
  body: DeleteShareRequest;
};

export type DeleteShareResponse = BaseResponse;

export type DeleteShareError = unknown;

export type DuplicateShareData = {
  body: DuplicateShareRequest;
};

export type DuplicateShareResponse2 = DuplicateShareResponse;

export type DuplicateShareError = unknown;

export type GetActionResultData = {
  query: {
    /**
     * Action result ID
     */
    resultId: string;
    /**
     * Action result version
     */
    version?: number;
  };
};

export type GetActionResultResponse2 = GetActionResultResponse;

export type GetActionResultError = unknown;

export type AbortActionData = {
  /**
   * Abort action request
   */
  body: AbortActionRequest;
};

export type AbortActionResponse = BaseResponse;

export type AbortActionError = unknown;

export type InvokeSkillData = {
  /**
   * Skill invocation request
   */
  body: InvokeSkillRequest;
};

export type InvokeSkillResponse2 = InvokeSkillResponse;

export type InvokeSkillError = unknown;

export type StreamInvokeSkillData = {
  /**
   * Skill invocation request
   */
  body: InvokeSkillRequest;
};

export type StreamInvokeSkillResponse = string;

export type StreamInvokeSkillError = unknown;

export type GenerateMediaData = {
  body: MediaGenerateRequest;
};

export type GenerateMediaResponse = MediaGenerateResponse;

export type GenerateMediaError = unknown;

export type ListCopilotSessionsData = {
  query?: {
    /**
     * Canvas ID
     */
    canvasId?: string;
  };
};

export type ListCopilotSessionsResponse2 = ListCopilotSessionsResponse;

export type ListCopilotSessionsError = unknown;

export type GetCopilotSessionDetailData = {
  query: {
    /**
     * Copilot session ID
     */
    sessionId: string;
  };
};

export type GetCopilotSessionDetailResponse2 = GetCopilotSessionDetailResponse;

export type GetCopilotSessionDetailError = unknown;

export type InitializeWorkflowData = {
  body: InitializeWorkflowRequest;
};

export type InitializeWorkflowResponse2 = InitializeWorkflowResponse;

export type InitializeWorkflowError = unknown;

export type AbortWorkflowData = {
  body: AbortWorkflowRequest;
};

export type AbortWorkflowResponse = BaseResponse;

export type AbortWorkflowError = unknown;

export type ListWorkflowExecutionsData = {
  query?: {
    /**
     * Creation time after filter (unix timestamp in milliseconds)
     */
    after?: number;
    /**
     * Canvas ID
     */
    canvasId?: string;
    /**
     * List order
     */
    order?: ListOrder;
    /**
     * Page number
     */
    page?: number;
    /**
     * Page size
     */
    pageSize?: number;
    /**
     * Execution status
     */
    status?: WorkflowExecutionStatus;
  };
};

export type ListWorkflowExecutionsResponse2 = ListWorkflowExecutionsResponse;

export type ListWorkflowExecutionsError = unknown;

export type GetWorkflowDetailData = {
  query: {
    /**
     * Workflow execution ID
     */
    executionId: string;
  };
};

export type GetWorkflowDetailResponse2 = GetWorkflowDetailResponse;

export type GetWorkflowDetailError = unknown;

export type GetWorkflowPlanDetailData = {
  query: {
    /**
     * Workflow plan ID
     */
    planId: string;
    /**
     * Workflow plan version
     */
    version?: number;
  };
};

export type GetWorkflowPlanDetailResponse2 = GetWorkflowPlanDetailResponse;

export type GetWorkflowPlanDetailError = unknown;

export type CreateWorkflowAppData = {
  body: CreateWorkflowAppRequest;
};

export type CreateWorkflowAppResponse2 = CreateWorkflowAppResponse;

export type CreateWorkflowAppError = unknown;

export type DeleteWorkflowAppData = {
  body: DeleteWorkflowAppRequest;
};

export type DeleteWorkflowAppResponse = BaseResponse;

export type DeleteWorkflowAppError = unknown;

export type GetWorkflowAppDetailData = {
  query: {
    /**
     * Workflow app ID
     */
    appId: string;
  };
};

export type GetWorkflowAppDetailResponse2 = GetWorkflowAppDetailResponse;

export type GetWorkflowAppDetailError = unknown;

export type ExecuteWorkflowAppData = {
  body: ExecuteWorkflowAppRequest;
};

export type ExecuteWorkflowAppResponse2 = ExecuteWorkflowAppResponse;

export type ExecuteWorkflowAppError = unknown;

export type ListWorkflowAppsData = {
  query?: {
    /**
     * Canvas ID to filter by
     */
    canvasId?: string;
    /**
     * Search keyword
     */
    keyword?: string;
    /**
     * Order
     */
    order?: ListOrder;
    /**
     * Page number
     */
    page?: number;
    /**
     * Page size
     */
    pageSize?: number;
  };
};

export type ListWorkflowAppsResponse2 = ListWorkflowAppsResponse;

export type ListWorkflowAppsError = unknown;

export type GetTemplateGenerationStatusData = {
  query: {
    /**
     * Workflow app ID
     */
    appId: string;
  };
};

export type GetTemplateGenerationStatusResponse2 = GetTemplateGenerationStatusResponse;

export type GetTemplateGenerationStatusError = unknown;

export type CreateScheduleData = {
  body: CreateScheduleRequest;
};

export type CreateScheduleResponse2 = CreateScheduleResponse;

export type CreateScheduleError = unknown;

export type UpdateScheduleData = {
  body: UpdateScheduleRequest;
};

export type UpdateScheduleResponse2 = UpdateScheduleResponse;

export type UpdateScheduleError = unknown;

export type DeleteScheduleData = {
  body: DeleteScheduleRequest;
};

export type DeleteScheduleResponse2 = DeleteScheduleResponse;

export type DeleteScheduleError = unknown;

export type ListSchedulesData = {
  body: ListSchedulesRequest;
};

export type ListSchedulesResponse2 = ListSchedulesResponse;

export type ListSchedulesError = unknown;

export type GetScheduleDetailData = {
  body: GetScheduleDetailRequest;
};

export type GetScheduleDetailResponse2 = GetScheduleDetailResponse;

export type GetScheduleDetailError = unknown;

export type GetScheduleRecordsData = {
  body: GetScheduleRecordsRequest;
};

export type GetScheduleRecordsResponse2 = GetScheduleRecordsResponse;

export type GetScheduleRecordsError = unknown;

export type ListAllScheduleRecordsData = {
  body: ListAllScheduleRecordsRequest;
};

export type ListAllScheduleRecordsResponse2 = ListAllScheduleRecordsResponse;

export type ListAllScheduleRecordsError = unknown;

export type GetAvailableToolsResponse2 = GetAvailableToolsResponse;

export type GetAvailableToolsError = unknown;

export type GetScheduleRecordDetailData = {
  body: GetScheduleRecordDetailRequest;
};

export type GetScheduleRecordDetailResponse2 = GetScheduleRecordDetailResponse;

export type GetScheduleRecordDetailError = unknown;

export type GetRecordSnapshotData = {
  body: GetRecordSnapshotRequest;
};

export type GetRecordSnapshotResponse2 = GetRecordSnapshotResponse;

export type GetRecordSnapshotError = unknown;

export type TriggerScheduleManuallyData = {
  body: TriggerScheduleManuallyRequest;
};

export type TriggerScheduleManuallyResponse2 = TriggerScheduleManuallyResponse;

export type TriggerScheduleManuallyError = unknown;

export type RetryScheduleRecordData = {
  body: RetryScheduleRecordRequest;
};

export type RetryScheduleRecordResponse2 = RetryScheduleRecordResponse;

export type RetryScheduleRecordError = unknown;

export type EnableWebhookData = {
  body: EnableWebhookRequest;
};

export type EnableWebhookResponse2 = EnableWebhookResponse;

export type EnableWebhookError = unknown;

export type DisableWebhookData = {
  body: DisableWebhookRequest;
};

export type DisableWebhookResponse = BaseResponse;

export type DisableWebhookError = unknown;

export type ResetWebhookData = {
  body: ResetWebhookRequest;
};

export type ResetWebhookResponse2 = ResetWebhookResponse;

export type ResetWebhookError = unknown;

export type UpdateWebhookData = {
  body: UpdateWebhookRequest;
};

export type UpdateWebhookResponse = BaseResponse;

export type UpdateWebhookError = unknown;

export type GetWebhookConfigData = {
  query: {
    /**
     * Canvas ID
     */
    canvasId: string;
  };
};

export type GetWebhookConfigResponse2 = GetWebhookConfigResponse;

export type GetWebhookConfigError = unknown;

export type GetWebhookHistoryData = {
  query: {
    /**
     * Page number
     */
    page?: number;
    /**
     * Page size
     */
    pageSize?: number;
    /**
     * Webhook ID
     */
    webhookId: string;
  };
};

export type GetWebhookHistoryResponse2 = GetWebhookHistoryResponse;

export type GetWebhookHistoryError = unknown;

export type RunWebhookData = {
  body: WebhookRunRequest;
  path: {
    /**
     * Webhook ID
     */
    webhookId: string;
  };
};

export type RunWebhookResponse = WebhookRunResponse;

export type RunWebhookError = unknown;

export type GetOpenapiConfigData = {
  query: {
    /**
     * Canvas ID
     */
    canvasId: string;
  };
};

export type GetOpenapiConfigResponse = OpenapiConfigResponse;

export type GetOpenapiConfigError = unknown;

export type UpdateOpenapiConfigData = {
  body: UpdateOpenapiConfigRequest;
};

export type UpdateOpenapiConfigResponse = OpenapiConfigResponse;

export type UpdateOpenapiConfigError = unknown;

export type UploadOpenapiFilesData = {
  body: {
    /**
     * Files to upload
     */
    files: Array<Blob | File>;
  };
};

export type UploadOpenapiFilesResponse = OpenapiFileUploadResponse;

export type UploadOpenapiFilesError = unknown;

export type SearchWorkflowsViaApiData = {
  query?: {
    /**
     * Keyword to search in workflow titles
     */
    keyword?: string;
    /**
     * Sort order
     */
    order?: ListOrder;
    /**
     * Page number (1-based)
     */
    page?: number;
    /**
     * Number of items per page
     */
    pageSize?: number;
  };
};

export type SearchWorkflowsViaApiResponse = OpenapiWorkflowSearchResponse;

export type SearchWorkflowsViaApiError = unknown;

export type GetWorkflowDetailViaApiData = {
  path: {
    /**
     * Canvas/Workflow ID
     */
    canvasId: string;
  };
};

export type GetWorkflowDetailViaApiResponse = OpenapiWorkflowDetailResponse;

export type GetWorkflowDetailViaApiError = unknown;

export type RunWorkflowViaApiData = {
  body: OpenapiWorkflowRunRequest;
  path: {
    /**
     * Canvas/Workflow ID
     */
    canvasId: string;
  };
};

export type RunWorkflowViaApiResponse = RunWorkflowApiResponse;

export type RunWorkflowViaApiError = unknown;

export type GenerateWorkflowViaCopilotData = {
  body: OpenapiCopilotGenerateRequest;
};

export type GenerateWorkflowViaCopilotResponse = OpenapiCopilotGenerateResponse;

export type GenerateWorkflowViaCopilotError = OpenapiCopilotGenerateErrorResponse | unknown;

export type GetWorkflowStatusViaApiData = {
  path: {
    /**
     * Workflow execution ID
     */
    executionId: string;
  };
};

export type GetWorkflowStatusViaApiResponse2 = GetWorkflowStatusViaApiResponse;

export type GetWorkflowStatusViaApiError = unknown;

export type GetWorkflowOutputData = {
  path: {
    /**
     * Workflow execution ID
     */
    executionId: string;
  };
};

export type GetWorkflowOutputResponse2 = GetWorkflowOutputResponse;

export type GetWorkflowOutputError = unknown;

export type AbortWorkflowViaApiData = {
  path: {
    /**
     * Workflow execution ID
     */
    executionId: string;
  };
};

export type AbortWorkflowViaApiResponse = BaseResponse;

export type AbortWorkflowViaApiError = unknown;

export type GetSettingsResponse = GetUserSettingsResponse;

export type GetSettingsError = unknown;

export type UpdateSettingsData = {
  body: UpdateUserSettingsRequest;
};

export type UpdateSettingsResponse = BaseResponse;

export type UpdateSettingsError = unknown;

export type CheckSettingsFieldData = {
  query: {
    /**
     * Settings field
     */
    field: 'name' | 'email';
    /**
     * Field value
     */
    value: string;
  };
};

export type CheckSettingsFieldResponse2 = CheckSettingsFieldResponse;

export type CheckSettingsFieldError = unknown;

export type GetFormDefinitionResponse2 = GetFormDefinitionResponse;

export type GetFormDefinitionError = unknown;

export type SubmitFormData = {
  body: SubmitFormRequest;
};

export type SubmitFormResponse = BaseResponse;

export type SubmitFormError = unknown;

export type GetCreditRechargeData = {
  query?: {
    /**
     * Page number (1-based)
     */
    page?: number;
    /**
     * Number of items per page
     */
    pageSize?: number;
  };
};

export type GetCreditRechargeResponse2 = GetCreditRechargeResponse;

export type GetCreditRechargeError = unknown;

export type GetCreditUsageData = {
  query?: {
    /**
     * Page number (1-based)
     */
    page?: number;
    /**
     * Number of items per page
     */
    pageSize?: number;
  };
};

export type GetCreditUsageResponse2 = GetCreditUsageResponse;

export type GetCreditUsageError = unknown;

export type GetCreditBalanceResponse = getCreditBalanceResponse;

export type GetCreditBalanceError = unknown;

export type GetCreditUsageByResultIdData = {
  query: {
    /**
     * Result ID
     */
    resultId: string;
    /**
     * Version number (optional, returns latest version if not specified)
     */
    version?: string;
  };
};

export type GetCreditUsageByResultIdResponse2 = GetCreditUsageByResultIdResponse;

export type GetCreditUsageByResultIdError = unknown;

export type GetCreditUsageByExecutionIdData = {
  query: {
    /**
     * Execution ID
     */
    executionId: string;
  };
};

export type GetCreditUsageByExecutionIdResponse2 = GetCreditUsageByExecutionIdResponse;

export type GetCreditUsageByExecutionIdError = unknown;

export type GetCreditUsageByCanvasIdData = {
  query: {
    /**
     * Canvas ID
     */
    canvasId: string;
  };
};

export type GetCreditUsageByCanvasIdResponse2 = GetCreditUsageByCanvasIdResponse;

export type GetCreditUsageByCanvasIdError = unknown;

export type GetCanvasCommissionByCanvasIdData = {
  query: {
    /**
     * Canvas ID
     */
    canvasId: string;
  };
};

export type GetCanvasCommissionByCanvasIdResponse2 = GetCanvasCommissionByCanvasIdResponse;

export type GetCanvasCommissionByCanvasIdError = unknown;

export type ListInvitationCodesResponse2 = ListInvitationCodesResponse;

export type ListInvitationCodesError = unknown;

export type ActivateInvitationCodeData = {
  body: ActivateInvitationCodeRequest;
};

export type ActivateInvitationCodeResponse = BaseResponse;

export type ActivateInvitationCodeError = unknown;

export type SkipInvitationCodeResponse = BaseResponse;

export type SkipInvitationCodeError = unknown;

export type GetSubscriptionPlansResponse2 = GetSubscriptionPlansResponse;

export type GetSubscriptionPlansError = unknown;

export type GetSubscriptionUsageResponse2 = GetSubscriptionUsageResponse;

export type GetSubscriptionUsageError = unknown;

export type ListModelsResponse2 = ListModelsResponse;

export type ListModelsError = unknown;

export type CreateCheckoutSessionData = {
  body: CreateCheckoutSessionRequest;
};

export type CreateCheckoutSessionResponse2 = CreateCheckoutSessionResponse;

export type CreateCheckoutSessionError = unknown;

export type CreateCreditPackCheckoutSessionData = {
  body: CreateCreditPackCheckoutSessionRequest;
};

export type CreateCreditPackCheckoutSessionResponse = CreateCheckoutSessionResponse;

export type CreateCreditPackCheckoutSessionError = unknown;

export type CreatePortalSessionResponse2 = CreatePortalSessionResponse;

export type CreatePortalSessionError = unknown;

export type SearchData = {
  body: SearchRequest;
};

export type SearchResponse2 = SearchResponse;

export type SearchError = unknown;

export type MultiLingualWebSearchData = {
  body: MultiLingualWebSearchRequest;
};

export type MultiLingualWebSearchResponse2 = MultiLingualWebSearchResponse;

export type MultiLingualWebSearchError = unknown;

export type ListProvidersData = {
  query?: {
    /**
     * Provider category
     */
    category?: ProviderCategory;
    /**
     * Whether the provider is enabled
     */
    enabled?: boolean;
    /**
     * Whether the provider is global. If not passed, return both global and user-specific providers.
     */
    isGlobal?: boolean;
    /**
     * Provider key
     */
    providerKey?: string;
  };
};

export type ListProvidersResponse2 = ListProvidersResponse;

export type ListProvidersError = unknown;

export type CreateProviderData = {
  body: UpsertProviderRequest;
};

export type CreateProviderResponse = UpsertProviderResponse;

export type CreateProviderError = unknown;

export type UpdateProviderData = {
  body: UpsertProviderRequest;
};

export type UpdateProviderResponse = UpsertProviderResponse;

export type UpdateProviderError = unknown;

export type DeleteProviderData = {
  body: DeleteProviderRequest;
};

export type DeleteProviderResponse = BaseResponse;

export type DeleteProviderError = unknown;

export type TestProviderConnectionData = {
  body: TestProviderConnectionRequest;
};

export type TestProviderConnectionResponse2 = TestProviderConnectionResponse;

export type TestProviderConnectionError = unknown;

export type ListProviderItemsData = {
  query?: {
    /**
     * Provider category
     */
    category?: ProviderCategory;
    /**
     * Whether the provider item is enabled
     */
    enabled?: boolean;
    /**
     * Whether the provider item is global. If not passed, return both global and user-specific provider items.
     */
    isGlobal?: boolean;
    /**
     * Provider ID
     */
    providerId?: string;
  };
};

export type ListProviderItemsResponse2 = ListProviderItemsResponse;

export type ListProviderItemsError = unknown;

export type ListProviderItemOptionsData = {
  query: {
    /**
     * Provider category
     */
    category?: ProviderCategory;
    /**
     * Provider ID
     */
    providerId: string;
  };
};

export type ListProviderItemOptionsResponse2 = ListProviderItemOptionsResponse;

export type ListProviderItemOptionsError = unknown;

export type CreateProviderItemData = {
  body: UpsertProviderItemRequest;
};

export type CreateProviderItemResponse = UpsertProviderItemResponse;

export type CreateProviderItemError = unknown;

export type BatchCreateProviderItemsData = {
  body: BatchUpsertProviderItemsRequest;
};

export type BatchCreateProviderItemsResponse = BatchUpsertProviderItemsResponse;

export type BatchCreateProviderItemsError = unknown;

export type UpdateProviderItemData = {
  body: UpsertProviderItemRequest;
};

export type UpdateProviderItemResponse = UpsertProviderItemResponse;

export type UpdateProviderItemError = unknown;

export type BatchUpdateProviderItemsData = {
  body: BatchUpsertProviderItemsRequest;
};

export type BatchUpdateProviderItemsResponse = BatchUpsertProviderItemsResponse;

export type BatchUpdateProviderItemsError = unknown;

export type DeleteProviderItemData = {
  body: DeleteProviderItemRequest;
};

export type DeleteProviderItemResponse = BaseResponse;

export type DeleteProviderItemError = unknown;

export type ListToolsData = {
  query?: {
    /**
     * Whether the tool is enabled. If not passed, return both enabled and disabled tools.
     */
    enabled?: boolean;
    /**
     * Whether the tool is global. If not passed, return both global and user-specific tools.
     */
    isGlobal?: boolean;
  };
};

export type ListToolsResponse2 = ListToolsResponse;

export type ListToolsError = unknown;

export type ListUserToolsResponse2 = ListUserToolsResponse;

export type ListUserToolsError = unknown;

export type ListToolsetInventoryResponse2 = ListToolsetInventoryResponse;

export type ListToolsetInventoryError = unknown;

export type ListToolsetsData = {
  query?: {
    /**
     * Whether the toolset is global. If not passed, return both global and user-specific toolsets.
     */
    isGlobal?: boolean;
  };
};

export type ListToolsetsResponse2 = ListToolsetsResponse;

export type ListToolsetsError = unknown;

export type CreateToolsetData = {
  body: UpsertToolsetRequest;
};

export type CreateToolsetResponse = UpsertToolsetResponse;

export type CreateToolsetError = unknown;

export type UpdateToolsetData = {
  body: UpsertToolsetRequest;
};

export type UpdateToolsetResponse = UpsertToolsetResponse;

export type UpdateToolsetError = unknown;

export type DeleteToolsetData = {
  body: DeleteToolsetRequest;
};

export type DeleteToolsetResponse = BaseResponse;

export type DeleteToolsetError = unknown;

export type ExportToolsetDefinitionsData = {
  query?: {
    /**
     * Toolset key(s) to export, comma-separated for multiple toolsets. If not provided, exports all supported toolsets.
     */
    toolsetKey?: string;
  };
};

export type ExportToolsetDefinitionsResponse2 = ExportToolsetDefinitionsResponse;

export type ExportToolsetDefinitionsError = unknown;

export type ExecuteToolData = {
  body: ExecuteToolRequest;
};

export type ExecuteToolResponse2 = ExecuteToolResponse;

export type ExecuteToolError = unknown;

export type GetToolCallResultData = {
  query: {
    /**
     * Tool call ID
     */
    toolCallId: string;
  };
};

export type GetToolCallResultResponse2 = GetToolCallResultResponse;

export type GetToolCallResultError = unknown;

export type AuthorizeComposioConnectionData = {
  path: {
    /**
     * Composio app slug (e.g., gmail, slack).
     */
    app: string;
  };
};

export type AuthorizeComposioConnectionResponse = InitiateComposioConnectionResponse;

export type AuthorizeComposioConnectionError = unknown;

export type RevokeComposioConnectionData = {
  path: {
    /**
     * Composio app slug (e.g., gmail, slack).
     */
    app: string;
  };
};

export type RevokeComposioConnectionResponse = ComposioRevokeResponse;

export type RevokeComposioConnectionError = unknown;

export type GetComposioConnectionStatusData = {
  path: {
    /**
     * Composio app slug (e.g., gmail, slack).
     */
    app: string;
  };
};

export type GetComposioConnectionStatusResponse = ComposioConnectionStatusResponse;

export type GetComposioConnectionStatusError = unknown;

export type ScrapeData = {
  body: ScrapeWeblinkRequest;
};

export type ScrapeResponse = ScrapeWeblinkResponse;

export type ScrapeError = unknown;

export type UploadData = {
  body: UploadRequest;
};

export type UploadResponse2 = UploadResponse;

export type UploadError = unknown;

export type ServeStaticResponse = unknown;

export type ServeStaticError = unknown;

export type ConvertData = {
  body: ConvertRequest;
};

export type ConvertResponse2 = ConvertResponse;

export type ConvertError = unknown;

export type GetPromptSuggestionsResponse2 = GetPromptSuggestionsResponse;

export type GetPromptSuggestionsError = unknown;

export type GetAvailableVouchersResponse2 = GetAvailableVouchersResponse;

export type GetAvailableVouchersError = unknown;

export type ListUserVouchersResponse2 = ListUserVouchersResponse;

export type ListUserVouchersError = unknown;

export type ValidateVoucherData = {
  body: ValidateVoucherRequest;
};

export type ValidateVoucherResponse2 = ValidateVoucherResponse;

export type ValidateVoucherError = unknown;

export type CreateVoucherInvitationData = {
  body: CreateVoucherInvitationRequest;
};

export type CreateVoucherInvitationResponse2 = CreateVoucherInvitationResponse;

export type CreateVoucherInvitationError = unknown;

export type VerifyVoucherInvitationData = {
  query: {
    /**
     * Invitation code
     */
    code: string;
  };
};

export type VerifyVoucherInvitationResponse2 = VerifyVoucherInvitationResponse;

export type VerifyVoucherInvitationError = unknown;

export type ClaimVoucherInvitationData = {
  body: ClaimVoucherInvitationRequest;
};

export type ClaimVoucherInvitationResponse2 = ClaimVoucherInvitationResponse;

export type ClaimVoucherInvitationError = unknown;

export type TriggerVoucherData = {
  body: TriggerVoucherRequest;
};

export type TriggerVoucherResponse2 = TriggerVoucherResponse;

export type TriggerVoucherError = unknown;
