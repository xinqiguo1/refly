// This file is auto-generated by @hey-api/openapi-ts

export const ExtractVariablesRequestSchema = {
  type: 'object',
  required: ['prompt', 'canvasId', 'mode'],
  properties: {
    prompt: {
      type: 'string',
      description: 'Natural language prompt describing the desired functionality',
      minLength: 1,
      maxLength: 500,
      example: 'Create a user registration form with username, email, and password fields',
    },
    canvasId: {
      type: 'string',
      description: 'Canvas ID to retrieve existing variable context and content',
      pattern: '^[a-zA-Z0-9_-]+$',
      example: 'canvas-123',
    },
    mode: {
      type: 'string',
      enum: ['direct', 'candidate'],
      description: `Processing mode for variable extraction:
- direct: Directly update Canvas variables and return results
- candidate: Return candidate solutions for user selection
`,
      example: 'candidate',
    },
    sessionId: {
      type: 'string',
      description: `Optional session ID for direct mode to check for existing candidate records.
When provided in direct mode, the system will check if there are
unapplied candidate records for this session.
`,
      example: 'session-789',
    },
  },
} as const;

export const VariableExtractionResultSchema = {
  type: 'object',
  required: ['originalPrompt', 'processedPrompt', 'variables', 'reusedVariables'],
  properties: {
    originalPrompt: {
      type: 'string',
      description: 'Original natural language prompt from user input',
      example: 'Create a user registration form with username, email, and password fields',
    },
    processedPrompt: {
      type: 'string',
      description: `Processed prompt with variable references embedded.
Variables are represented using handlebars syntax (e.g., {{variableName}}).
`,
      example:
        'Create a user registration form with {{username}}, {{email}}, and {{password}} fields',
    },
    variables: {
      type: 'array',
      description: 'List of extracted workflow variables',
      items: {
        $ref: '#/components/schemas/WorkflowVariable',
      },
    },
    reusedVariables: {
      type: 'array',
      description: 'List of variables that were reused from existing context',
      items: {
        $ref: '#/components/schemas/VariableReuse',
      },
    },
    sessionId: {
      type: 'string',
      description: `Session ID for candidate mode responses.
This ID can be used in subsequent direct mode requests
to apply the selected candidate solution.
`,
      example: 'session-abc123',
    },
    extractionConfidence: {
      type: 'number',
      description: 'Confidence score for the extraction (0.0 to 1.0)',
      example: 0.78,
    },
  },
} as const;

export const VariableReuseSchema = {
  type: 'object',
  description: 'Information about variables reused from existing context',
  required: ['detectedText', 'reusedVariableName', 'confidence', 'reason'],
  properties: {
    detectedText: {
      type: 'string',
      description: 'Text in the prompt that triggered variable reuse detection',
      example: 'form',
    },
    reusedVariableName: {
      type: 'string',
      description: 'Name of the existing variable that was reused',
      example: 'formType',
    },
    confidence: {
      type: 'number',
      format: 'float',
      minimum: 0,
      maximum: 1,
      description: 'Confidence score for the reuse detection (0.0 to 1.0)',
      example: 0.78,
    },
    reason: {
      type: 'string',
      description: 'Explanation of why this variable was reused',
      example: 'Similar form structure detected in existing variables',
    },
  },
} as const;

export const McpServerTypeSchema = {
  type: 'string',
  description: 'MCP Server type',
  enum: ['sse', 'streamable', 'stdio'],
} as const;

export const McpServerDTOSchema = {
  type: 'object',
  required: ['name', 'type', 'enabled', 'isGlobal'],
  properties: {
    name: {
      type: 'string',
      description: 'MCP server name',
      example: 'My MCP Server',
    },
    type: {
      $ref: '#/components/schemas/McpServerType',
    },
    url: {
      type: 'string',
      description: 'MCP server URL (for sse and streamable types)',
      example: 'https://example.com/mcp',
    },
    command: {
      type: 'string',
      description: 'Command to execute (for stdio type)',
      example: 'python',
    },
    args: {
      type: 'array',
      description: 'Command arguments (for stdio type)',
      items: {
        type: 'string',
      },
      example: ['-m', 'server.py'],
    },
    env: {
      type: 'object',
      description: 'Environment variables (for stdio type)',
      additionalProperties: {
        type: 'string',
      },
      example: {
        API_KEY: 'your_api_key',
      },
    },
    headers: {
      type: 'object',
      description: 'HTTP headers (for sse and streamable types)',
      additionalProperties: {
        type: 'string',
      },
      example: {
        Authorization: 'Bearer token',
      },
    },
    reconnect: {
      type: 'object',
      description: 'Reconnection configuration',
      properties: {
        enabled: {
          type: 'boolean',
          description: 'Whether reconnection is enabled',
        },
        maxAttempts: {
          type: 'integer',
          description: 'Maximum number of reconnection attempts',
        },
        delayMs: {
          type: 'integer',
          description: 'Delay between reconnection attempts in milliseconds',
        },
      },
    },
    config: {
      type: 'object',
      description: 'Additional configuration',
      additionalProperties: true,
    },
    enabled: {
      type: 'boolean',
      description: 'Whether the MCP server is enabled',
    },
    isGlobal: {
      type: 'boolean',
      description: 'Whether the MCP server is global',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'MCP server creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'MCP server update time',
    },
  },
} as const;

export const ListMcpServersResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          items: {
            $ref: '#/components/schemas/McpServerDTO',
          },
        },
      },
    },
  ],
} as const;

export const UpsertMcpServerRequestSchema = {
  type: 'object',
  required: ['name', 'type'],
  properties: {
    name: {
      type: 'string',
      description: 'MCP server name',
    },
    type: {
      $ref: '#/components/schemas/McpServerType',
    },
    url: {
      type: 'string',
      description: 'MCP server URL (required for sse and streamable types)',
    },
    command: {
      type: 'string',
      description: 'Command to execute (required for stdio type)',
    },
    args: {
      type: 'array',
      description: 'Command arguments (required for stdio type)',
      items: {
        type: 'string',
      },
    },
    env: {
      type: 'object',
      description: 'Environment variables (for stdio type)',
      additionalProperties: {
        type: 'string',
      },
    },
    headers: {
      type: 'object',
      description: 'HTTP headers (for sse and streamable types)',
      additionalProperties: {
        type: 'string',
      },
    },
    reconnect: {
      type: 'object',
      description: 'Reconnection configuration',
      properties: {
        enabled: {
          type: 'boolean',
          description: 'Whether reconnection is enabled',
        },
        maxAttempts: {
          type: 'integer',
          description: 'Maximum number of reconnection attempts',
        },
        delayMs: {
          type: 'integer',
          description: 'Delay between reconnection attempts in milliseconds',
        },
      },
    },
    config: {
      type: 'object',
      description: 'Additional configuration',
      additionalProperties: true,
    },
    enabled: {
      type: 'boolean',
      description: 'Whether the MCP server is enabled',
    },
  },
} as const;

export const UpsertMcpServerResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/McpServerDTO',
        },
      },
    },
  ],
} as const;

export const DeleteMcpServerRequestSchema = {
  type: 'object',
  required: ['name'],
  properties: {
    name: {
      type: 'string',
      description: 'MCP name to delete',
    },
  },
} as const;

export const McpServerToolSchema = {
  type: 'object',
  required: ['name', 'description'],
  properties: {
    name: {
      type: 'string',
      description: 'Tool name',
      example: 'tool_name',
    },
    description: {
      type: 'string',
      description: 'Tool description',
      example: 'This tool does something useful',
    },
  },
} as const;

export const ValidateMcpServerResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          items: {
            $ref: '#/components/schemas/McpServerTool',
          },
        },
      },
    },
  ],
} as const;

export const DeleteMcpServerResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'null',
        },
      },
    },
  ],
} as const;

export const PageSchema = {
  type: 'object',
  required: ['pageId', 'title', 'createdAt', 'updatedAt'],
  properties: {
    pageId: {
      type: 'string',
      description: 'Page ID',
      example: 'pg-g30e1b80b5g1itbemc0g5jj3',
    },
    title: {
      type: 'string',
      description: 'Page title',
      example: 'My Page',
    },
    description: {
      type: 'string',
      description: 'Page description',
    },
    status: {
      type: 'string',
      description: 'Page status',
      enum: ['draft', 'published'],
    },
    canvasId: {
      type: 'string',
      description: 'Canvas ID associated with this page',
      example: 'cv-g30e1b80b5g1itbemc0g5jj3',
    },
    coverUrl: {
      type: 'string',
      description: 'Page cover URL',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Page creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Page last update time',
    },
  },
} as const;

export const PageNodeRelationSchema = {
  type: 'object',
  required: ['relationId', 'nodeId', 'nodeType', 'entityId', 'orderIndex'],
  properties: {
    relationId: {
      type: 'string',
      description: 'Relation ID',
    },
    pageId: {
      type: 'string',
      description: 'Page ID',
    },
    nodeId: {
      type: 'string',
      description: 'Node ID',
    },
    nodeType: {
      type: 'string',
      description: 'Node type',
    },
    entityId: {
      type: 'string',
      description: 'Entity ID',
    },
    orderIndex: {
      type: 'integer',
      description: 'Order index',
    },
    nodeData: {
      description: 'Node data',
      $ref: '#/components/schemas/CanvasNodeData',
    },
  },
} as const;

export const PageDetailSchema = {
  type: 'object',
  allOf: [
    {
      $ref: '#/components/schemas/Page',
    },
    {
      type: 'object',
      properties: {
        nodeRelations: {
          type: 'array',
          description: 'List of node relations',
          items: {
            $ref: '#/components/schemas/PageNodeRelation',
          },
        },
        pageConfig: {
          type: 'object',
          description: 'Page configuration',
        },
      },
    },
  ],
} as const;

export const UpdatePageRequestSchema = {
  type: 'object',
  properties: {
    title: {
      type: 'string',
      description: 'Page title',
    },
    description: {
      type: 'string',
      description: 'Page description',
    },
    nodeRelations: {
      type: 'array',
      description: 'List of node relations with updated order',
      items: {
        type: 'object',
        properties: {
          nodeId: {
            type: 'string',
            description: 'Node ID',
          },
          orderIndex: {
            type: 'integer',
            description: 'New order index',
          },
        },
      },
    },
  },
} as const;

export const UpdatePageResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          allOf: [
            {
              $ref: '#/components/schemas/Page',
            },
            {
              type: 'object',
              properties: {
                nodeRelations: {
                  type: 'array',
                  description: 'List of node relations',
                  items: {
                    $ref: '#/components/schemas/PageNodeRelation',
                  },
                },
              },
            },
          ],
        },
      },
    },
  ],
} as const;

export const DeletePageResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          properties: {
            pageId: {
              type: 'string',
              description: 'ID of the deleted page',
            },
            canvasId: {
              type: 'string',
              description: 'Canvas ID associated with the deleted page',
            },
          },
        },
      },
    },
  ],
} as const;

export const SharePageResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          properties: {
            pageId: {
              type: 'string',
              description: 'Page ID',
            },
            canvasId: {
              type: 'string',
              description: 'Canvas ID associated with the page',
            },
            shareId: {
              type: 'string',
              description: 'Share ID',
            },
            shareUrl: {
              type: 'string',
              description: 'Share URL',
            },
          },
        },
      },
    },
  ],
} as const;

export const DeletePageNodeResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          properties: {
            pageId: {
              type: 'string',
              description: 'Page ID',
            },
            canvasId: {
              type: 'string',
              description: 'Canvas ID associated with the page',
            },
            nodeId: {
              type: 'string',
              description: 'ID of the deleted node',
            },
          },
        },
      },
    },
  ],
} as const;

export const ListPagesResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          properties: {
            total: {
              type: 'integer',
              description: 'Total number of pages',
            },
            pages: {
              type: 'array',
              description: 'List of pages',
              items: {
                $ref: '#/components/schemas/Page',
              },
            },
          },
        },
      },
    },
  ],
} as const;

export const PageDetailResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/PageDetail',
        },
      },
    },
  ],
} as const;

export const AddPageNodesRequestSchema = {
  type: 'object',
  required: ['nodeIds'],
  properties: {
    nodeIds: {
      type: 'array',
      description: 'List of node IDs to add to the page',
      items: {
        type: 'string',
      },
    },
  },
} as const;

export const AddPageNodesResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          properties: {
            page: {
              $ref: '#/components/schemas/Page',
            },
            nodeRelations: {
              type: 'array',
              description: 'List of node relations',
              items: {
                $ref: '#/components/schemas/PageNodeRelation',
              },
            },
          },
        },
      },
    },
  ],
} as const;

export const CanvasPageResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          properties: {
            page: {
              $ref: '#/components/schemas/Page',
            },
            nodeRelations: {
              type: 'array',
              description: 'List of node relations',
              items: {
                $ref: '#/components/schemas/PageNodeRelation',
              },
            },
          },
        },
      },
    },
  ],
} as const;

export const UserSchema = {
  type: 'object',
  description: 'Refly user, used as JWT payload',
  required: ['uid'],
  properties: {
    uid: {
      type: 'string',
      description: 'UID',
    },
    email: {
      type: 'string',
      description: 'Email',
    },
  },
} as const;

export const AuthTypeSchema = {
  type: 'string',
  description: 'Auth type',
  enum: ['email', 'oauth'],
} as const;

export const AccountSchema = {
  type: 'object',
  description: 'Auth account',
  required: ['type', 'provider', 'providerAccountId'],
  properties: {
    type: {
      $ref: '#/components/schemas/AuthType',
      description: 'Auth type',
    },
    provider: {
      type: 'string',
      description: 'Provider',
    },
    scope: {
      type: 'array',
      description: 'Auth scope',
      items: {
        type: 'string',
      },
    },
    providerAccountId: {
      type: 'string',
      description: 'Provider account ID',
    },
  },
} as const;

export const ListAccountsResponseSchema = {
  type: 'object',
  description: 'List auth accounts response',
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'List of auth accounts',
          items: {
            $ref: '#/components/schemas/Account',
          },
        },
      },
    },
  ],
} as const;

export const CheckToolOAuthStatusResponseSchema = {
  type: 'object',
  description: 'Check tool OAuth status response',
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'OAuth status information',
          properties: {
            authorized: {
              type: 'boolean',
              description: 'Whether user has sufficient OAuth authorization',
            },
            provider: {
              type: 'string',
              description: 'OAuth provider',
            },
            scope: {
              type: 'array',
              description: 'Required OAuth scopes',
              items: {
                type: 'string',
              },
            },
          },
        },
      },
    },
  ],
} as const;

export const ShareUserSchema = {
  type: 'object',
  description: 'Refly user in shared entity',
  required: ['uid'],
  properties: {
    uid: {
      type: 'string',
      description: 'UID',
    },
    name: {
      type: 'string',
      description: 'User name',
    },
    nickname: {
      type: 'string',
      description: 'User nickname',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'User creation time',
    },
    avatar: {
      type: 'string',
      description: 'User avatar',
    },
  },
} as const;

export const ListOrderSchema = {
  type: 'string',
  description: 'List order',
  enum: ['creationAsc', 'creationDesc', 'updationAsc', 'updationDesc'],
} as const;

export const CanvasStatusSchema = {
  type: 'string',
  description: 'Canvas status',
  enum: ['ready', 'duplicating', 'duplicate_failed'],
} as const;

export const CanvasSchema = {
  type: 'object',
  required: ['canvasId', 'title', 'createdAt', 'updatedAt'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID',
      example: 'c-g30e1b80b5g1itbemc0g5jj3',
    },
    title: {
      type: 'string',
      description: 'Canvas title',
      example: 'My canvas',
    },
    readOnly: {
      type: 'boolean',
      description: 'Whether this canvas is read-only',
    },
    status: {
      type: 'string',
      description: 'Canvas status',
      $ref: '#/components/schemas/CanvasStatus',
    },
    owner: {
      description: 'Canvas owner',
      $ref: '#/components/schemas/ShareUser',
    },
    shareRecord: {
      description: 'Canvas share record',
      $ref: '#/components/schemas/ShareRecord',
    },
    workflowApp: {
      description: 'Canvas workflow app',
      $ref: '#/components/schemas/WorkflowApp',
    },
    usedToolsets: {
      type: 'array',
      description: 'Used toolsets in the canvas',
      items: {
        type: 'object',
        $ref: '#/components/schemas/GenericToolset',
      },
    },
    minimapUrl: {
      type: 'string',
      description: 'Minimap URL',
    },
    minimapStorageKey: {
      type: 'string',
      description: 'Minimap storage key',
    },
    schedule: {
      description: 'Workflow schedule configuration',
      $ref: '#/components/schemas/WorkflowSchedule',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Canvas creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Canvas update time',
    },
  },
} as const;

export const WorkflowScheduleSchema = {
  type: 'object',
  properties: {
    scheduleId: {
      type: 'string',
      description: 'Schedule ID',
    },
    name: {
      type: 'string',
      description: 'Schedule name',
    },
    isEnabled: {
      type: 'boolean',
      description: 'Whether the schedule is enabled',
    },
    cronExpression: {
      type: 'string',
      description: 'Cron expression',
    },
    scheduleConfig: {
      type: 'string',
      description: 'Schedule config JSON (type, time, weekdays, monthDays)',
    },
    timezone: {
      type: 'string',
      description: 'Timezone',
    },
    nextRunAt: {
      type: 'string',
      format: 'date-time',
      description: 'Next run time',
    },
    lastRunAt: {
      type: 'string',
      format: 'date-time',
      description: 'Last run time',
    },
  },
} as const;

export const CreateScheduleRequestSchema = {
  type: 'object',
  required: ['canvasId', 'name', 'cronExpression', 'scheduleConfig'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID to schedule',
    },
    name: {
      type: 'string',
      description: 'Schedule name',
    },
    cronExpression: {
      type: 'string',
      description: 'Cron expression for scheduling',
    },
    scheduleConfig: {
      type: 'string',
      description: 'Schedule configuration JSON',
    },
    timezone: {
      type: 'string',
      description: 'Timezone for schedule execution',
    },
    isEnabled: {
      type: 'boolean',
      description: 'Whether the schedule is enabled',
      default: true,
    },
  },
} as const;

export const CreateScheduleResponseSchema = {
  type: 'object',
  properties: {
    success: {
      type: 'boolean',
      description: 'Whether the operation was successful',
    },
    data: {
      $ref: '#/components/schemas/WorkflowSchedule',
    },
    message: {
      type: 'string',
      description: 'Response message',
    },
  },
} as const;

export const UpdateScheduleRequestSchema = {
  type: 'object',
  required: ['scheduleId'],
  properties: {
    scheduleId: {
      type: 'string',
      description: 'Schedule ID to update',
    },
    name: {
      type: 'string',
      description: 'Schedule name',
    },
    cronExpression: {
      type: 'string',
      description: 'Cron expression for scheduling',
    },
    scheduleConfig: {
      type: 'string',
      description: 'Schedule configuration JSON',
    },
    timezone: {
      type: 'string',
      description: 'Timezone for schedule execution',
    },
    isEnabled: {
      type: 'boolean',
      description: 'Whether the schedule is enabled',
    },
  },
} as const;

export const UpdateScheduleResponseSchema = {
  type: 'object',
  properties: {
    success: {
      type: 'boolean',
      description: 'Whether the operation was successful',
    },
    data: {
      $ref: '#/components/schemas/WorkflowSchedule',
    },
    message: {
      type: 'string',
      description: 'Response message',
    },
  },
} as const;

export const DeleteScheduleRequestSchema = {
  type: 'object',
  required: ['scheduleId'],
  properties: {
    scheduleId: {
      type: 'string',
      description: 'Schedule ID to delete',
    },
  },
} as const;

export const DeleteScheduleResponseSchema = {
  type: 'object',
  properties: {
    success: {
      type: 'boolean',
      description: 'Whether the operation was successful',
    },
    message: {
      type: 'string',
      description: 'Response message',
    },
  },
} as const;

export const ListSchedulesRequestSchema = {
  type: 'object',
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID to filter schedules',
    },
    page: {
      type: 'integer',
      description: 'Page number for pagination',
      default: 1,
    },
    pageSize: {
      type: 'integer',
      description: 'Number of items per page',
      default: 10,
    },
  },
} as const;

export const ListSchedulesResponseSchema = {
  type: 'object',
  properties: {
    success: {
      type: 'boolean',
      description: 'Whether the operation was successful',
    },
    data: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/WorkflowSchedule',
      },
      description: 'List of schedules',
    },
    total: {
      type: 'integer',
      description: 'Total number of schedules',
    },
    page: {
      type: 'integer',
      description: 'Current page number',
    },
    pageSize: {
      type: 'integer',
      description: 'Number of items per page',
    },
  },
} as const;

export const GetScheduleDetailRequestSchema = {
  type: 'object',
  required: ['scheduleId'],
  properties: {
    scheduleId: {
      type: 'string',
      description: 'Schedule ID to get details for',
    },
  },
} as const;

export const GetScheduleDetailResponseSchema = {
  type: 'object',
  properties: {
    success: {
      type: 'boolean',
      description: 'Whether the operation was successful',
    },
    data: {
      $ref: '#/components/schemas/WorkflowSchedule',
    },
    message: {
      type: 'string',
      description: 'Response message',
    },
  },
} as const;

export const CanvasTemplateCategorySchema = {
  type: 'object',
  required: ['categoryId', 'name', 'labelDict', 'descriptionDict'],
  properties: {
    categoryId: {
      type: 'string',
      description: 'Category ID',
    },
    name: {
      type: 'string',
      description: 'Category name',
    },
    labelDict: {
      type: 'object',
      description: 'Category label dictionary',
      additionalProperties: {
        type: 'string',
      },
    },
    descriptionDict: {
      type: 'object',
      description: 'Category description dictionary',
      additionalProperties: {
        type: 'string',
      },
    },
  },
} as const;

export const CanvasTemplateSchema = {
  type: 'object',
  required: ['templateId', 'shareId', 'title', 'description', 'language', 'createdAt', 'updatedAt'],
  properties: {
    templateId: {
      type: 'string',
      description: 'Canvas template ID',
      example: 'ct-g30e1b80b5g1itbemc0g5jj3',
    },
    shareId: {
      type: 'string',
      description: 'Share ID',
      example: 'can-g30e1b80b5g1itbemc0g5jj3',
    },
    shareUser: {
      description: 'Share user',
      $ref: '#/components/schemas/ShareUser',
    },
    version: {
      type: 'integer',
      description: 'Canvas template version',
    },
    category: {
      description: 'Canvas template category',
      $ref: '#/components/schemas/CanvasTemplateCategory',
    },
    title: {
      type: 'string',
      description: 'Canvas template title',
    },
    description: {
      type: 'string',
      description: 'Canvas template description',
    },
    language: {
      type: 'string',
      description: 'Canvas template language code',
    },
    featured: {
      type: 'boolean',
      description: 'Whether this canvas template is featured',
    },
    appId: {
      type: 'string',
      description: 'Workflow app ID',
    },
    coverUrl: {
      type: 'string',
      description: 'Canvas template cover image URL',
    },
    appShareId: {
      type: 'string',
      description: 'Associated workflow app share ID',
    },
    creditUsage: {
      type: 'integer',
      description: 'Credit usage for running this workflow app',
      nullable: true,
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Canvas template creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Canvas template update time',
    },
  },
} as const;

export const ResourceMetaSchema = {
  type: 'object',
  description: 'Resource metadata',
  properties: {
    url: {
      type: 'string',
      description: 'Weblink URL',
      example: 'https://www.google.com',
    },
    title: {
      type: 'string',
      description: 'Weblink title',
      example: 'Google',
    },
    contentType: {
      type: 'string',
      description: 'File content type (MIME type)',
      example: 'application/pdf',
    },
  },
} as const;

export const ResourceTypeSchema = {
  type: 'string',
  description: 'Resource type',
  enum: ['weblink', 'text', 'file', 'document', 'image', 'video', 'audio', 'text/plain'],
} as const;

export const IndexErrorSchema = {
  type: 'object',
  description: 'Error message for resource indexing',
  properties: {
    type: {
      type: 'string',
      description: 'Error type',
      enum: ['pageLimitExceeded', 'unknownError'],
    },
    metadata: {
      type: 'object',
      description: 'Error metadata',
    },
  },
} as const;

export const ResourceSchema = {
  type: 'object',
  required: ['resourceId', 'resourceType', 'title'],
  properties: {
    resourceId: {
      type: 'string',
      description: "Resource ID (empty if it's external)",
      example: 'r-g30e1b80b5g1itbemc0g5jj3',
    },
    resourceType: {
      description: 'Resource type',
      $ref: '#/components/schemas/ResourceType',
    },
    title: {
      type: 'string',
      description: 'Resource title',
    },
    data: {
      type: 'object',
      description: 'Resource metadata',
      $ref: '#/components/schemas/ResourceMeta',
    },
    indexStatus: {
      description: 'Resource index status',
      $ref: '#/components/schemas/IndexStatus',
    },
    indexError: {
      description: 'Error message for resource indexing',
      $ref: '#/components/schemas/IndexError',
    },
    storageKey: {
      type: 'string',
      description: 'Resource storage key',
    },
    storageSize: {
      type: 'string',
      description: 'Resource storage size (in bytes)',
    },
    vectorSize: {
      type: 'string',
      description: 'Resource vector storage size (in bytes)',
    },
    rawFileKey: {
      type: 'string',
      description: 'Raw file storage key (used to download the file)',
    },
    canvasId: {
      type: 'string',
      description: 'Canvas ID to bind with',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Resource creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Resource update time',
    },
    contentPreview: {
      type: 'string',
      description: 'Preview content for this resource',
    },
    shareId: {
      type: 'string',
      description: 'Share ID',
    },
    content: {
      type: 'string',
      description: 'Document content for this resource (only returned in getResourceDetail API)',
    },
    downloadURL: {
      type: 'string',
      description: 'Download URL for this resource (for file type only)',
    },
    publicURL: {
      type: 'string',
      description: 'Publicly accessible URL for this resource (file type only)',
    },
  },
} as const;

export const DocumentSchema = {
  type: 'object',
  required: ['docId', 'title'],
  properties: {
    docId: {
      type: 'string',
      description: 'Document ID',
      example: 'd-g30e1b80b5g1itbemc0g5jj3',
    },
    title: {
      type: 'string',
      description: 'Document title',
      example: 'My document',
    },
    contentPreview: {
      type: 'string',
      description: 'Document content preview',
    },
    content: {
      type: 'string',
      description: 'Full document content (only returned in detail api)',
    },
    readOnly: {
      type: 'boolean',
      description: 'Whether this document is read-only',
    },
    canvasId: {
      type: 'string',
      description: 'Canvas ID to bind with',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Document creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Document update time',
    },
  },
} as const;

export const EntityTypeSchema = {
  type: 'string',
  description: 'Entity type',
  enum: [
    'document',
    'resource',
    'canvas',
    'share',
    'user',
    'project',
    'skillResponse',
    'codeArtifact',
    'page',
    'mediaResult',
    'workflowApp',
    'driveFile',
  ],
} as const;

export const EntitySchema = {
  type: 'object',
  description: 'Entity',
  properties: {
    entityId: {
      type: 'string',
      description: 'Entity ID',
    },
    entityType: {
      description: 'Entity type',
      $ref: '#/components/schemas/EntityType',
    },
  },
} as const;

export const ProjectSourceSchema = {
  type: 'object',
  description: 'Project source',
  properties: {
    entityId: {
      type: 'string',
      description: 'Entity ID',
    },
    entityType: {
      description: 'Entity type',
      $ref: '#/components/schemas/EntityType',
    },
    title: {
      type: 'string',
      description: 'Project title',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Project creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Project update time',
    },
  },
} as const;

export const ProjectSchema = {
  type: 'object',
  description: 'Project',
  required: ['projectId', 'name'],
  properties: {
    projectId: {
      type: 'string',
      description: 'Project ID',
    },
    name: {
      type: 'string',
      description: 'Project name',
    },
    description: {
      type: 'string',
      description: 'Project description',
    },
    coverUrl: {
      type: 'string',
      description: 'Project cover URL',
    },
    customInstructions: {
      type: 'string',
      description: 'Custom instructions for the project',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Project creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Project update time',
    },
  },
} as const;

export const LabelClassSchema = {
  type: 'object',
  description: 'Label class',
  required: ['labelClassId', 'name', 'displayName', 'createdAt', 'updatedAt'],
  properties: {
    labelClassId: {
      type: 'string',
      description: 'Label class ID',
      example: 'lc-g30e1b80b5g1itbemc0g5jj3',
    },
    name: {
      type: 'string',
      description: 'Label class name',
      example: 'Related Dataset',
    },
    displayName: {
      type: 'string',
      description: 'Label class display name',
      example: 'Label display name',
    },
    icon: {
      description: 'Label icon',
      $ref: '#/components/schemas/Icon',
    },
    prompt: {
      type: 'string',
      description: 'Label creation instruction prompt',
      example: 'Extract labels for the tech-related keywords',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Label class creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Label class update time',
    },
  },
} as const;

export const LabelInstanceSchema = {
  type: 'object',
  description: 'Label instances related to entities',
  required: ['labelId', 'labelClassId', 'value'],
  properties: {
    labelId: {
      type: 'string',
      description: 'Label instance ID',
      example: 'lb-g30e1b80b5g1itbemc0g5jj3',
    },
    labelClassId: {
      type: 'string',
      description: 'Label class ID',
      example: 'lc-g30e1b80b5g1itbemc0g5jj3',
    },
    labelClass: {
      description: 'Label class',
      $ref: '#/components/schemas/LabelClass',
    },
    value: {
      type: 'string',
      description: 'Label value',
      example: 'HotPotQA',
    },
  },
} as const;

export const InputModeSchema = {
  type: 'string',
  description: 'Data input mode',
  enum: ['text', 'textarea', 'number', 'select', 'multiSelect', 'radio', 'switch'],
} as const;

export const ConfigScopeSchema = {
  type: 'array',
  description: 'Config scope',
  items: {
    type: 'string',
    enum: ['runtime', 'template'],
  },
} as const;

export const SelectOptionSchema = {
  type: 'object',
  description: 'Select option',
  required: ['value'],
  properties: {
    value: {
      type: 'string',
      description: 'Option value',
    },
    labelDict: {
      type: 'object',
      description: 'Option label (key is locale, value is label)',
      additionalProperties: {
        type: 'string',
      },
    },
    disabled: {
      type: 'boolean',
      description: 'Whether this option is disabled',
      default: false,
    },
  },
} as const;

export const DynamicConfigItemSchema = {
  type: 'object',
  description: 'Dynamic config item',
  required: ['key', 'inputMode', 'labelDict', 'descriptionDict'],
  properties: {
    key: {
      type: 'string',
      description: 'Config key',
    },
    inputMode: {
      description: 'Config input mode',
      $ref: '#/components/schemas/InputMode',
    },
    required: {
      type: 'boolean',
      description: 'Specifies whether this config is required',
      default: false,
    },
    labelDict: {
      type: 'object',
      description: 'Config label (key is locale, value is label)',
      additionalProperties: {
        type: 'string',
      },
    },
    descriptionDict: {
      type: 'object',
      description: 'Config description (key is locale, value is description)',
      additionalProperties: {
        type: 'string',
      },
    },
    defaultValue: {
      description: 'Default value',
      oneOf: [
        {
          type: 'number',
        },
        {
          type: 'string',
        },
        {
          type: 'boolean',
        },
        {
          type: 'array',
          items: {
            type: 'string',
          },
        },
      ],
    },
    options: {
      type: 'array',
      description: 'Config options',
      items: {
        $ref: '#/components/schemas/SelectOption',
      },
    },
    inputProps: {
      type: 'object',
      description: 'Additional input properties',
      properties: {
        min: {
          type: 'number',
          description: 'Minimum value for number input',
        },
        max: {
          type: 'number',
          description: 'Maximum value for number input',
        },
        step: {
          type: 'number',
          description: 'Step value for number input',
        },
        precision: {
          type: 'number',
          description: 'Decimal precision for number input',
        },
        passwordType: {
          type: 'boolean',
          description: 'Whether to display as password input',
        },
      },
    },
  },
} as const;

export const DynamicConfigValueSchema = {
  type: 'object',
  description: 'Dynamic config value',
  required: ['label', 'value', 'displayValue'],
  properties: {
    label: {
      type: 'string',
      description: 'Config key label',
    },
    value: {
      oneOf: [
        {
          type: 'string',
        },
        {
          type: 'number',
        },
        {
          type: 'boolean',
        },
        {
          type: 'array',
          items: {
            type: 'string',
          },
        },
        {
          type: 'object',
          additionalProperties: true,
        },
      ],
      description: 'Config value',
    },
    displayValue: {
      type: 'string',
      description: 'Config display value',
    },
    configScope: {
      description: 'The contexts in which the requirement applies',
      $ref: '#/components/schemas/ConfigScope',
    },
  },
} as const;

export const SkillTemplateConfigDefinitionSchema = {
  type: 'object',
  description: 'Skill template config schema',
  required: ['items'],
  properties: {
    items: {
      type: 'array',
      description: 'Config items',
      items: {
        $ref: '#/components/schemas/DynamicConfigItem',
      },
    },
  },
} as const;

export const IconTypeSchema = {
  type: 'string',
  description: 'Icon type',
  enum: ['emoji', 'image'],
} as const;

export const IconSchema = {
  type: 'object',
  description: 'Icon',
  required: ['type', 'value'],
  properties: {
    type: {
      description: 'Icon type',
      $ref: '#/components/schemas/IconType',
    },
    value: {
      type: 'string',
      description: 'Icon value',
    },
  },
} as const;

export const SkillSchema = {
  type: 'object',
  description: 'Skill',
  required: ['name'],
  properties: {
    name: {
      type: 'string',
      description: 'Skill name',
    },
    description: {
      type: 'string',
      description: 'Skill description',
    },
    icon: {
      description: 'Skill icon',
      $ref: '#/components/schemas/Icon',
    },
    configSchema: {
      description: 'Skill config schema',
      $ref: '#/components/schemas/SkillTemplateConfigDefinition',
    },
    tplConfig: {
      description: 'Skill template config',
      $ref: '#/components/schemas/SkillTemplateConfig',
    },
  },
} as const;

export const SkillTriggerTypeSchema = {
  type: 'string',
  description: 'Skill trigger type',
  enum: ['timer', 'simpleEvent'],
} as const;

export const SimpleEventNameSchema = {
  type: 'string',
  description: 'Simple event name',
  enum: ['onResourceReady'],
} as const;

export const SimpleEventSchema = {
  type: 'object',
  required: ['name', 'displayName'],
  properties: {
    name: {
      description: 'Simple event name',
      $ref: '#/components/schemas/SimpleEventName',
    },
    displayName: {
      type: 'object',
      description: 'Simple event display name (key is locale, value is display name)',
    },
  },
} as const;

export const TimerIntervalSchema = {
  type: 'string',
  description: 'Timer interval',
  enum: ['hour', 'day', 'week', 'month', 'year'],
} as const;

export const TimerTriggerConfigSchema = {
  type: 'object',
  required: ['datetime'],
  properties: {
    datetime: {
      type: 'string',
      format: 'date-time',
      description: 'Time to run',
    },
    repeatInterval: {
      type: 'string',
      description: 'Repeat interval',
      $ref: '#/components/schemas/TimerInterval',
    },
  },
} as const;

export const SkillTriggerSchema = {
  type: 'object',
  description: 'Skill triggers',
  required: [
    'skillId',
    'displayName',
    'triggerId',
    'triggerType',
    'enabled',
    'createdAt',
    'updatedAt',
  ],
  properties: {
    skillId: {
      type: 'string',
      description: 'Skill ID',
      example: 'sk-g30e1b80b5g1itbemc0g5jj3',
    },
    displayName: {
      type: 'string',
      description: 'Trigger display name',
      example: 'My trigger',
    },
    triggerId: {
      type: 'string',
      description: 'Trigger ID',
      example: 'tr-g30e1b80b5g1itbemc0g5jj3',
    },
    triggerType: {
      description: 'Trigger type',
      $ref: '#/components/schemas/SkillTriggerType',
    },
    simpleEventName: {
      description: 'Simple event name (only required when trigger type is `simpleEvent`)',
      $ref: '#/components/schemas/SimpleEventName',
    },
    timerConfig: {
      description: 'Timer config (only required when trigger type is `timer`)',
      $ref: '#/components/schemas/TimerTriggerConfig',
    },
    input: {
      description: 'Skill input',
      $ref: '#/components/schemas/SkillInput',
    },
    context: {
      description: 'Skill context',
      $ref: '#/components/schemas/SkillContext',
    },
    tplConfig: {
      description: 'Skill template config',
      $ref: '#/components/schemas/SkillTemplateConfig',
    },
    enabled: {
      type: 'boolean',
      description: 'Trigger enabled',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Trigger creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Trigger update time',
    },
  },
} as const;

export const SkillMetaSchema = {
  type: 'object',
  description: 'Skill metadata',
  required: ['name'],
  properties: {
    name: {
      type: 'string',
      description: 'Skill name',
    },
    icon: {
      description: 'Skill icon',
      $ref: '#/components/schemas/Icon',
    },
  },
} as const;

export const ActionMetaSchema = {
  type: 'object',
  description: 'Action metadata',
  required: ['name'],
  properties: {
    type: {
      type: 'string',
      description: 'Action type',
      $ref: '#/components/schemas/ActionType',
    },
    name: {
      type: 'string',
      description: 'Action name',
    },
    icon: {
      description: 'Action icon',
      $ref: '#/components/schemas/Icon',
    },
  },
} as const;

export const SkillRuntimeConfigSchema = {
  type: 'object',
  description: 'Skill runtime config',
  properties: {
    disableLinkParsing: {
      type: 'boolean',
      description: 'Whether to disable link parsing for input query',
    },
    enabledKnowledgeBase: {
      type: 'boolean',
      description: 'Whether to enable knowledge base for input query',
    },
  },
} as const;

export const SkillTemplateConfigSchema = {
  type: 'object',
  description: 'Skill template config (key is config item key, value is config value)',
  additionalProperties: {
    description: 'Skill template config value',
    $ref: '#/components/schemas/DynamicConfigValue',
  },
} as const;

export const ActionConfigSchema = {
  type: 'object',
  description: 'Action config (key is config item key, value is config value)',
  additionalProperties: {
    description: 'Skill template config value',
    $ref: '#/components/schemas/DynamicConfigValue',
  },
} as const;

export const SkillInstanceSchema = {
  type: 'object',
  description: 'Skill',
  allOf: [
    {
      $ref: '#/components/schemas/SkillMeta',
    },
    {
      type: 'object',
      required: ['createdAt', 'updatedAt', 'invocationConfig'],
      properties: {
        description: {
          type: 'string',
          description: 'Skill instance description',
        },
        promptHint: {
          type: 'string',
          description: 'Skill instance prompt hint',
        },
        tplConfig: {
          description: 'Skill template config',
          $ref: '#/components/schemas/SkillTemplateConfig',
        },
        tplConfigSchema: {
          description: 'Skill template config schema',
          $ref: '#/components/schemas/SkillTemplateConfigDefinition',
        },
        pinnedAt: {
          type: 'string',
          format: 'date-time',
          description: 'Skill pinned time',
        },
        createdAt: {
          type: 'string',
          format: 'date-time',
          description: 'Skill creation time',
        },
        updatedAt: {
          type: 'string',
          format: 'date-time',
          description: 'Skill update time',
        },
      },
    },
  ],
} as const;

export const SourceMetaSchema = {
  type: 'object',
  description: 'Source metadata',
  properties: {
    source: {
      type: 'string',
      description: 'Source URL',
      deprecated: true,
    },
    title: {
      type: 'string',
      description: 'Source title',
      deprecated: true,
    },
    publishedTime: {
      type: 'string',
      format: 'date-time',
      description: 'Source publish timesss',
    },
    entityId: {
      type: 'string',
      description: 'Related entity ID',
    },
    entityType: {
      type: 'string',
      description: 'Related entity type',
    },
    originalLocale: {
      type: 'string',
      description: 'Original locale',
    },
    translatedDisplayLocale: {
      type: 'string',
      description: 'Translated display locale',
    },
    isTranslated: {
      type: 'boolean',
      description: 'Whether the source is translated',
    },
    originalQuery: {
      type: 'string',
      description: 'Original query',
    },
    translatedQuery: {
      type: 'string',
      description: 'Translated query',
    },
    sourceType: {
      type: 'string',
      description: 'Source type',
      enum: ['webSearch', 'library'],
    },
  },
} as const;

export const SourceSelectionSchema = {
  type: 'object',
  description: 'Source selection',
  required: ['content', 'type'],
  properties: {
    xPath: {
      type: 'string',
      description: 'Selected xPath',
      deprecated: true,
    },
    content: {
      type: 'string',
      description: 'Selected content',
    },
    type: {
      type: 'string',
      description: 'Selection type',
      enum: ['text', 'table', 'link', 'image', 'video', 'audio'],
    },
  },
} as const;

export const SourceSchema = {
  type: 'object',
  description: 'Source of the message',
  required: ['pageContent'],
  properties: {
    url: {
      type: 'string',
      description: 'Source URL',
    },
    title: {
      type: 'string',
      description: 'Source title',
    },
    pageContent: {
      type: 'string',
      description: 'Source content',
    },
    score: {
      type: 'number',
      description: 'Relativity score',
    },
    metadata: {
      type: 'object',
      description: 'Source metadata',
      $ref: '#/components/schemas/SourceMeta',
    },
    selections: {
      type: 'array',
      description: 'Source selections',
      items: {
        $ref: '#/components/schemas/SourceSelection',
      },
    },
  },
} as const;

export const SearchStepSchema = {
  type: 'object',
  description: 'Search step',
  properties: {
    step: {
      type: 'string',
      description: 'Search step name',
    },
    duration: {
      type: 'number',
      description: 'Step duration in milliseconds',
    },
    result: {
      type: 'object',
      description: 'Step-specific result data',
    },
  },
} as const;

export const ModelTierSchema = {
  type: 'string',
  description: 'Model tier',
  enum: ['t1', 't2', 'free'],
} as const;

export const TokenUsageItemSchema = {
  type: 'object',
  description: 'Token usage item',
  required: ['modelName', 'modelProvider', 'inputTokens', 'outputTokens'],
  properties: {
    modelName: {
      type: 'string',
      description: 'Model name',
    },
    modelProvider: {
      type: 'string',
      description: 'Model provider',
    },
    modelLabel: {
      type: 'string',
      description: 'Model label',
    },
    inputTokens: {
      type: 'number',
      description: 'Input tokens',
    },
    outputTokens: {
      type: 'number',
      description: 'Output tokens',
    },
    cacheReadTokens: {
      type: 'number',
      description: 'Cache read tokens',
    },
    cacheWriteTokens: {
      type: 'number',
      description: 'Cache write tokens',
    },
    providerItemId: {
      type: 'string',
      description: 'Provider item ID',
    },
    tier: {
      type: 'string',
      description: 'Model tier',
      deprecated: true,
    },
    originalModelId: {
      type: 'string',
      description: "Original model ID before routing (e.g., 'auto')",
    },
    modelRoutedData: {
      type: 'object',
      description: 'Complete model routing metadata (JSON)',
      properties: {
        isRouted: {
          type: 'boolean',
          description: 'Whether this request was routed',
        },
        originalItemId: {
          type: 'string',
          description: 'Original provider item ID before routing',
        },
        originalModelId: {
          type: 'string',
          description: "Original model ID (e.g., 'auto')",
        },
        originalProvider: {
          type: 'string',
          description: 'Original model provider name',
        },
        originalModelName: {
          type: 'string',
          description: 'Original model name/label for display',
        },
        routedAt: {
          type: 'string',
          format: 'date-time',
          description: 'Routing timestamp',
        },
        routingStrategy: {
          type: 'string',
          description: "Routing strategy used (e.g., 'auto', 'load_balance', 'region')",
        },
      },
    },
  },
} as const;

export const ActionStatusSchema = {
  type: 'string',
  description: 'Action status',
  enum: ['init', 'waiting', 'executing', 'finish', 'failed'],
} as const;

export const ActionErrorTypeSchema = {
  type: 'string',
  description: 'Action error type',
  enum: ['systemError', 'userAbort'],
} as const;

export const ArtifactTypeSchema = {
  type: 'string',
  description: 'Artifact type',
  enum: ['document', 'codeArtifact', 'image', 'video', 'audio'],
} as const;

export const ArtifactStatusSchema = {
  type: 'string',
  description: 'Artifact status',
  enum: ['waiting', 'generating', 'finish', 'failed'],
} as const;

export const ArtifactSchema = {
  type: 'object',
  description: 'Artifact',
  required: ['type', 'entityId', 'title'],
  properties: {
    type: {
      type: 'string',
      description: 'Artifact type',
      $ref: '#/components/schemas/ArtifactType',
    },
    entityId: {
      type: 'string',
      description: 'Entity ID',
    },
    title: {
      type: 'string',
      description: 'Artifact title',
    },
    status: {
      description: 'Artifact status',
      $ref: '#/components/schemas/ArtifactStatus',
    },
    content: {
      type: 'string',
      description: 'Artifact content',
    },
    metadata: {
      type: 'object',
      description: 'Artifact metadata',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Artifact creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Artifact update time',
    },
  },
} as const;

export const ActionStepMetaSchema = {
  type: 'object',
  description: 'Action step metadata',
  required: ['name'],
  properties: {
    name: {
      type: 'string',
      description: 'Step name',
    },
  },
} as const;

export const ActionLogSchema = {
  type: 'object',
  description: 'Action log',
  required: ['key'],
  properties: {
    key: {
      type: 'string',
      description: 'Log key',
    },
    titleArgs: {
      type: 'object',
      description: 'Log title arguments',
    },
    descriptionArgs: {
      type: 'object',
      description: 'Log description arguments',
    },
  },
} as const;

export const ActionStepSchema = {
  type: 'object',
  description: 'Action step',
  required: ['name', 'status'],
  properties: {
    name: {
      type: 'string',
      description: 'Step name',
    },
    content: {
      type: 'string',
      description: 'Step content',
    },
    reasoningContent: {
      type: 'string',
      description: 'Step reasoning content',
    },
    artifacts: {
      type: 'array',
      description: 'Step artifacts',
      items: {
        $ref: '#/components/schemas/Artifact',
      },
    },
    structuredData: {
      type: 'object',
      description: 'Step structured data output',
      example: {
        sources: ['Source'],
        relatedQuestions: ['string'],
      },
    },
    logs: {
      type: 'array',
      description: 'Action step logs',
      items: {
        $ref: '#/components/schemas/ActionLog',
      },
    },
    tokenUsage: {
      type: 'array',
      description: 'Token usage',
      items: {
        $ref: '#/components/schemas/TokenUsageItem',
      },
    },
    toolCalls: {
      type: 'array',
      description: 'Tool calls in this step',
      items: {
        $ref: '#/components/schemas/ToolCallResult',
      },
    },
  },
} as const;

export const CodeArtifactTypeSchema = {
  type: 'string',
  description: 'Code artifact type',
  enum: [
    'application/refly.artifacts.react',
    'image/svg+xml',
    'application/refly.artifacts.mermaid',
    'text/markdown',
    'application/refly.artifacts.code',
    'text/html',
    'application/refly.artifacts.mindmap',
    'text/csv',
    'application/json',
    'text/plain',
  ],
} as const;

export const CodeArtifactSchema = {
  type: 'object',
  description: 'Code artifact',
  required: ['type', 'artifactId', 'title'],
  properties: {
    type: {
      type: 'string',
      description: 'Artifact type',
      $ref: '#/components/schemas/CodeArtifactType',
    },
    artifactId: {
      type: 'string',
      description: 'Artifact ID',
    },
    title: {
      type: 'string',
      description: 'Artifact title',
    },
    content: {
      type: 'string',
      description: 'Code artifact content',
    },
    language: {
      type: 'string',
      description: 'Code artifact language',
    },
    resultId: {
      type: 'string',
      description: 'Action result ID',
    },
    resultVersion: {
      type: 'number',
      description: 'Action result version',
    },
    canvasId: {
      type: 'string',
      description: 'Canvas ID to bind with',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
    },
  },
} as const;

export const ActionMessageTypeSchema = {
  type: 'string',
  description: 'Action message type',
  enum: ['ai', 'tool'],
} as const;

export const ActionMessageSchema = {
  type: 'object',
  description: 'Action message',
  required: ['messageId', 'type'],
  properties: {
    messageId: {
      type: 'string',
      description: 'Action message ID',
    },
    type: {
      $ref: '#/components/schemas/ActionMessageType',
      description: 'Action message type',
    },
    content: {
      type: 'string',
      description: 'Action message content',
    },
    reasoningContent: {
      type: 'string',
      description: 'Action message reasoning content',
    },
    toolCallMeta: {
      $ref: '#/components/schemas/ToolCallMeta',
      description: 'Action message tool call metadata',
    },
    toolCallId: {
      type: 'string',
      description: 'Action message tool call ID',
    },
    toolCallResult: {
      $ref: '#/components/schemas/ToolCallResult',
      description: 'Tool call result',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Action message creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Action message update time',
    },
  },
} as const;

export const ActionResultSchema = {
  type: 'object',
  description: 'Action result',
  required: ['resultId'],
  properties: {
    resultId: {
      type: 'string',
      readOnly: true,
      description: 'Action result ID',
      example: 'ar-g30e1b80b5g1itbemc0g5jj3',
    },
    version: {
      type: 'number',
      description: 'Action result version',
    },
    title: {
      type: 'string',
      description: 'Action result title',
      deprecated: true,
    },
    input: {
      description: 'Action input',
      $ref: '#/components/schemas/SkillInput',
    },
    tier: {
      description: 'Model tier',
      $ref: '#/components/schemas/ModelTier',
    },
    status: {
      type: 'string',
      description: 'Step status',
      $ref: '#/components/schemas/ActionStatus',
    },
    errorType: {
      type: 'string',
      description: 'Error type (defaults to systemError when omitted)',
      $ref: '#/components/schemas/ActionErrorType',
    },
    type: {
      description: 'Action type',
      $ref: '#/components/schemas/ActionType',
    },
    modelInfo: {
      description: 'Selected model',
      $ref: '#/components/schemas/ModelInfo',
    },
    actualProviderItemId: {
      type: 'string',
      description:
        'Actual provider item ID used for execution after routing (e.g. routed from Auto)',
    },
    isAutoModelRouted: {
      type: 'boolean',
      description: 'Whether the action execution was routed from the Auto model',
    },
    targetType: {
      description: 'Action target type',
      $ref: '#/components/schemas/EntityType',
    },
    targetId: {
      type: 'string',
      description: 'Action target ID',
    },
    actionMeta: {
      type: 'object',
      description: 'Action metadata',
      $ref: '#/components/schemas/ActionMeta',
    },
    context: {
      type: 'object',
      description: 'Action context',
      $ref: '#/components/schemas/SkillContext',
    },
    tplConfig: {
      type: 'object',
      description: 'Action template config',
      $ref: '#/components/schemas/SkillTemplateConfig',
      deprecated: true,
    },
    runtimeConfig: {
      type: 'object',
      description: 'Action runtime config',
      $ref: '#/components/schemas/SkillRuntimeConfig',
      deprecated: true,
    },
    history: {
      type: 'array',
      description: 'Action result history',
      items: {
        $ref: '#/components/schemas/ActionResult',
      },
    },
    steps: {
      type: 'array',
      description: 'Action steps',
      deprecated: true,
      items: {
        $ref: '#/components/schemas/ActionStep',
      },
    },
    messages: {
      type: 'array',
      description: 'Action messages',
      items: {
        $ref: '#/components/schemas/ActionMessage',
      },
    },
    errors: {
      type: 'array',
      description: 'Errors',
      items: {
        type: 'string',
      },
    },
    toolsets: {
      type: 'array',
      description: 'Action toolsets',
      items: {
        $ref: '#/components/schemas/GenericToolset',
      },
    },
    toolCalls: {
      type: 'array',
      description: 'Tool calls during action execution',
      items: {
        $ref: '#/components/schemas/ToolCallResult',
      },
    },
    files: {
      type: 'array',
      description: 'Files generated by the action',
      items: {
        $ref: '#/components/schemas/DriveFile',
      },
    },
    outputUrl: {
      type: 'string',
      format: 'uri',
      description: 'Media generation output URL (for media type actions)',
      example: 'https://example.com/generated/image_123.png',
    },
    storageKey: {
      type: 'string',
      description: 'Media generation output storage key',
    },
    pilotStepId: {
      type: 'string',
      description: 'Pilot step ID',
    },
    pilotSessionId: {
      type: 'string',
      description: 'Pilot session ID',
    },
    workflowExecutionId: {
      type: 'string',
      description: 'Workflow execution ID for workflow context',
    },
    workflowNodeExecutionId: {
      type: 'string',
      description: 'Workflow node execution ID for workflow context',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Message creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Message update time',
    },
  },
} as const;

export const IndexStatusSchema = {
  type: 'string',
  description: 'Resource index status',
  enum: ['init', 'wait_parse', 'wait_index', 'finish', 'parse_failed', 'index_failed'],
} as const;

export const SubscriptionIntervalSchema = {
  type: 'string',
  description: 'Payment recurring interval',
  enum: ['monthly', 'yearly'],
} as const;

export const SubscriptionPlanTypeSchema = {
  type: 'string',
  description: 'Subscription plan type',
  enum: ['free', 'starter', 'maker', 'enterprise', 'plus', 'pro'],
} as const;

export const SubscriptionStatusSchema = {
  type: 'string',
  description: 'Subscription status',
  enum: [
    'active',
    'canceled',
    'incomplete',
    'incomplete_expired',
    'past_due',
    'paused',
    'trialing',
    'unpaid',
  ],
} as const;

export const SubscriptionSchema = {
  type: 'object',
  required: ['subscriptionId', 'planType', 'status'],
  properties: {
    subscriptionId: {
      type: 'string',
      description: 'Subscription ID',
    },
    lookupKey: {
      type: 'string',
      description: 'Subscription lookup key',
    },
    planType: {
      type: 'string',
      description: 'Subscription plan type',
      $ref: '#/components/schemas/SubscriptionPlanType',
    },
    interval: {
      description: 'Payment recurring interval',
      $ref: '#/components/schemas/SubscriptionInterval',
    },
    status: {
      type: 'string',
      description: 'Subscription status',
      $ref: '#/components/schemas/SubscriptionStatus',
    },
    isTrial: {
      type: 'boolean',
      description: 'Whether the subscription is a trial',
    },
    cancelAt: {
      type: 'string',
      format: 'date-time',
      description: 'Subscription cancel time',
    },
  },
} as const;

export const TokenUsageMeterSchema = {
  type: 'object',
  required: [
    'meterId',
    'uid',
    'startAt',
    't1TokenQuota',
    't1TokenUsed',
    't2TokenQuota',
    't2TokenUsed',
  ],
  properties: {
    meterId: {
      type: 'string',
      description: 'Token usage meter ID',
    },
    uid: {
      type: 'string',
      description: 'User ID',
    },
    subscriptionId: {
      type: 'string',
      description: 'Subscription ID',
    },
    startAt: {
      type: 'string',
      format: 'date-time',
      description: 'Token usage meter start time',
    },
    endAt: {
      type: 'string',
      format: 'date-time',
      description: 'Token usage meter end time',
    },
    t1CountQuota: {
      type: 'number',
      description: 'Request count quota (T1)',
      example: 1000000,
    },
    t1CountUsed: {
      type: 'number',
      description: 'Request count used (T1)',
      example: 100000,
    },
    t1TokenQuota: {
      type: 'number',
      description: 'Token quota (T1)',
      example: 1000000,
      deprecated: true,
    },
    t1TokenUsed: {
      type: 'number',
      description: 'Token used (T1)',
      example: 100000,
      deprecated: true,
    },
    t2CountQuota: {
      type: 'number',
      description: 'Request count quota (T2)',
      example: 1000000,
    },
    t2CountUsed: {
      type: 'number',
      description: 'Request count used (T2)',
      example: 100000,
    },
    t2TokenQuota: {
      type: 'number',
      description: 'Token quota (T2)',
      example: 1000000,
      deprecated: true,
    },
    t2TokenUsed: {
      type: 'number',
      description: 'Token used (T2)',
      example: 100000,
      deprecated: true,
    },
  },
} as const;

export const StorageUsageMeterSchema = {
  type: 'object',
  required: [
    'meterId',
    'uid',
    'objectStorageQuota',
    'resourceSize',
    'canvasSize',
    'fileSize',
    'vectorStorageQuota',
    'vectorStorageUsed',
  ],
  properties: {
    meterId: {
      type: 'string',
      description: 'Storage usage meter ID',
    },
    uid: {
      type: 'string',
      description: 'User ID',
    },
    subscriptionId: {
      type: 'string',
      description: 'Subscription ID',
    },
    fileCountUsed: {
      type: 'number',
      description: 'File count used',
      example: 100,
    },
    fileCountQuota: {
      type: 'number',
      description: 'File count quota',
      example: 1000,
    },
    objectStorageQuota: {
      type: 'string',
      description: 'Object storage quota (in bytes), including resource, canvas and static files',
      example: '104857600',
      deprecated: true,
    },
    resourceSize: {
      type: 'string',
      description: 'Resource storage size in use (in bytes)',
      example: '1048576',
      deprecated: true,
    },
    canvasSize: {
      type: 'string',
      description: 'Canvas storage size in use (in bytes)',
      example: '1048576',
      deprecated: true,
    },
    fileSize: {
      type: 'string',
      description: 'Static file storage size in use (in bytes)',
      example: '1048576',
      deprecated: true,
    },
    vectorStorageQuota: {
      type: 'string',
      description: 'Vector storage quota (in bytes)',
      example: '1048576',
      deprecated: true,
    },
    vectorStorageUsed: {
      type: 'string',
      description: 'Vector storage size used (in bytes)',
      example: '1048576',
      deprecated: true,
    },
  },
} as const;

export const FileParsingMeterSchema = {
  type: 'object',
  required: ['pagesParsed', 'pagesLimit'],
  properties: {
    pagesParsed: {
      type: 'number',
      description: 'File pages parsed',
    },
    pagesLimit: {
      type: 'number',
      description: 'File pages limit',
    },
    fileUploadLimit: {
      type: 'number',
      description: 'File upload limit (in MB)',
    },
  },
} as const;

export const OperationModeSchema = {
  type: 'string',
  description: 'Operation mode',
  enum: ['mouse', 'touchpad'],
} as const;

export const ProviderConfigSchema = {
  type: 'object',
  description: 'Provider config',
  properties: {
    providerId: {
      type: 'string',
      description: 'Provider ID',
    },
    providerKey: {
      type: 'string',
      description: 'Provider key',
    },
  },
} as const;

export const ModelSceneSchema = {
  type: 'string',
  description: 'Model usage scene',
  enum: ['chat', 'copilot', 'agent', 'queryAnalysis', 'titleGeneration', 'image', 'video', 'audio'],
} as const;

export const DefaultModelConfigSchema = {
  type: 'object',
  description: 'Default model config',
  properties: {
    chat: {
      description: 'Default chat model to use',
      $ref: '#/components/schemas/ProviderItem',
    },
    copilot: {
      description: 'Default copilot model to use',
      $ref: '#/components/schemas/ProviderItem',
    },
    agent: {
      description: 'Default agent model to use',
      $ref: '#/components/schemas/ProviderItem',
    },
    queryAnalysis: {
      description: 'Query analysis and context processing model',
      $ref: '#/components/schemas/ProviderItem',
    },
    titleGeneration: {
      description: 'Title generation model for canvas and documents',
      $ref: '#/components/schemas/ProviderItem',
    },
    image: {
      description: 'Default image generation model',
      $ref: '#/components/schemas/ProviderItem',
    },
    video: {
      description: 'Default video generation model',
      $ref: '#/components/schemas/ProviderItem',
    },
    audio: {
      description: 'Default audio generation model',
      $ref: '#/components/schemas/ProviderItem',
    },
  },
} as const;

export const ProviderModeSchema = {
  type: 'string',
  description: 'Provider mode',
  enum: ['global', 'custom'],
} as const;

export const UserPreferencesSchema = {
  type: 'object',
  description: 'User preferences',
  properties: {
    operationMode: {
      description: 'Operation mode',
      $ref: '#/components/schemas/OperationMode',
    },
    providerMode: {
      description: 'Provider mode',
      $ref: '#/components/schemas/ProviderMode',
    },
    disableHoverCard: {
      type: 'boolean',
      description: 'Whether to disable hover tutorial',
      default: false,
    },
    hasBeenInvited: {
      type: 'boolean',
      description: 'Whether the user has been invited',
      default: false,
    },
    requireInvitationCode: {
      type: 'boolean',
      description: 'Whether to require invitation code',
    },
    webSearch: {
      description: 'Web search config',
      $ref: '#/components/schemas/ProviderConfig',
    },
    urlParsing: {
      description: 'URL parsing config',
      $ref: '#/components/schemas/ProviderConfig',
    },
    pdfParsing: {
      description: 'PDF parsing config',
      $ref: '#/components/schemas/ProviderConfig',
    },
    defaultModel: {
      description: 'Default model config',
      $ref: '#/components/schemas/DefaultModelConfig',
    },
  },
} as const;

export const OnboardingStatusSchema = {
  type: 'string',
  description: 'Onboarding status',
  enum: ['not_started', 'skipped', 'completed'],
} as const;

export const OnboardingConfigSchema = {
  type: 'object',
  properties: {
    settings: {
      description: 'Settings onboarding status',
      $ref: '#/components/schemas/OnboardingStatus',
    },
    tour: {
      description: 'Tour onboarding status',
      $ref: '#/components/schemas/OnboardingStatus',
    },
  },
} as const;

export const UserSettingsSchema = {
  type: 'object',
  required: ['uid', 'avatar', 'name', 'email'],
  properties: {
    uid: {
      type: 'string',
      description: 'User ID',
      example: 'u-g30e1b80b5g1itbemc0g5jj3',
    },
    avatar: {
      type: 'string',
      description: 'User avatar',
      example: 'https://static.refly.ai/avatar/1.jpg',
    },
    name: {
      type: 'string',
      description: 'Username (can only contains letters, numbers, and underscores)',
      example: 'john_doe',
    },
    nickname: {
      type: 'string',
      description: 'User nickname',
      example: 'John Doe',
    },
    email: {
      type: 'string',
      description: 'User email',
      example: '6XJpZ@example.com',
    },
    emailVerified: {
      type: 'boolean',
      description: 'Whether email is verified',
      default: false,
    },
    uiLocale: {
      type: 'string',
      description: 'User UI locale',
      example: 'en',
    },
    outputLocale: {
      type: 'string',
      description: 'User output locale',
      example: 'en',
    },
    customerId: {
      type: 'string',
      description: 'Stripe customer ID',
    },
    subscription: {
      description: 'User subscription',
      $ref: '#/components/schemas/Subscription',
    },
    hasBetaAccess: {
      type: 'boolean',
      description: 'Whether the user has beta access',
      default: false,
    },
    preferences: {
      description: 'User preferences',
      $ref: '#/components/schemas/UserPreferences',
    },
    onboarding: {
      description: 'Onboarding config',
      $ref: '#/components/schemas/OnboardingConfig',
    },
  },
} as const;

export const AuthProviderSchema = {
  type: 'string',
  description: 'Auth provider',
  enum: ['email', 'google', 'github', 'invitation'],
} as const;

export const AuthConfigItemSchema = {
  type: 'object',
  required: ['provider'],
  properties: {
    provider: {
      description: 'Auth provider',
      $ref: '#/components/schemas/AuthProvider',
    },
  },
} as const;

export const AuthConfigResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Auth providers',
          items: {
            $ref: '#/components/schemas/AuthConfigItem',
          },
        },
      },
    },
  ],
} as const;

export const EmailSignupRequestSchema = {
  type: 'object',
  description: 'Email signup request',
  required: ['email', 'password'],
  properties: {
    email: {
      type: 'string',
      description: 'Email',
    },
    password: {
      type: 'string',
      description: 'Password',
    },
  },
} as const;

export const EmailSignupDataSchema = {
  type: 'object',
  properties: {
    sessionId: {
      type: 'string',
      description: 'Verification session ID',
    },
    skipVerification: {
      type: 'boolean',
      description: 'Whether email verification is skipped',
    },
  },
} as const;

export const EmailSignupResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/EmailSignupData',
        },
      },
    },
  ],
} as const;

export const VerificationPurposeSchema = {
  type: 'string',
  description: 'Verification purpose',
  enum: ['signup', 'resetPassword'],
} as const;

export const CreateVerificationRequestSchema = {
  type: 'object',
  description: 'Create verification session request',
  required: ['email', 'purpose'],
  properties: {
    email: {
      type: 'string',
      description: 'Email',
    },
    purpose: {
      type: 'string',
      description: 'Verification purpose',
      $ref: '#/components/schemas/VerificationPurpose',
    },
    password: {
      type: 'string',
      description: 'Password',
    },
  },
} as const;

export const CreateVerificationDataSchema = {
  type: 'object',
  properties: {
    sessionId: {
      type: 'string',
      description: 'Verification session ID',
    },
  },
} as const;

export const CreateVerificationResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/CreateVerificationData',
        },
      },
    },
  ],
} as const;

export const ResendVerificationRequestSchema = {
  type: 'object',
  description: 'Resend verification request',
  required: ['sessionId'],
  properties: {
    sessionId: {
      type: 'string',
      description: 'Verification session ID',
    },
  },
} as const;

export const CheckVerificationRequestSchema = {
  type: 'object',
  description: 'Check verification code request',
  required: ['sessionId', 'code'],
  properties: {
    sessionId: {
      type: 'string',
      description: 'Verification session ID',
    },
    code: {
      type: 'string',
      description: 'Verification code',
    },
  },
} as const;

export const EmailLoginRequestSchema = {
  type: 'object',
  description: 'Email login request',
  required: ['email', 'password'],
  properties: {
    email: {
      type: 'string',
      description: 'Email',
    },
    password: {
      type: 'string',
      description: 'Password',
    },
  },
} as const;

export const EmailLoginDataSchema = {
  type: 'object',
  properties: {
    accessToken: {
      type: 'string',
      description: 'Access token',
    },
  },
} as const;

export const EmailLoginResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/EmailLoginData',
        },
      },
    },
  ],
} as const;

export const GetUserSettingsResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/UserSettings',
        },
      },
    },
  ],
} as const;

export const CollabTokenDataSchema = {
  type: 'object',
  required: ['token'],
  properties: {
    token: {
      type: 'string',
      description: 'Collab token',
    },
    expiresAt: {
      type: 'number',
      description: 'Token expiration time (in unix milliseconds)',
    },
  },
} as const;

export const GetCollabTokenResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/CollabTokenData',
        },
      },
    },
  ],
} as const;

export const BaseResponseSchema = {
  type: 'object',
  required: ['success'],
  properties: {
    success: {
      type: 'boolean',
      description: 'Whether the operation was successful',
      example: true,
    },
    errCode: {
      type: 'string',
      description: 'Error code',
    },
    errMsg: {
      type: 'string',
      description: 'Error message',
      example: 'Operation failed',
    },
    traceId: {
      type: 'string',
      description: 'Trace ID',
    },
    stack: {
      type: 'string',
      description: 'Error stack (only returned in development environment)',
    },
  },
} as const;

export const ErrorDetailSchema = {
  type: 'object',
  required: ['code', 'message'],
  properties: {
    code: {
      type: 'string',
      description: 'Error code identifier',
      example: 'TTS_FAILED',
    },
    message: {
      type: 'string',
      description: 'Human-readable error message',
      example: 'Failed to generate speech after 3 attempts',
    },
  },
} as const;

export const BaseResponseV2Schema = {
  type: 'object',
  required: ['status'],
  properties: {
    status: {
      type: 'string',
      description: 'Response status',
      enum: ['success', 'failed'],
      example: 'success',
    },
    data: {
      description: 'Response data (generic object, present when status is success)',
      type: 'object',
      additionalProperties: true,
    },
    errors: {
      type: 'array',
      description: 'Array of error objects (present when status is error)',
      items: {
        $ref: '#/components/schemas/ErrorDetail',
      },
    },
  },
} as const;

export const ListCanvasResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Canvas list',
          items: {
            $ref: '#/components/schemas/Canvas',
          },
        },
      },
    },
  ],
} as const;

export const GetCanvasDetailResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/Canvas',
        },
      },
    },
  ],
} as const;

export const CanvasHistoryVersionSchema = {
  type: 'object',
  required: ['version', 'hash', 'timestamp'],
  properties: {
    version: {
      type: 'string',
      description: 'Canvas version',
    },
    hash: {
      type: 'string',
      description: 'Canvas hash',
    },
    timestamp: {
      type: 'number',
      description: 'Canvas timestamp (in unix milliseconds)',
    },
  },
} as const;

export const CanvasDataSchema = {
  type: 'object',
  description: 'Canvas data',
  required: ['nodes', 'edges'],
  properties: {
    nodes: {
      type: 'array',
      description: 'Canvas nodes',
      items: {
        $ref: '#/components/schemas/CanvasNode',
      },
    },
    edges: {
      type: 'array',
      description: 'Canvas edges',
      items: {
        $ref: '#/components/schemas/CanvasEdge',
      },
    },
  },
} as const;

export const CanvasStateSchema = {
  type: 'object',
  description: 'Canvas state',
  allOf: [
    {
      $ref: '#/components/schemas/CanvasData',
    },
    {
      type: 'object',
      properties: {
        version: {
          type: 'string',
          description: 'Canvas version',
        },
        hash: {
          type: 'string',
          description: 'Canvas state hash (sha256), calculated from nodes and edges',
        },
        transactions: {
          type: 'array',
          description: 'Canvas transaction list',
          items: {
            $ref: '#/components/schemas/CanvasTransaction',
          },
        },
        history: {
          type: 'array',
          description: 'Canvas history versions',
          items: {
            $ref: '#/components/schemas/CanvasHistoryVersion',
          },
        },
        createdAt: {
          type: 'number',
          description: 'Canvas creation timestamp (in unix milliseconds)',
        },
        updatedAt: {
          type: 'number',
          description: 'Canvas last updated timestamp (in unix milliseconds)',
        },
      },
    },
  ],
} as const;

export const RawCanvasDataSchema = {
  type: 'object',
  description: 'Raw canvas data',
  allOf: [
    {
      $ref: '#/components/schemas/CanvasData',
    },
    {
      type: 'object',
      properties: {
        canvasId: {
          type: 'string',
          description: 'Canvas ID',
        },
        title: {
          type: 'string',
          description: 'Canvas title',
        },
        owner: {
          type: 'object',
          description: 'Canvas owner',
          $ref: '#/components/schemas/ShareUser',
        },
        minimapUrl: {
          type: 'string',
          description: 'Minimap URL',
        },
        variables: {
          type: 'array',
          description: 'Workflow variables',
          items: {
            $ref: '#/components/schemas/WorkflowVariable',
          },
        },
      },
    },
  ],
} as const;

export const GetCanvasDataResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/RawCanvasData',
        },
      },
    },
  ],
} as const;

export const SharedCanvasDataSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/RawCanvasData',
    },
    {
      type: 'object',
      properties: {
        resources: {
          type: 'array',
          description: 'Resources in the canvas',
          deprecated: true,
          items: {
            $ref: '#/components/schemas/Resource',
          },
        },
        files: {
          type: 'array',
          description: 'Drive files in the canvas',
          items: {
            $ref: '#/components/schemas/DriveFile',
          },
        },
      },
    },
  ],
} as const;

export const ExportCanvasResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          properties: {
            downloadUrl: {
              type: 'string',
              description: 'Download URL for the canvas data',
            },
          },
        },
      },
    },
  ],
} as const;

export const ImportCanvasRequestSchema = {
  type: 'object',
  required: ['file'],
  properties: {
    file: {
      type: 'string',
      format: 'binary',
      description: 'File to import',
    },
    canvasId: {
      type: 'string',
      description: 'Canvas ID to specify',
    },
  },
} as const;

export const DuplicateCanvasRequestSchema = {
  type: 'object',
  required: ['canvasId'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID to duplicate',
    },
    title: {
      type: 'string',
      description: 'Custom canvas title',
    },
    projectId: {
      type: 'string',
      description: 'Project ID to bind with',
    },
    duplicateEntities: {
      type: 'boolean',
      description: 'Whether to duplicate entities within the canvas',
    },
  },
} as const;

export const DuplicateDocumentRequestSchema = {
  type: 'object',
  required: ['docId'],
  properties: {
    docId: {
      type: 'string',
      description: 'Document ID to duplicate',
    },
    title: {
      type: 'string',
      description: 'Custom document title for the duplicate',
    },
    canvasId: {
      type: 'string',
      description: 'Target canvas ID',
    },
  },
} as const;

export const DuplicateResourceRequestSchema = {
  type: 'object',
  required: ['resourceId'],
  properties: {
    resourceId: {
      type: 'string',
      description: 'Resource ID to duplicate',
    },
    title: {
      type: 'string',
      description: 'Custom resource title for the duplicate',
    },
    canvasId: {
      type: 'string',
      description: 'Target canvas ID',
    },
  },
} as const;

export const UpsertCanvasRequestSchema = {
  type: 'object',
  properties: {
    title: {
      type: 'string',
      description: 'Canvas title',
      example: 'My Canvas',
    },
    canvasId: {
      type: 'string',
      description: 'Canvas ID (only used for update)',
      example: 'c-g30e1b80b5g1itbemc0g5jj3',
    },
    projectId: {
      type: 'string',
      description: 'Project ID to bind with',
    },
    minimapStorageKey: {
      type: 'string',
      description: 'Minimap storage key',
    },
    variables: {
      type: 'array',
      description: 'Workflow variables',
      items: {
        $ref: '#/components/schemas/WorkflowVariable',
      },
    },
    visibility: {
      type: 'boolean',
      description: 'Whether this canvas is visible in lists',
      default: true,
    },
  },
} as const;

export const UpsertCanvasResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/Canvas',
        },
      },
    },
  ],
} as const;

export const DeleteCanvasRequestSchema = {
  type: 'object',
  required: ['canvasId'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID to delete',
      example: 'c-g30e1b80b5g1itbemc0g5jj3',
    },
    deleteAllFiles: {
      type: 'boolean',
      description: 'Whether to delete all files in the canvas',
      default: false,
    },
  },
} as const;

export const AutoNameCanvasRequestSchema = {
  type: 'object',
  required: ['canvasId'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID',
    },
    directUpdate: {
      type: 'boolean',
      description: 'Whether to directly update the canvas title',
      default: false,
    },
  },
} as const;

export const AutoNameCanvasResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Auto name canvas result',
          properties: {
            title: {
              type: 'string',
              description: 'New canvas title',
            },
          },
        },
      },
    },
  ],
} as const;

export const GetCanvasStateResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/CanvasState',
        },
      },
    },
  ],
} as const;

export const SetCanvasStateRequestSchema = {
  type: 'object',
  required: ['canvasId', 'state'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID',
    },
    state: {
      type: 'object',
      description: 'Canvas state to set',
      $ref: '#/components/schemas/CanvasState',
    },
  },
} as const;

export const GetCanvasTransactionsResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Canvas diff list',
          items: {
            $ref: '#/components/schemas/CanvasTransaction',
          },
        },
      },
    },
  ],
} as const;

export const DiffTypeSchema = {
  type: 'string',
  description: 'Diff type',
  enum: ['add', 'update', 'delete'],
} as const;

export const NodeDiffSchema = {
  type: 'object',
  required: ['id', 'type'],
  properties: {
    id: {
      type: 'string',
      description: 'Node ID',
    },
    type: {
      type: 'string',
      description: 'Node diff type',
      $ref: '#/components/schemas/DiffType',
    },
    from: {
      type: 'object',
      description: 'Node diff from (only the fields that are different will be included)',
      additionalProperties: true,
    },
    to: {
      type: 'object',
      description: 'Node diff to (only the fields that are different will be included)',
      additionalProperties: true,
    },
  },
} as const;

export const EdgeDiffSchema = {
  type: 'object',
  required: ['id', 'type'],
  properties: {
    id: {
      type: 'string',
      description: 'Edge ID',
    },
    type: {
      type: 'string',
      description: 'Edge diff type',
      $ref: '#/components/schemas/DiffType',
    },
    from: {
      type: 'object',
      description: 'Edge diff from',
      $ref: '#/components/schemas/CanvasEdge',
    },
    to: {
      type: 'object',
      description: 'Edge diff to',
      $ref: '#/components/schemas/CanvasEdge',
    },
  },
} as const;

export const CanvasTransactionSourceSchema = {
  type: 'object',
  description: 'Canvas transaction source',
  required: ['type'],
  properties: {
    type: {
      type: 'string',
      description: 'Source type',
      enum: ['user', 'system'],
    },
    uid: {
      type: 'string',
      description: 'Source user ID',
    },
  },
} as const;

export const CanvasTransactionSchema = {
  type: 'object',
  required: ['txId', 'nodeDiffs', 'edgeDiffs', 'createdAt'],
  properties: {
    txId: {
      type: 'string',
      description: 'Transaction ID',
    },
    nodeDiffs: {
      type: 'array',
      description: 'Node diffs',
      items: {
        $ref: '#/components/schemas/NodeDiff',
      },
    },
    edgeDiffs: {
      type: 'array',
      description: 'Edge diffs',
      items: {
        $ref: '#/components/schemas/EdgeDiff',
      },
    },
    revoked: {
      type: 'boolean',
      description: 'Whether the transaction is revoked',
    },
    source: {
      type: 'object',
      description: 'Transaction source',
      $ref: '#/components/schemas/CanvasTransactionSource',
    },
    deleted: {
      type: 'boolean',
      description: 'Whether the transaction is deleted',
    },
    createdAt: {
      type: 'number',
      description: 'Transaction creation timestamp (in unix milliseconds)',
    },
    syncedAt: {
      type: 'number',
      description: 'Transaction synchronization timestamp (in unix milliseconds)',
    },
  },
} as const;

export const SyncCanvasStateRequestSchema = {
  type: 'object',
  required: ['canvasId', 'transactions'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID',
    },
    version: {
      type: 'string',
      description: 'Canvas state version',
    },
    transactions: {
      type: 'array',
      description: 'Transaction list',
      items: {
        $ref: '#/components/schemas/CanvasTransaction',
      },
    },
  },
} as const;

export const SyncCanvasStateResultSchema = {
  type: 'object',
  required: ['transactions'],
  properties: {
    transactions: {
      type: 'array',
      description: 'Transaction list',
      items: {
        $ref: '#/components/schemas/CanvasTransaction',
      },
    },
  },
} as const;

export const SyncCanvasStateResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Apply canvas state result',
          $ref: '#/components/schemas/SyncCanvasStateResult',
        },
      },
    },
  ],
} as const;

export const CreateCanvasVersionRequestSchema = {
  type: 'object',
  required: ['canvasId', 'state'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID',
    },
    state: {
      type: 'object',
      description: 'Canvas state',
      $ref: '#/components/schemas/CanvasState',
    },
  },
} as const;

export const VersionConflictSchema = {
  type: 'object',
  required: ['localState', 'remoteState'],
  properties: {
    localState: {
      type: 'object',
      description: 'Local canvas state',
      $ref: '#/components/schemas/CanvasState',
    },
    remoteState: {
      type: 'object',
      description: 'Server canvas state',
      $ref: '#/components/schemas/CanvasState',
    },
  },
} as const;

export const CreateCanvasVersionResultSchema = {
  type: 'object',
  required: ['canvasId'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID',
    },
    conflict: {
      type: 'object',
      description: 'Version conflict (when there is a conflict)',
      $ref: '#/components/schemas/VersionConflict',
    },
    newState: {
      type: 'object',
      description: 'New canvas state (when there is no conflict)',
      $ref: '#/components/schemas/CanvasState',
    },
  },
} as const;

export const CreateCanvasVersionResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Create canvas version result',
          $ref: '#/components/schemas/CreateCanvasVersionResult',
        },
      },
    },
  ],
} as const;

export const ListCanvasTemplateResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Canvas template list',
          items: {
            $ref: '#/components/schemas/CanvasTemplate',
          },
        },
      },
    },
  ],
} as const;

export const CreateCanvasTemplateRequestSchema = {
  type: 'object',
  required: ['canvasId', 'title', 'description', 'language'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID',
    },
    title: {
      type: 'string',
      description: 'Canvas template title',
    },
    description: {
      type: 'string',
      description: 'Canvas template description',
    },
    categoryId: {
      type: 'string',
      description: 'Canvas template category ID',
    },
    language: {
      type: 'string',
      description: 'Canvas template language code',
    },
    coverStorageKey: {
      type: 'string',
      description: 'Cover storage key',
    },
  },
} as const;

export const UpdateCanvasTemplateRequestSchema = {
  type: 'object',
  required: ['templateId'],
  properties: {
    templateId: {
      type: 'string',
      description: 'Canvas template ID',
    },
    title: {
      type: 'string',
      description: 'Canvas template title',
    },
    description: {
      type: 'string',
      description: 'Canvas template description',
    },
    categoryId: {
      type: 'string',
      description: 'Canvas template category ID',
    },
    language: {
      type: 'string',
      description: 'Canvas template language code',
    },
  },
} as const;

export const UpsertCanvasTemplateResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          description: 'Canvas template',
          $ref: '#/components/schemas/CanvasTemplate',
        },
      },
    },
  ],
} as const;

export const ListCanvasTemplateCategoryResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Canvas template category list',
          items: {
            $ref: '#/components/schemas/CanvasTemplateCategory',
          },
        },
      },
    },
  ],
} as const;

export const UpsertResourceRequestSchema = {
  type: 'object',
  required: ['title', 'resourceType'],
  properties: {
    title: {
      type: 'string',
      description: 'Resource title',
      example: 'My Resource',
    },
    resourceType: {
      description: 'Resource type',
      $ref: '#/components/schemas/ResourceType',
    },
    resourceId: {
      type: 'string',
      description: 'Resource ID (only used for update)',
      example: 'r-g30e1b80b5g1itbemc0g5jj3',
    },
    projectId: {
      type: 'string',
      description: 'Project ID to bind with',
    },
    canvasId: {
      type: 'string',
      description: 'Canvas ID to bind with',
    },
    data: {
      description: 'Resource metadata',
      $ref: '#/components/schemas/ResourceMeta',
    },
    storageKey: {
      type: 'string',
      description: 'Storage key',
    },
    content: {
      type: 'string',
      description: 'Resource content (this will be ignored if storageKey was set)',
    },
  },
} as const;

export const UpsertResourceResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/Resource',
        },
      },
    },
  ],
} as const;

export const BatchCreateResourceResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Resource list',
          items: {
            $ref: '#/components/schemas/Resource',
          },
        },
      },
    },
  ],
} as const;

export const ReindexResourceRequestSchema = {
  type: 'object',
  required: ['resourceIds'],
  properties: {
    resourceIds: {
      type: 'array',
      description: 'Resource ID list',
      items: {
        type: 'string',
      },
    },
  },
} as const;

export const ReindexResourceResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Resource list',
          items: {
            $ref: '#/components/schemas/Resource',
          },
        },
      },
    },
  ],
} as const;

export const DeleteResourceRequestSchema = {
  type: 'object',
  required: ['resourceId'],
  properties: {
    resourceId: {
      type: 'string',
      description: 'Resource ID to delete',
      example: 'r-g30e1b80b5g1itbemc0g5jj3',
    },
  },
} as const;

export const ListResourceResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Resource list',
          items: {
            $ref: '#/components/schemas/Resource',
          },
        },
      },
    },
  ],
} as const;

export const GetResourceDetailResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Resource data',
          $ref: '#/components/schemas/Resource',
        },
      },
    },
  ],
} as const;

export const ListDocumentResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Canvas list',
          items: {
            $ref: '#/components/schemas/Document',
          },
        },
      },
    },
  ],
} as const;

export const GetDocumentDetailResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Document data',
          $ref: '#/components/schemas/Document',
        },
      },
    },
  ],
} as const;

export const UpsertDocumentRequestSchema = {
  type: 'object',
  properties: {
    title: {
      type: 'string',
      description: 'Canvas title',
      example: 'My Canvas',
    },
    docId: {
      type: 'string',
      description: 'Document ID (only used for update)',
      example: 'd-g30e1b80b5g1itbemc0g5jj3',
    },
    projectId: {
      type: 'string',
      description: 'Project ID to bind with',
    },
    canvasId: {
      type: 'string',
      description: 'Canvas ID to bind with',
    },
    readOnly: {
      type: 'boolean',
      description: 'Whether this document is read-only',
      default: false,
    },
    initialContent: {
      type: 'string',
      description: 'Document initial content',
    },
    resultId: {
      type: 'string',
      description: 'Action result ID to bind with',
    },
  },
} as const;

export const UpsertDocumentResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/Document',
        },
      },
    },
  ],
} as const;

export const DeleteDocumentRequestSchema = {
  type: 'object',
  required: ['docId'],
  properties: {
    docId: {
      type: 'string',
      description: 'Document ID to delete',
      example: 'd-g30e1b80b5g1itbemc0g5jj3',
    },
  },
} as const;

export const GetActionResultResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/ActionResult',
        },
      },
    },
  ],
} as const;

export const AbortActionRequestSchema = {
  type: 'object',
  required: ['resultId'],
  properties: {
    resultId: {
      type: 'string',
      description: 'Action result ID',
    },
    version: {
      type: 'integer',
      description: 'Action result version',
    },
  },
} as const;

export const ListProjectResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Project list',
          items: {
            $ref: '#/components/schemas/Project',
          },
        },
      },
    },
  ],
} as const;

export const GetProjectDetailResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/Project',
        },
      },
    },
  ],
} as const;

export const UpsertProjectRequestSchema = {
  type: 'object',
  properties: {
    projectId: {
      type: 'string',
      description: 'Project ID (only used for update)',
    },
    name: {
      type: 'string',
      description: 'Project name',
    },
    description: {
      type: 'string',
      description: 'Project description',
    },
    coverStorageKey: {
      type: 'string',
      description: 'Project cover storage key',
    },
    customInstructions: {
      type: 'string',
      description: 'Custom instructions',
    },
  },
} as const;

export const UpsertProjectResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/Project',
        },
      },
    },
  ],
} as const;

export const UpdateProjectItemsRequestSchema = {
  type: 'object',
  properties: {
    projectId: {
      type: 'string',
      description: 'Project ID',
    },
    operation: {
      type: 'string',
      description: 'Operation type',
      enum: ['add', 'remove'],
    },
    items: {
      type: 'array',
      description: 'Item list',
      items: {
        $ref: '#/components/schemas/Entity',
      },
    },
  },
} as const;

export const DeleteProjectRequestSchema = {
  type: 'object',
  required: ['projectId'],
  properties: {
    projectId: {
      type: 'string',
      description: 'Project ID to delete',
      example: 'p-g30e1b80b5g1itbemc0g5jj3',
    },
  },
} as const;

export const DeleteProjectItemsRequestSchema = {
  type: 'object',
  required: ['projectId', 'items'],
  properties: {
    projectId: {
      type: 'string',
      description: 'Project ID',
    },
    items: {
      type: 'array',
      description: 'Item list',
      items: {
        $ref: '#/components/schemas/Entity',
      },
    },
  },
} as const;

export const SkillEventTypeSchema = {
  type: 'string',
  description: 'Skill event type',
  enum: [
    'start',
    'end',
    'stream',
    'log',
    'artifact',
    'structured_data',
    'token_usage',
    'create_node',
    'tool_call_start',
    'tool_call_end',
    'tool_call_error',
    'tool_call_stream',
    'error',
  ],
} as const;

export const SkillEventSchema = {
  type: 'object',
  required: ['event', 'resultId'],
  properties: {
    event: {
      description: 'Event type',
      $ref: '#/components/schemas/SkillEventType',
    },
    skillMeta: {
      description: 'Skill metadata',
      $ref: '#/components/schemas/SkillMeta',
    },
    step: {
      description: 'Action step metadata',
      $ref: '#/components/schemas/ActionStepMeta',
      deprecated: true,
    },
    resultId: {
      type: 'string',
      description: 'Result ID',
    },
    version: {
      type: 'number',
      description: 'Result version',
    },
    messageId: {
      type: 'string',
      description: 'Message ID',
    },
    content: {
      type: 'string',
      description: 'Event content. Only present when `event` is `stream`',
    },
    reasoningContent: {
      type: 'string',
      description: 'Reasoning content. Only present when `event` is `stream`',
    },
    tokenUsage: {
      description: 'Token usage data. Only present when `event` is `token_usage`.',
      $ref: '#/components/schemas/TokenUsageItem',
    },
    log: {
      description: 'Log data. Only present when `event` is `log`.',
      $ref: '#/components/schemas/ActionLog',
    },
    structuredData: {
      type: 'object',
      description: 'Structured data. Only present when `event` is `structured_data`.',
    },
    artifact: {
      description: 'Artifact data. Only present when `event` is `artifact`.',
      $ref: '#/components/schemas/Artifact',
    },
    node: {
      description: 'Canvas node data. Only present when `event` is `create_node`.',
      $ref: '#/components/schemas/CanvasNode',
    },
    error: {
      description: 'Error data. Only present when `event` is `error`.',
      $ref: '#/components/schemas/BaseResponse',
    },
    originError: {
      type: 'string',
      description: 'Original error message. Only present when `event` is `error`.',
    },
    toolCallMeta: {
      description:
        'Tool call metadata. Only present when `event` is `tool_call_start`, `tool_call_end`, or `tool_call_error`.',
      $ref: '#/components/schemas/ToolCallMeta',
    },
    toolCallResult: {
      description: 'Tool call result data.',
      $ref: '#/components/schemas/ToolCallResult',
    },
  },
} as const;

export const ToolCallStatusSchema = {
  type: 'string',
  description: 'Tool call status',
  enum: ['executing', 'completed', 'failed'],
} as const;

export const ToolCallMetaSchema = {
  type: 'object',
  properties: {
    toolName: {
      type: 'string',
      description: 'Tool name',
    },
    toolsetId: {
      type: 'string',
      description: 'Toolset ID',
    },
    toolsetKey: {
      type: 'string',
      description: 'Toolset key',
    },
    toolCallId: {
      type: 'string',
      description: 'Tool call ID',
    },
    status: {
      $ref: '#/components/schemas/ToolCallStatus',
      description: 'Tool call status',
    },
    startTs: {
      type: 'number',
      description: 'Tool call start timestamp (milliseconds)',
    },
    endTs: {
      type: 'number',
      description: 'Tool call end timestamp (milliseconds)',
    },
    error: {
      type: 'string',
      description: 'Tool call error',
    },
  },
} as const;

export const ToolCallResultSchema = {
  type: 'object',
  required: ['callId', 'status', 'createdAt', 'updatedAt'],
  properties: {
    callId: {
      type: 'string',
      description: 'Tool call ID (run_id from LangChain)',
    },
    uid: {
      type: 'string',
      description: 'User ID',
    },
    toolsetId: {
      type: 'string',
      description: 'Toolset ID (toolsetKey)',
    },
    toolName: {
      type: 'string',
      description: 'Tool name',
    },
    stepName: {
      type: 'string',
      description: 'Step name (the action step in which this tool was called)',
    },
    input: {
      oneOf: [
        {
          type: 'object',
        },
        {
          type: 'string',
        },
      ],
      description: 'Tool input arguments',
    },
    output: {
      oneOf: [
        {
          type: 'object',
        },
        {
          type: 'string',
        },
      ],
      description: 'Tool output result',
    },
    error: {
      type: 'string',
      description: 'Error message if tool execution failed',
    },
    status: {
      description: 'Tool call status',
      $ref: '#/components/schemas/ToolCallStatus',
    },
    createdAt: {
      type: 'number',
      description: 'Tool call start timestamp (milliseconds)',
    },
    updatedAt: {
      type: 'number',
      description: 'Tool call last update timestamp (milliseconds)',
    },
    deletedAt: {
      type: 'number',
      description: 'Tool call deletion timestamp (milliseconds)',
    },
  },
} as const;

export const ShareRecordSchema = {
  type: 'object',
  required: ['shareId', 'entityType', 'entityId'],
  properties: {
    shareId: {
      type: 'string',
      description: 'Share ID',
    },
    title: {
      type: 'string',
      description: 'Share title',
    },
    entityType: {
      $ref: '#/components/schemas/EntityType',
      description: 'Entity type',
    },
    entityId: {
      type: 'string',
      description: 'Entity ID',
    },
    allowDuplication: {
      type: 'boolean',
      description: 'Whether to allow duplication of the shared entity',
    },
    parentShareId: {
      type: 'string',
      description: 'Parent share ID',
    },
    templateId: {
      type: 'string',
      description: 'Canvas template ID',
    },
    createdAt: {
      type: 'string',
      description: 'Create timestamp',
    },
    updatedAt: {
      type: 'string',
      description: 'Update timestamp',
    },
  },
} as const;

export const UpsertCodeArtifactRequestSchema = {
  type: 'object',
  properties: {
    artifactId: {
      type: 'string',
      description: 'Code artifact ID (not needed for creation)',
    },
    title: {
      type: 'string',
      description: 'Code artifact title',
    },
    type: {
      type: 'string',
      description: 'Code artifact type',
    },
    content: {
      type: 'string',
      description: 'Code artifact content',
    },
    language: {
      type: 'string',
      description: 'Code artifact language',
    },
    resultId: {
      type: 'string',
      description: 'Action result ID',
    },
    resultVersion: {
      type: 'number',
      description: 'Action result version',
    },
    canvasId: {
      type: 'string',
      description: 'Canvas ID to bind with',
    },
    previewStorageKey: {
      type: 'string',
      description: 'Code artifact preview storage key',
    },
    createIfNotExists: {
      type: 'boolean',
      description: 'Whether to create the code artifact if it does not exist',
      default: false,
    },
  },
} as const;

export const UpsertCodeArtifactResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/CodeArtifact',
        },
      },
    },
  ],
} as const;

export const ListCodeArtifactResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Code artifact list',
          items: {
            $ref: '#/components/schemas/CodeArtifact',
          },
        },
      },
    },
  ],
} as const;

export const GetCodeArtifactDetailResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/CodeArtifact',
        },
      },
    },
  ],
} as const;

export const DuplicateCodeArtifactRequestSchema = {
  type: 'object',
  required: ['artifactId'],
  properties: {
    artifactId: {
      type: 'string',
      description: 'Code artifact ID to duplicate',
    },
    canvasId: {
      type: 'string',
      description: 'Target canvas ID',
    },
  },
} as const;

export const CreateShareRequestSchema = {
  type: 'object',
  required: ['entityType', 'entityId'],
  properties: {
    entityType: {
      $ref: '#/components/schemas/EntityType',
      description: 'Entity type',
    },
    entityId: {
      type: 'string',
      description: 'Entity ID',
    },
    title: {
      type: 'string',
      description: 'Share title',
    },
    allowDuplication: {
      type: 'boolean',
      description: 'Whether to allow duplication of the shared entity',
      default: false,
    },
    parentShareId: {
      type: 'string',
      description: 'Parent share ID',
    },
    shareData: {
      type: 'string',
      description: 'Raw share data (JSON string)',
    },
    shareDataStorageKey: {
      type: 'string',
      description: 'Share data storage key',
    },
    coverStorageKey: {
      type: 'string',
      description: 'Cover storage key',
    },
    creditUsage: {
      type: 'number',
      description: 'Credit usage',
    },
  },
} as const;

export const CreateShareResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/ShareRecord',
          description: 'Share created',
        },
      },
    },
  ],
} as const;

export const ListShareResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Share record list',
          items: {
            $ref: '#/components/schemas/ShareRecord',
          },
        },
      },
    },
  ],
} as const;

export const DeleteShareRequestSchema = {
  type: 'object',
  required: ['shareId'],
  properties: {
    shareId: {
      type: 'string',
      description: 'Share ID',
    },
  },
} as const;

export const DuplicateShareRequestSchema = {
  type: 'object',
  required: ['shareId'],
  properties: {
    shareId: {
      type: 'string',
      description: 'Share ID',
    },
    projectId: {
      type: 'string',
      description: 'Project ID to duplicate the share to',
    },
    canvasId: {
      type: 'string',
      description: 'Target canvas ID',
    },
    title: {
      type: 'string',
      description: 'Custom title for the duplicated entity',
    },
  },
} as const;

export const DuplicateShareResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          description: 'Duplicated entity',
          $ref: '#/components/schemas/Entity',
        },
      },
    },
  ],
} as const;

export const ListLabelClassesResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Label class list',
          items: {
            $ref: '#/components/schemas/LabelClass',
          },
        },
      },
    },
  ],
} as const;

export const CreateLabelClassRequestSchema = {
  type: 'object',
  required: ['name', 'displayName', 'prompt'],
  properties: {
    name: {
      type: 'string',
      description: 'Label class name',
      example: 'my_class',
    },
    displayName: {
      type: 'string',
      description: 'Label display name',
      example: 'My Class',
    },
    icon: {
      description: 'Label icon',
      $ref: '#/components/schemas/Icon',
    },
    prompt: {
      type: 'string',
      description: 'Label creation instruction prompt',
      example: 'Extract labels for the tech-related keywords',
    },
  },
} as const;

export const UpdateLabelClassRequestSchema = {
  type: 'object',
  required: ['labelClassId'],
  properties: {
    labelClassId: {
      type: 'string',
      description: 'Label class ID',
    },
    name: {
      type: 'string',
      description: 'Label class name',
      example: 'My Class',
    },
    displayName: {
      type: 'string',
      description: 'Label display name',
      example: 'My Class',
    },
    icon: {
      description: 'Label icon',
      $ref: '#/components/schemas/Icon',
    },
    prompt: {
      type: 'string',
      description: 'Label creation instruction prompt',
      example: 'Extract labels for the tech-related keywords',
    },
  },
} as const;

export const UpsertLabelClassResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          description: 'Label class upserted',
          $ref: '#/components/schemas/LabelClass',
        },
      },
    },
  ],
} as const;

export const DeleteLabelClassRequestSchema = {
  type: 'object',
  required: ['labelClassId'],
  properties: {
    labelClassId: {
      type: 'string',
      description: 'Label class ID to delete',
      example: 'lc-g30e1b80b5g1itbemc0g5jj3',
    },
  },
} as const;

export const ListLabelInstancesResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Label list',
          items: {
            $ref: '#/components/schemas/LabelInstance',
          },
        },
      },
    },
  ],
} as const;

export const CreateLabelInstanceRequestSchema = {
  type: 'object',
  required: ['labelClassId', 'valueList', 'entityType', 'entityId'],
  properties: {
    labelClassId: {
      type: 'string',
      description: 'Label class ID',
      example: 'lc-g30e1b80b5g1itbemc0g5jj3',
    },
    valueList: {
      type: 'array',
      description: 'Label value list',
      items: {
        type: 'string',
        example: 'label-1',
      },
    },
    entityType: {
      description: 'Label entity type',
      $ref: '#/components/schemas/EntityType',
    },
    entityId: {
      description: 'Label entity ID',
      type: 'string',
    },
  },
} as const;

export const UpdateLabelInstanceRequestSchema = {
  type: 'object',
  properties: {
    labelId: {
      type: 'string',
      description: 'Label ID to update',
    },
    value: {
      type: 'string',
      description: 'Updated label value',
    },
  },
} as const;

export const UpsertLabelInstanceResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Label instance upserted',
          items: {
            $ref: '#/components/schemas/LabelInstance',
          },
        },
      },
    },
  ],
} as const;

export const DeleteLabelInstanceRequestSchema = {
  type: 'object',
  required: ['labelId'],
  properties: {
    labelId: {
      type: 'string',
      description: 'Label ID to delete',
      example: 'lb-g30e1b80b5g1itbemc0g5jj3',
    },
  },
} as const;

export const ActionSchema = {
  type: 'object',
  required: ['actionType', 'actionName'],
  properties: {
    actionType: {
      type: 'string',
      description: 'Action type',
      $ref: '#/components/schemas/ActionType',
    },
    actionName: {
      type: 'string',
      description: 'Action name',
    },
    icon: {
      description: 'Action icon',
      $ref: '#/components/schemas/Icon',
    },
  },
} as const;

export const ListActionResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Action list',
          items: {
            $ref: '#/components/schemas/Action',
          },
        },
      },
    },
  ],
} as const;

export const ListSkillResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Skill list',
          items: {
            $ref: '#/components/schemas/Skill',
          },
        },
      },
    },
  ],
} as const;

export const ListSkillInstanceResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Skill list',
          items: {
            $ref: '#/components/schemas/SkillInstance',
          },
        },
      },
    },
  ],
} as const;

export const SkillInstanceCreateParamSchema = {
  type: 'object',
  required: ['displayName'],
  properties: {
    tplName: {
      type: 'string',
      description: 'Skill template name',
      example: 'online-search',
    },
    displayName: {
      type: 'string',
      description: 'Skill display name',
      example: 'My Custom Skill',
    },
    description: {
      type: 'string',
      description: 'Skill description',
    },
    icon: {
      description: 'Skill instance icon',
      $ref: '#/components/schemas/Icon',
    },
    tplConfig: {
      description: 'Skill template config',
      $ref: '#/components/schemas/SkillTemplateConfig',
    },
  },
} as const;

export const CreateSkillInstanceRequestSchema = {
  type: 'object',
  required: ['instanceList'],
  properties: {
    instanceList: {
      type: 'array',
      description: 'Skill instances to upsert',
      items: {
        $ref: '#/components/schemas/SkillInstanceCreateParam',
      },
    },
  },
} as const;

export const CreateSkillInstanceResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Skill instance list',
          items: {
            $ref: '#/components/schemas/SkillInstance',
          },
        },
      },
    },
  ],
} as const;

export const UpdateSkillInstanceRequestSchema = {
  type: 'object',
  required: ['skillId'],
  properties: {
    skillId: {
      type: 'string',
      description: 'Skill ID',
      example: 's-g30e1b80b5g1itbemc0g5jj3',
    },
    displayName: {
      type: 'string',
      description: 'Skill display name',
      example: 'My Custom Skill',
    },
    description: {
      type: 'string',
      description: 'Skill description',
    },
    icon: {
      description: 'Skill instance icon',
      $ref: '#/components/schemas/Icon',
    },
    tplConfig: {
      description: 'Skill template config',
      $ref: '#/components/schemas/SkillTemplateConfig',
    },
  },
} as const;

export const UpdateSkillInstanceResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          description: 'Skill instance list',
          $ref: '#/components/schemas/SkillInstance',
        },
      },
    },
  ],
} as const;

export const PinSkillInstanceRequestSchema = {
  type: 'object',
  required: ['skillId'],
  properties: {
    skillId: {
      type: 'string',
      description: 'Skill ID to pin',
    },
  },
} as const;

export const UnpinSkillInstanceRequestSchema = {
  type: 'object',
  required: ['skillId'],
  properties: {
    skillId: {
      type: 'string',
      description: 'Skill ID to unpin',
    },
  },
} as const;

export const DeleteSkillInstanceRequestSchema = {
  type: 'object',
  required: ['skillId'],
  properties: {
    skillId: {
      type: 'string',
      description: 'Skill ID to delete',
    },
  },
} as const;

export const SkillInputSchema = {
  type: 'object',
  description: 'Skill input',
  properties: {
    query: {
      type: 'string',
      description: 'User query',
    },
    originalQuery: {
      type: 'string',
      description: 'Original user query',
    },
    images: {
      type: 'array',
      description: 'Image list (storage keys)',
      deprecated: true,
      items: {
        type: 'string',
      },
    },
  },
} as const;

export const SkillContextResourceItemSchema = {
  type: 'object',
  description: 'Skill context resource item',
  properties: {
    resourceId: {
      type: 'string',
      description: 'Resource ID (if empty, this will be considered as external resource)',
    },
    resource: {
      description: 'Resource',
      $ref: '#/components/schemas/Resource',
    },
    isCurrent: {
      type: 'boolean',
      description: 'Whether this resource is current',
    },
    metadata: {
      type: 'object',
      description: 'Resource context metadata',
    },
  },
} as const;

export const SkillContextDocumentItemSchema = {
  type: 'object',
  description: 'Skill context document item',
  properties: {
    docId: {
      type: 'string',
      description: 'Document ID',
    },
    document: {
      description: 'Document',
      $ref: '#/components/schemas/Document',
    },
    isCurrent: {
      type: 'boolean',
      description: 'Whether this document is current',
    },
    metadata: {
      type: 'object',
      description: 'Canvas context metadata',
    },
  },
} as const;

export const SkillContextCodeArtifactItemSchema = {
  type: 'object',
  description: 'Skill context code artifact item',
  properties: {
    artifactId: {
      type: 'string',
      description: 'Artifact ID',
    },
    codeArtifact: {
      description: 'Code artifact',
      $ref: '#/components/schemas/CodeArtifact',
    },
    isCurrent: {
      type: 'boolean',
      description: 'Whether this code artifact is current',
    },
    metadata: {
      type: 'object',
      description: 'Code artifact context metadata',
    },
  },
} as const;

export const SkillContextContentItemSchema = {
  type: 'object',
  description: 'Skill context content item',
  required: ['content'],
  properties: {
    content: {
      type: 'string',
      description: 'Content',
    },
    metadata: {
      type: 'object',
      description: 'Content context metadata',
    },
  },
} as const;

export const SkillContextUrlItemSchema = {
  type: 'object',
  description: 'Skill context url item',
  required: ['url'],
  properties: {
    url: {
      type: 'string',
      description: 'URL',
    },
    metadata: {
      type: 'object',
      description: 'URL context metadata',
    },
  },
} as const;

export const SkillContextMediaItemSchema = {
  type: 'object',
  description: 'Skill context media item',
  required: ['mediaType', 'entityId', 'title', 'url', 'storageKey'],
  properties: {
    mediaType: {
      type: 'string',
      description: 'Media type',
      $ref: '#/components/schemas/MediaType',
    },
    entityId: {
      type: 'string',
      description: 'Media entity ID',
    },
    title: {
      type: 'string',
      description: 'Media title',
    },
    url: {
      type: 'string',
      description: 'Media URL',
    },
    storageKey: {
      type: 'string',
      description: 'Media storage key',
    },
    metadata: {
      type: 'object',
      description: 'Media context metadata',
    },
  },
} as const;

export const SkillContextFileItemSchema = {
  type: 'object',
  description: 'Skill context file item',
  required: ['fileId'],
  properties: {
    fileId: {
      type: 'string',
      description: 'File ID',
    },
    file: {
      description: 'File object',
      $ref: '#/components/schemas/DriveFile',
    },
    variableId: {
      type: 'string',
      description: 'Variable ID if this file is from a workflow variable',
    },
    variableName: {
      type: 'string',
      description: 'Variable name if this file is from a workflow variable',
    },
  },
} as const;

export const SkillContextResultItemSchema = {
  type: 'object',
  description: 'Skill context result item',
  properties: {
    resultId: {
      type: 'string',
      description: 'Result ID',
    },
    result: {
      description: 'Result',
      $ref: '#/components/schemas/ActionResult',
    },
  },
} as const;

export const SkillContextSchema = {
  type: 'object',
  description: 'Skill invocation context',
  properties: {
    resources: {
      type: 'array',
      description: 'Context resources',
      items: {
        $ref: '#/components/schemas/SkillContextResourceItem',
      },
    },
    documents: {
      type: 'array',
      description: 'Context documents',
      items: {
        $ref: '#/components/schemas/SkillContextDocumentItem',
      },
    },
    codeArtifacts: {
      type: 'array',
      description: 'Context code artifacts',
      items: {
        $ref: '#/components/schemas/SkillContextCodeArtifactItem',
      },
    },
    contentList: {
      type: 'array',
      description: 'Context content list',
      items: {
        $ref: '#/components/schemas/SkillContextContentItem',
      },
    },
    urls: {
      type: 'array',
      description: 'List of URLs',
      items: {
        $ref: '#/components/schemas/SkillContextUrlItem',
      },
      deprecated: true,
    },
    mediaList: {
      type: 'array',
      description: 'List of media',
      items: {
        $ref: '#/components/schemas/SkillContextMediaItem',
      },
    },
    files: {
      type: 'array',
      description: 'List of files',
      items: {
        $ref: '#/components/schemas/SkillContextFileItem',
      },
    },
    results: {
      type: 'array',
      description: 'List of results',
      items: {
        $ref: '#/components/schemas/SkillContextResultItem',
      },
    },
  },
} as const;

export const SelectionKeySchema = {
  type: 'string',
  enum: [
    'documentSelection',
    'resourceSelection',
    'skillResponseSelection',
    'extensionWeblinkSelection',
    'documentCursorSelection',
    'documentBeforeCursorSelection',
    'documentAfterCursorSelection',
  ],
} as const;

export const ActionTypeSchema = {
  type: 'string',
  enum: ['skill', 'tool', 'media'],
} as const;

export const AgentModeSchema = {
  type: 'string',
  enum: ['copilot_agent', 'node_agent'],
} as const;

export const InvokeSkillRequestSchema = {
  type: 'object',
  properties: {
    input: {
      description: 'Skill input',
      $ref: '#/components/schemas/SkillInput',
    },
    title: {
      description: 'Agent title',
      type: 'string',
    },
    context: {
      description: 'Skill invocation context',
      $ref: '#/components/schemas/SkillContext',
    },
    resultHistory: {
      type: 'array',
      description: 'Skill result history',
      items: {
        $ref: '#/components/schemas/ActionResult',
      },
      deprecated: true,
    },
    runtimeConfig: {
      description: 'Skill runtime config',
      $ref: '#/components/schemas/SkillRuntimeConfig',
      deprecated: true,
    },
    tplConfig: {
      description: 'Skill template config',
      $ref: '#/components/schemas/SkillTemplateConfig',
      deprecated: true,
    },
    skillName: {
      type: 'string',
      description: 'Skill name (if not provided, commonQnA will be used)',
      deprecated: true,
    },
    target: {
      description: 'Skill invocation target',
      $ref: '#/components/schemas/Entity',
    },
    projectId: {
      type: 'string',
      description: 'Project ID',
    },
    resultId: {
      type: 'string',
      description: `Result ID associated with this invocation.
1) If not provided, a new resultId will be generated.
2) If there is no existing result with this resultId, it will be created and run.
3) If there is an existing result with this resultId, it will be rerun.
`,
    },
    locale: {
      type: 'string',
      description: 'Selected output locale',
    },
    modelName: {
      type: 'string',
      description: 'Selected model',
      deprecated: true,
    },
    modelItemId: {
      type: 'string',
      description: 'Selected model item ID',
    },
    skillId: {
      type: 'string',
      description: 'Skill ID',
    },
    triggerId: {
      type: 'string',
      description: 'Trigger ID',
    },
    selectedMcpServers: {
      type: 'array',
      description: 'Selected MCP servers (deprecated, use `tools` instead)',
      items: {
        type: 'string',
      },
      deprecated: true,
    },
    toolsets: {
      type: 'array',
      description: 'Selected toolsets',
      items: {
        $ref: '#/components/schemas/GenericToolset',
      },
    },
    mode: {
      description: 'Agent mode',
      $ref: '#/components/schemas/AgentMode',
      default: 'node_agent',
    },
    copilotSessionId: {
      type: 'string',
      description: 'Copilot session ID',
    },
    workflowExecutionId: {
      type: 'string',
      description: 'Workflow execution ID for workflow context',
    },
    workflowNodeExecutionId: {
      type: 'string',
      description: 'Workflow node execution ID for workflow context',
    },
  },
} as const;

export const InvokeSkillResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        resultId: {
          type: 'string',
          description: 'Skill result ID',
        },
      },
    },
  ],
} as const;

export const ListSkillTriggerResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Skill trigger list',
          items: {
            $ref: '#/components/schemas/SkillTrigger',
          },
        },
      },
    },
  ],
} as const;

export const SkillTriggerCreateParamSchema = {
  type: 'object',
  required: ['skillId', 'displayName', 'triggerType'],
  properties: {
    skillId: {
      type: 'string',
      description: 'Skill ID',
      example: 'sk-g30e1b80b5g1itbemc0g5jj3',
    },
    displayName: {
      type: 'string',
      description: 'Trigger display name',
      example: 'My trigger',
    },
    triggerType: {
      description: 'Trigger type',
      $ref: '#/components/schemas/SkillTriggerType',
    },
    simpleEventName: {
      description: 'Simple event name (only required when trigger type is `simpleEvent`)',
      $ref: '#/components/schemas/SimpleEventName',
    },
    timerConfig: {
      description: 'Timer config (only required when trigger type is `timer`)',
      $ref: '#/components/schemas/TimerTriggerConfig',
    },
    input: {
      description: 'Skill input',
      $ref: '#/components/schemas/SkillInput',
    },
    context: {
      description: 'Skill invocation context',
      $ref: '#/components/schemas/SkillContext',
    },
    tplConfig: {
      description: 'Skill template config',
      $ref: '#/components/schemas/SkillTemplateConfig',
    },
    enabled: {
      type: 'boolean',
      description: 'Whether this trigger is enabled',
    },
  },
} as const;

export const CreateSkillTriggerRequestSchema = {
  type: 'object',
  required: ['triggerList'],
  properties: {
    triggerList: {
      type: 'array',
      description: 'Skill triggers to upsert',
      items: {
        $ref: '#/components/schemas/SkillTriggerCreateParam',
      },
    },
  },
} as const;

export const CreateSkillTriggerResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Skill trigger list',
          items: {
            $ref: '#/components/schemas/SkillTrigger',
          },
        },
      },
    },
  ],
} as const;

export const UpdateSkillTriggerRequestSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/SkillTriggerCreateParam',
    },
    {
      type: 'object',
      required: ['triggerId'],
      properties: {
        triggerId: {
          type: 'string',
          description: 'Trigger ID',
          example: 'tr-g30e1b80b5g1itbemc0g5jj3',
        },
      },
    },
  ],
} as const;

export const UpdateSkillTriggerResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          description: 'Updated skill trigger',
          $ref: '#/components/schemas/SkillTrigger',
        },
      },
    },
  ],
} as const;

export const DeleteSkillTriggerRequestSchema = {
  type: 'object',
  required: ['triggerId'],
  properties: {
    triggerId: {
      type: 'string',
      description: 'Trigger ID to delete',
    },
  },
} as const;

export const MediaTypeSchema = {
  type: 'string',
  description: 'media type',
  enum: ['image', 'video', 'audio'],
  example: 'image',
} as const;

export const MediaGenerateRequestSchema = {
  type: 'object',
  required: ['mediaType', 'prompt'],
  properties: {
    mediaType: {
      $ref: '#/components/schemas/MediaType',
    },
    model: {
      type: 'string',
      description: 'Model name for content generation',
    },
    title: {
      type: 'string',
      description: 'Title of the generated media',
    },
    targetType: {
      description: 'Target type',
      $ref: '#/components/schemas/EntityType',
    },
    targetId: {
      type: 'string',
      description: 'Target ID',
    },
    providerItemId: {
      type: 'string',
      description: 'Provider item ID',
    },
    provider: {
      type: 'string',
      description: 'Optional provider selection (use providerItemId instead)',
      nullable: true,
    },
    prompt: {
      type: 'string',
      description: 'Text prompt for content generation',
    },
    wait: {
      type: 'boolean',
      description: 'Whether to wait for the generation to complete',
      default: false,
    },
    resultId: {
      type: 'string',
      description: 'Media generation result ID',
    },
    parentResultId: {
      type: 'string',
      description: 'Parent result ID for the media generation (usually the actor agent result ID)',
    },
    parentResultVersion: {
      type: 'number',
      description:
        'Parent result version for the media generation (usually the actor agent result version)',
    },
    apiKey: {
      type: 'string',
      description: 'API key for the provider',
    },
    inputParameters: {
      type: 'array',
      description: 'Input parameter configurations',
      items: {
        $ref: '#/components/schemas/MediaModelParameter',
      },
    },
    input: {
      type: 'object',
      description: 'Flexible key-value pairs for additional input parameters',
      additionalProperties: true,
    },
    unitCost: {
      type: 'number',
      description: 'Unit cost for the media generation',
    },
  },
} as const;

export const MediaGenerationResultSchema = {
  type: 'object',
  required: ['resultId'],
  properties: {
    resultId: {
      type: 'string',
      description: 'Media generation result ID',
      example: 'ar-g30e1b80b5g1itbemc0g5jj3',
    },
    file: {
      $ref: '#/components/schemas/DriveFile',
      description: 'Generated file',
    },
    outputUrl: {
      type: 'string',
      description: 'Media generation output URL (only available when `wait` is true)',
      deprecated: true,
    },
    storageKey: {
      type: 'string',
      description: 'Media generation output storage key (only available when `wait` is true)',
      deprecated: true,
    },
    originalResult: {
      type: 'object',
      description: 'Media generation original result from provider',
    },
  },
} as const;

export const MediaGenerateResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/MediaGenerationResult',
        },
      },
    },
  ],
} as const;

export const FishAudioTextToSpeechRequestSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/MediaGenerateRequest',
    },
    {
      type: 'object',
      required: ['text'],
      properties: {
        text: {
          type: 'string',
          description: 'Text to convert to speech',
          example: 'Hello, welcome to Refly',
          minLength: 1,
          maxLength: 5000,
        },
        referenceId: {
          type: 'string',
          description: 'Voice model reference ID (optional, uses default if not specified)',
          example: '7f92f8afb8ec43bf81429cc1c9199cb1',
        },
        references: {
          type: 'array',
          description:
            'Reference audio files for voice cloning (alternative to referenceId). Provide uploaded audio files with optional transcripts.',
          items: {
            type: 'object',
            required: ['entityId'],
            properties: {
              entityId: {
                type: 'string',
                description: 'Entity ID of the uploaded audio file from file upload',
                example: 'r-vkwhup837t2jzicp87v8i6q5',
              },
              text: {
                type: 'string',
                description:
                  'Optional transcript text of the audio. If not provided, will be automatically transcribed using speech-to-text.',
                example: 'Hello, this is a sample voice recording',
              },
            },
          },
        },
        format: {
          type: 'string',
          description: 'Output audio format',
          enum: ['mp3', 'wav', 'opus', 'pcm'],
          default: 'mp3',
          example: 'mp3',
        },
        mp3Bitrate: {
          type: 'integer',
          description: 'MP3 bitrate (only for mp3 format)',
          enum: [64, 128, 192],
          default: 128,
          example: 128,
        },
        sampleRate: {
          type: 'integer',
          description: 'Sample rate in Hz',
          example: 44100,
        },
        temperature: {
          type: 'number',
          description: 'Controls randomness (0-1)',
          minimum: 0,
          maximum: 1,
          default: 0.9,
          example: 0.9,
        },
        topP: {
          type: 'number',
          description: 'Nucleus sampling diversity control (0-1)',
          minimum: 0,
          maximum: 1,
          default: 0.9,
          example: 0.9,
        },
        normalize: {
          type: 'boolean',
          description: 'Whether to normalize audio',
          default: true,
        },
        chunkLength: {
          type: 'integer',
          description: 'Chunk length for processing',
          minimum: 100,
          maximum: 300,
          default: 200,
        },
        wait: {
          type: 'boolean',
        },
      },
      description: 'Whether to wait for the generation to complete',
      default: false,
    },
  ],
} as const;

export const FishAudioTextToSpeechResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponseV2',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'TTS response data (present when status is success)',
          properties: {
            audioUrl: {
              type: 'string',
              format: 'uri',
              description: 'Public URL of the generated audio',
              example: 'https://cdn.refly.ai/static/abc123.mp3',
            },
            entityId: {
              type: 'string',
              description: 'Entity ID of the generated audio file',
              example: 'r-vkwhup837t2jzicp87v8i6q5',
            },
            duration: {
              type: 'number',
              description: 'Audio duration in seconds',
              example: 5.2,
            },
            format: {
              type: 'string',
              description: 'Audio format',
              example: 'mp3',
            },
            size: {
              type: 'integer',
              description: 'File size in bytes',
              example: 102400,
            },
            resultId: {
              type: 'string',
              description: 'Audio generation result ID',
              example: 'ar-g30e1b80b5g1itbemc0g5jj3',
            },
            storageKey: {
              type: 'string',
              description: 'Storage key for the generated audio (only available when wait is true)',
            },
          },
        },
      },
    },
  ],
} as const;

export const FishAudioSpeechToTextRequestSchema = {
  type: 'object',
  required: ['entityId'],
  properties: {
    entityId: {
      type: 'string',
      description: 'Entity ID of the uploaded audio file to transcribe',
      example: 'r-vkwhup837t2jzicp87v8i6q5',
    },
    language: {
      type: 'string',
      description: 'Language code for speech recognition (e.g., "zh", "en")',
      example: 'en',
    },
    ignoreTimestamps: {
      type: 'boolean',
      description: 'Whether to ignore timestamps (increases latency for audio shorter than 30s)',
      default: true,
    },
  },
} as const;

export const FishAudioSpeechToTextResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponseV2',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'STT response data (present when status is success)',
          properties: {
            text: {
              type: 'string',
              description: 'Transcribed text',
              example: 'Hello, welcome to Refly',
            },
            duration: {
              type: 'number',
              description: 'Audio duration in seconds',
              example: 5.2,
            },
            segments: {
              type: 'array',
              description: 'Text segments with timestamps',
              items: {
                type: 'object',
                properties: {
                  text: {
                    type: 'string',
                    description: 'Segment text',
                  },
                  start: {
                    type: 'number',
                    description: 'Start time in seconds',
                  },
                  end: {
                    type: 'number',
                    description: 'End time in seconds',
                  },
                },
              },
            },
          },
        },
      },
    },
  ],
} as const;

export const HeyGenGenerateVideoRequestSchema = {
  type: 'object',
  required: ['scenes'],
  properties: {
    scenes: {
      type: 'array',
      description: 'Video scenes (1-50 items)',
      minItems: 1,
      maxItems: 50,
      items: {
        type: 'object',
        required: ['voice'],
        properties: {
          character: {
            type: 'object',
            required: ['avatarId'],
            properties: {
              type: {
                type: 'string',
                enum: ['avatar', 'talking_photo'],
                default: 'avatar',
                description: 'Character type',
              },
              avatarId: {
                type: 'string',
                description: 'Avatar ID from HeyGen',
                example: 'avatar_123',
              },
              avatarStyle: {
                type: 'string',
                enum: ['normal', 'circle', 'closeUp'],
                default: 'normal',
                description: 'Avatar display style',
              },
              scale: {
                type: 'number',
                minimum: 0,
                maximum: 5,
                description: 'Avatar scale',
              },
              offset: {
                type: 'object',
                description: 'Avatar position offset',
                properties: {
                  x: {
                    type: 'number',
                  },
                  y: {
                    type: 'number',
                  },
                },
              },
            },
          },
          voice: {
            type: 'object',
            required: ['type'],
            properties: {
              type: {
                type: 'string',
                enum: ['text', 'audio', 'silence'],
                description: 'Voice type',
              },
              voiceId: {
                type: 'string',
                description: 'Voice ID (for text type)',
              },
              inputText: {
                type: 'string',
                description: 'Text to speak (for text type)',
              },
              audioUrl: {
                type: 'string',
                description: 'Audio URL (for audio type, lowest priority)',
              },
              storageKey: {
                type: 'string',
                description:
                  'Storage key of the audio file (format "static/{uuid}", for audio type, takes priority over audioUrl)',
              },
              speed: {
                type: 'number',
                minimum: 0.5,
                maximum: 1.5,
                description: 'Speech speed',
              },
              pitch: {
                type: 'number',
                minimum: -50,
                maximum: 50,
                description: 'Voice pitch',
              },
              emotion: {
                type: 'string',
                description: 'Voice emotion',
              },
            },
          },
          background: {
            type: 'object',
            description: 'Scene background',
            properties: {
              type: {
                type: 'string',
                enum: ['color', 'image', 'video'],
                description: 'Background type',
              },
              url: {
                type: 'string',
                description: 'Background image/video URL (lowest priority)',
              },
              storageKey: {
                type: 'string',
                description:
                  'Storage key of the background file (format "static/{uuid}", takes priority over url)',
              },
              color: {
                type: 'string',
                description: 'Background color (hex)',
                example: '#f6f6fc',
              },
              playStyle: {
                type: 'string',
                enum: ['freeze', 'loop', 'fit_to_scene', 'once'],
                default: 'fit_to_scene',
                description: 'Video playback mode (only for type "video")',
              },
            },
          },
        },
      },
    },
    dimension: {
      type: 'object',
      description: 'Video dimensions',
      properties: {
        width: {
          type: 'integer',
          example: 1280,
        },
        height: {
          type: 'integer',
          example: 720,
        },
      },
    },
    aspectRatio: {
      type: 'string',
      description: 'Video aspect ratio',
      example: '16:9',
    },
    test: {
      type: 'boolean',
      description: 'Test mode (adds watermark)',
      default: false,
    },
    title: {
      type: 'string',
      description: 'Video title',
    },
    callbackId: {
      type: 'string',
      description: 'Custom callback identifier',
    },
    caption: {
      type: 'boolean',
      description: 'Add captions',
      default: false,
    },
    parentResultId: {
      type: 'string',
      description: 'Parent action result ID for context inheritance',
    },
  },
} as const;

export const HeyGenGenerateVideoResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponseV2',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          properties: {
            videoId: {
              type: 'string',
              description: 'Generated video ID',
              example: 'video_abc123',
            },
            status: {
              type: 'string',
              enum: ['pending', 'processing', 'completed', 'failed'],
              description: 'Video generation status',
            },
            videoUrl: {
              type: 'string',
              format: 'uri',
              description: 'Video URL (when completed)',
            },
            thumbnailUrl: {
              type: 'string',
              format: 'uri',
              description: 'Thumbnail URL',
            },
            duration: {
              type: 'number',
              description: 'Video duration in seconds',
            },
            error: {
              type: 'object',
              description: 'Error details (when failed)',
              properties: {
                code: {
                  type: 'string',
                },
                message: {
                  type: 'string',
                },
              },
            },
          },
        },
      },
    },
  ],
} as const;

export const SandboxExecuteParamsSchema = {
  type: 'object',
  required: ['code', 'language'],
  properties: {
    code: {
      type: 'string',
      description: 'Code to execute in the sandbox',
    },
    language: {
      type: 'string',
      description: 'Programming language for code execution',
      enum: ['python', 'javascript', 'shell'],
      example: 'python',
    },
  },
} as const;

export const SandboxExecuteContextSchema = {
  type: 'object',
  properties: {
    parentResultId: {
      type: 'string',
      description: 'Parent action result ID for context inheritance',
    },
    canvasId: {
      type: 'string',
      description: 'Canvas ID for context',
    },
    targetId: {
      type: 'string',
      description: 'Target entity ID',
    },
    targetType: {
      type: 'string',
      description: 'Target entity type',
    },
    model: {
      type: 'string',
      description: 'Model name for credit tracking',
    },
    providerItemId: {
      type: 'string',
      description: 'Provider item ID for credit tracking',
    },
    version: {
      type: 'number',
      description: 'Result version for file registration',
    },
  },
} as const;

export const SandboxExecuteRequestSchema = {
  type: 'object',
  required: ['params'],
  properties: {
    params: {
      $ref: '#/components/schemas/SandboxExecuteParams',
    },
    context: {
      $ref: '#/components/schemas/SandboxExecuteContext',
    },
  },
} as const;

export const SandboxExecuteResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponseV2',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: `Execution result data. Present when status is 'success'.
- exitCode=0: Code executed successfully
- exitCode!=0: Code error (syntax error, runtime exception, etc.)
`,
          properties: {
            output: {
              type: 'string',
              description: 'Combined output from stdout and execution result text',
            },
            error: {
              type: 'string',
              description:
                'Error message extracted from stderr/traceback (ANSI stripped, truncated if too long)',
            },
            exitCode: {
              type: 'integer',
              description: 'Exit code of the execution (0=success, non-zero=code error)',
            },
            executionTime: {
              type: 'integer',
              description: 'Execution time in milliseconds',
            },
            files: {
              type: 'array',
              description:
                'List of files generated by the code execution (available even when exitCode!=0)',
              items: {
                $ref: '#/components/schemas/DriveFile',
              },
            },
            warnings: {
              type: 'array',
              description:
                'System warnings from sandbox (e.g., file rename due to conflict, temporary directory creation)',
              items: {
                type: 'string',
              },
            },
          },
        },
      },
    },
  ],
} as const;

export const PilotStepStatusSchema = {
  type: 'string',
  enum: ['init', 'executing', 'finish', 'failed'],
} as const;

export const PilotStepSchema = {
  type: 'object',
  properties: {
    stepId: {
      type: 'string',
      description: 'Pilot step ID',
    },
    name: {
      type: 'string',
      description: 'Pilot step name',
    },
    epoch: {
      type: 'number',
      description: 'Pilot step epoch',
    },
    entityId: {
      type: 'string',
      description: 'Pilot step entity ID',
    },
    entityType: {
      type: 'string',
      description: 'Pilot step entity type',
    },
    status: {
      description: 'Pilot step status',
      $ref: '#/components/schemas/PilotStepStatus',
    },
    rawOutput: {
      type: 'string',
      description: 'Pilot step raw output',
    },
    actionResult: {
      description: 'Pilot step action result',
      $ref: '#/components/schemas/ActionResult',
    },
    createdAt: {
      type: 'string',
      description: 'Pilot step created at',
    },
    updatedAt: {
      type: 'string',
      description: 'Pilot step updated at',
    },
  },
} as const;

export const PilotSessionStatusSchema = {
  type: 'string',
  enum: ['init', 'executing', 'waiting', 'finish', 'failed'],
} as const;

export const PilotSessionSchema = {
  type: 'object',
  required: [
    'sessionId',
    'status',
    'targetType',
    'targetId',
    'title',
    'input',
    'currentEpoch',
    'maxEpoch',
  ],
  properties: {
    sessionId: {
      type: 'string',
      description: 'Pilot session ID',
    },
    title: {
      type: 'string',
      description: 'Pilot session title',
    },
    input: {
      description: 'Pilot session input',
      $ref: '#/components/schemas/SkillInput',
    },
    status: {
      description: 'Pilot session status',
      $ref: '#/components/schemas/PilotSessionStatus',
    },
    targetType: {
      description: 'Pilot session target type',
      $ref: '#/components/schemas/EntityType',
    },
    targetId: {
      type: 'string',
      description: 'Pilot session target ID',
    },
    currentEpoch: {
      type: 'number',
      description: 'Pilot session current epoch',
    },
    maxEpoch: {
      type: 'number',
      description: 'Pilot session max epoch',
    },
    steps: {
      type: 'array',
      description: 'Pilot steps',
      items: {
        $ref: '#/components/schemas/PilotStep',
      },
    },
    createdAt: {
      type: 'string',
      description: 'Pilot session created at',
    },
    updatedAt: {
      type: 'string',
      description: 'Pilot session updated at',
    },
  },
} as const;

export const CreatePilotSessionRequestSchema = {
  type: 'object',
  required: ['targetId', 'targetType', 'input'],
  properties: {
    targetId: {
      type: 'string',
      description: 'Pilot session target ID',
    },
    targetType: {
      description: 'Pilot session target type',
      $ref: '#/components/schemas/EntityType',
    },
    maxEpoch: {
      type: 'number',
      description: 'Pilot session max epoch',
      default: 2,
    },
    title: {
      type: 'string',
      description: 'Pilot session title',
    },
    input: {
      description: 'Pilot session input',
      $ref: '#/components/schemas/SkillInput',
    },
    providerItemId: {
      type: 'string',
      description: 'Pilot session provider item ID',
    },
  },
} as const;

export const UpdatePilotSessionRequestSchema = {
  type: 'object',
  required: ['sessionId'],
  properties: {
    sessionId: {
      type: 'string',
      description: 'Pilot session ID',
    },
    input: {
      description: 'Pilot session input',
      $ref: '#/components/schemas/SkillInput',
    },
    maxEpoch: {
      type: 'number',
      description: 'Pilot session max epoch',
      default: 2,
    },
  },
} as const;

export const RecoverPilotSessionRequestSchema = {
  type: 'object',
  required: ['sessionId'],
  properties: {
    sessionId: {
      type: 'string',
      description: 'Pilot session ID to recover',
    },
    stepIds: {
      type: 'array',
      description:
        'Optional array of specific step IDs to recover. If not provided, recovers all failed steps in the current epoch.',
      items: {
        type: 'string',
      },
    },
  },
} as const;

export const UpsertPilotSessionResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          description: 'Upserted pilot session',
          $ref: '#/components/schemas/PilotSession',
        },
      },
    },
  ],
} as const;

export const ListPilotSessionsResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Pilot session list',
          items: {
            $ref: '#/components/schemas/PilotSession',
          },
        },
      },
    },
  ],
} as const;

export const GetPilotSessionDetailResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          description: 'Pilot session detail',
          $ref: '#/components/schemas/PilotSession',
        },
      },
    },
  ],
} as const;

export const CopilotSessionSchema = {
  type: 'object',
  properties: {
    sessionId: {
      type: 'string',
      description: 'Copilot session ID',
    },
    title: {
      type: 'string',
      description: 'Copilot session title',
    },
    canvasId: {
      type: 'string',
      description: 'Copilot session canvas ID',
    },
    createdAt: {
      type: 'string',
      description: 'Copilot session created at',
    },
    updatedAt: {
      type: 'string',
      description: 'Copilot session updated at',
    },
    results: {
      type: 'array',
      description: 'Copilot session results (only returned in detail API)',
      items: {
        $ref: '#/components/schemas/ActionResult',
      },
    },
  },
} as const;

export const ListCopilotSessionsResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Copilot session list',
          items: {
            $ref: '#/components/schemas/CopilotSession',
          },
        },
      },
    },
  ],
} as const;

export const GetCopilotSessionDetailResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          description: 'Copilot session detail',
          $ref: '#/components/schemas/CopilotSession',
        },
      },
    },
  ],
} as const;

export const UpdateUserSettingsRequestSchema = {
  type: 'object',
  properties: {
    name: {
      type: 'string',
      description: 'User name',
      example: 'john_name',
    },
    nickname: {
      type: 'string',
      description: 'User nickname',
      example: 'John Doe',
    },
    avatar: {
      type: 'string',
      description: 'User avatar',
    },
    avatarStorageKey: {
      type: 'string',
      description: 'User avatar storage key',
    },
    uiLocale: {
      type: 'string',
      description: 'UI locale',
      example: 'en',
    },
    outputLocale: {
      type: 'string',
      description: 'Output locale',
      example: 'en',
    },
    preferences: {
      description: 'User preferences',
      $ref: '#/components/schemas/UserPreferences',
    },
    onboarding: {
      description: 'Onboarding config',
      $ref: '#/components/schemas/OnboardingConfig',
    },
  },
} as const;

export const CheckSettingsFieldResultSchema = {
  type: 'object',
  required: ['field', 'value', 'available'],
  properties: {
    field: {
      type: 'string',
      description: 'Settings field',
    },
    value: {
      type: 'string',
      description: 'Settings field value',
    },
    available: {
      type: 'boolean',
      description: 'Whether the field value is available',
    },
  },
} as const;

export const CheckSettingsFieldResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          description: 'Settings field check result',
          $ref: '#/components/schemas/CheckSettingsFieldResult',
        },
      },
    },
  ],
} as const;

export const CreateCheckoutSessionRequestSchema = {
  type: 'object',
  required: ['planType'],
  properties: {
    planType: {
      description: 'Subscription plan type',
      $ref: '#/components/schemas/SubscriptionPlanType',
    },
    interval: {
      description: 'Subscription billing interval',
      $ref: '#/components/schemas/SubscriptionInterval',
    },
    voucherId: {
      type: 'string',
      description: 'Optional voucher ID to apply discount',
    },
    voucherEntryPoint: {
      type: 'string',
      description:
        'Entry point where voucher was applied (e.g., claimed_popup, discount_popup, credit_insufficient_modal, pricing_page)',
    },
    voucherUserType: {
      type: 'string',
      description: 'User type when voucher was applied (e.g., new, returning)',
    },
    currentPlan: {
      type: 'string',
      description: 'Current plan',
    },
    source: {
      type: 'string',
      description: 'Source',
    },
  },
} as const;

export const CreateCreditPackCheckoutSessionRequestSchema = {
  type: 'object',
  required: ['packId'],
  properties: {
    packId: {
      type: 'string',
      description: 'Credit pack identifier',
    },
    currentPlan: {
      type: 'string',
      description: 'Current plan',
    },
    source: {
      type: 'string',
      description: 'Source',
    },
  },
} as const;

export const CreateCheckoutSessionResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Checkout session',
          properties: {
            url: {
              type: 'string',
              description: 'Checkout session URL',
            },
          },
        },
      },
    },
  ],
} as const;

export const CreatePortalSessionResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Portal session',
          properties: {
            url: {
              type: 'string',
              description: 'Portal session URL',
            },
          },
        },
      },
    },
  ],
} as const;

export const SubmitFormRequestSchema = {
  type: 'object',
  required: ['formSubmission'],
  properties: {
    formSubmission: {
      description: 'Form submission',
      $ref: '#/components/schemas/FormSubmission',
    },
  },
} as const;

export const GetFormDefinitionResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Form definition',
          $ref: '#/components/schemas/FormDefinition',
        },
      },
    },
  ],
} as const;

export const HasFilledFormResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Has filled form data',
          properties: {
            hasFilledForm: {
              type: 'boolean',
              description: 'Whether the user has filled the form',
              default: false,
            },
          },
        },
      },
    },
  ],
} as const;

export const GetCreditRechargeResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Credit recharge data with pagination',
          properties: {
            data: {
              type: 'array',
              description: 'Credit recharge list',
              items: {
                $ref: '#/components/schemas/CreditRecharge',
              },
            },
            total: {
              type: 'integer',
              description: 'Total number of records',
            },
            page: {
              type: 'integer',
              description: 'Current page number',
            },
            pageSize: {
              type: 'integer',
              description: 'Number of items per page',
            },
          },
        },
      },
    },
  ],
} as const;

export const GetCreditUsageResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Credit usage data with pagination',
          properties: {
            data: {
              type: 'array',
              description: 'Credit usage list',
              items: {
                $ref: '#/components/schemas/CreditUsage',
              },
            },
            total: {
              type: 'integer',
              description: 'Total number of records',
            },
            page: {
              type: 'integer',
              description: 'Current page number',
            },
            pageSize: {
              type: 'integer',
              description: 'Number of items per page',
            },
          },
        },
      },
    },
  ],
} as const;

export const getCreditBalanceResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Credit balance',
          properties: {
            creditBalance: {
              type: 'number',
              description: 'Credit balance',
            },
            creditAmount: {
              type: 'number',
              description: 'Credit amount',
            },
            regularCredits: {
              type: 'number',
              description: 'Regular credits (from purchases, gifts, subscriptions)',
            },
            templateEarningsCredits: {
              type: 'number',
              description: 'Template earnings credits',
            },
            cumulativeEarningsCredits: {
              type: 'number',
              description: 'Cumulative earnings credits',
            },
          },
        },
      },
    },
  ],
} as const;

export const GetCreditUsageByResultIdResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Credit usage by result ID',
          properties: {
            total: {
              type: 'number',
              description: 'Total credit usage by result ID',
            },
            usages: {
              type: 'array',
              description: 'Credit usage list by result ID',
              items: {
                $ref: '#/components/schemas/CreditUsage',
              },
            },
          },
        },
      },
    },
  ],
} as const;

export const GetCreditUsageByExecutionIdResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Credit usage by execution ID',
          properties: {
            total: {
              type: 'number',
              description: 'Total credit usage by execution ID',
            },
            usages: {
              type: 'array',
              description: 'Credit usage list by execution ID',
              items: {
                $ref: '#/components/schemas/CreditUsage',
              },
            },
          },
        },
      },
    },
  ],
} as const;

export const GetCreditUsageByCanvasIdResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Credit usage by canvas ID',
          properties: {
            total: {
              type: 'number',
              description: 'Total credit usage by canvas ID',
            },
            usages: {
              type: 'array',
              description: 'Credit usage list by canvas ID',
              items: {
                $ref: '#/components/schemas/CreditUsage',
              },
            },
          },
        },
      },
    },
  ],
} as const;

export const GetCanvasCommissionByCanvasIdResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Canvas commission by canvas ID',
          properties: {
            total: {
              type: 'number',
              description: 'Total canvas commission by canvas ID',
            },
          },
        },
      },
    },
  ],
} as const;

export const InvitationCodeSchema = {
  type: 'object',
  properties: {
    code: {
      type: 'string',
      description: 'Invitation code',
    },
    inviterUid: {
      type: 'string',
      description: 'Inviter UID',
    },
    inviteeUid: {
      type: 'string',
      description: 'Invitee UID',
    },
    status: {
      type: 'string',
      description: 'Invitation status',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Invitation creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Invitation update time',
    },
  },
} as const;

export const ActivateInvitationCodeRequestSchema = {
  type: 'object',
  properties: {
    code: {
      type: 'string',
      description: 'Invitation code',
    },
  },
} as const;

export const ListInvitationCodesResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Invitation code list',
          items: {
            $ref: '#/components/schemas/InvitationCode',
          },
        },
      },
    },
  ],
} as const;

export const HasBeenInvitedResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Has been invited data',
          properties: {
            hasBeenInvited: {
              type: 'boolean',
              description: 'Whether user has been invited',
              default: false,
            },
          },
        },
      },
    },
  ],
} as const;

export const SubscriptionPlanSchema = {
  type: 'object',
  properties: {
    planType: {
      type: 'string',
      description: 'Subscription plan type',
    },
    creditQuota: {
      type: 'number',
      description: 'Credit quota per month',
    },
    dailyGiftCreditQuota: {
      type: 'number',
      description: 'Daily gift credit quota',
    },
    t1TokenQuota: {
      type: 'number',
      description: 'Token quota per month (T1)',
    },
    t2TokenQuota: {
      type: 'number',
      description: 'Token quota per month (T2)',
    },
    objectStorageQuota: {
      type: 'string',
      description: 'Object storage quota (in bytes)',
    },
    vectorStorageQuota: {
      type: 'string',
      description: 'Vector storage quota (in bytes)',
    },
  },
} as const;

export const GetSubscriptionPlansResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Subscription plans',
          items: {
            $ref: '#/components/schemas/SubscriptionPlan',
          },
        },
      },
    },
  ],
} as const;

export const SubscriptionUsageDataSchema = {
  type: 'object',
  properties: {
    token: {
      description: 'Token usage meter',
      $ref: '#/components/schemas/TokenUsageMeter',
    },
    storage: {
      description: 'Storage usage meter',
      $ref: '#/components/schemas/StorageUsageMeter',
    },
    fileParsing: {
      description: 'File parsing meter',
      $ref: '#/components/schemas/FileParsingMeter',
    },
  },
} as const;

export const GetSubscriptionUsageResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Subscription usage',
          $ref: '#/components/schemas/SubscriptionUsageData',
        },
      },
    },
  ],
} as const;

export const WebSearchRequestSchema = {
  type: 'object',
  properties: {
    q: {
      type: 'string',
      description: 'Search query',
    },
    hl: {
      type: 'string',
      description: 'Language/locale code',
    },
    gl: {
      type: 'string',
      description: 'Country/region code',
    },
    location: {
      type: 'string',
      description: 'Location string',
    },
    limit: {
      type: 'number',
      description: 'Web search result limit',
      default: 10,
    },
  },
} as const;

export const BatchWebSearchRequestSchema = {
  type: 'object',
  properties: {
    limit: {
      type: 'number',
      description: 'Web search result limit',
      default: 10,
    },
    queries: {
      type: 'array',
      description: 'Web search queries',
      items: {
        $ref: '#/components/schemas/WebSearchRequest',
      },
    },
  },
} as const;

export const MultiLingualWebSearchRequestSchema = {
  type: 'object',
  required: ['query', 'searchLocaleList'],
  properties: {
    query: {
      type: 'string',
      description: 'Search query',
    },
    searchLocaleList: {
      type: 'array',
      description: 'List of search locales',
      items: {
        type: 'string',
      },
    },
    displayLocale: {
      type: 'string',
      description: 'Display locale',
      default: 'auto',
    },
    searchLimit: {
      type: 'number',
      description: 'Web search result limit per locale',
    },
    enableRerank: {
      type: 'boolean',
      description: 'Whether to enable reranking of search results',
    },
    rerankLimit: {
      type: 'number',
      description: 'Limit for reranked results',
    },
    rerankRelevanceThreshold: {
      type: 'number',
      description: 'Relevance threshold for reranking',
    },
  },
} as const;

export const MultiLingualWebSearchResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'Multilingual web search results',
          required: ['sources', 'searchSteps'],
          properties: {
            sources: {
              type: 'array',
              description: 'Search result sources',
              items: {
                $ref: '#/components/schemas/Source',
              },
            },
            searchSteps: {
              type: 'array',
              description: 'Search steps',
              items: {
                $ref: '#/components/schemas/SearchStep',
              },
            },
          },
        },
      },
    },
  ],
} as const;

export const WebSearchResultSchema = {
  type: 'object',
  properties: {
    name: {
      type: 'string',
      description: 'Web search result name',
    },
    url: {
      type: 'string',
      description: 'Web search result url',
    },
    snippet: {
      type: 'string',
      description: 'Web search result snippet',
    },
    locale: {
      type: 'string',
      description: 'Web search result locale',
    },
  },
} as const;

export const WebSearchResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Web search results',
          items: {
            $ref: '#/components/schemas/WebSearchResult',
          },
        },
      },
    },
  ],
} as const;

export const RerankResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Reranked results',
          items: {
            $ref: '#/components/schemas/SearchResult',
          },
        },
      },
    },
  ],
} as const;

export const SearchOptionsSchema = {
  type: 'object',
  description: 'Search options for internal use',
  properties: {
    enableReranker: {
      type: 'boolean',
      description: 'Whether to enable reranker',
      default: true,
    },
  },
} as const;

export const SearchDomainSchema = {
  type: 'string',
  enum: ['resource', 'document', 'canvas'],
} as const;

export const SearchModeSchema = {
  type: 'string',
  enum: ['keyword', 'vector', 'hybrid'],
} as const;

export const SearchRequestSchema = {
  type: 'object',
  required: ['query'],
  properties: {
    query: {
      type: 'string',
      description: 'Search query (if empty, return last updated data)',
    },
    domains: {
      type: 'array',
      description: 'Search domains (if not specified, return all domains)',
      items: {
        $ref: '#/components/schemas/SearchDomain',
      },
    },
    entities: {
      type: 'array',
      description: 'Search entities',
      items: {
        $ref: '#/components/schemas/Entity',
      },
    },
    mode: {
      type: 'string',
      description: 'Search mode',
      $ref: '#/components/schemas/SearchMode',
      default: 'keyword',
    },
    projectId: {
      type: 'string',
      description: 'Project ID',
    },
    limit: {
      type: 'number',
      description: 'Search result limit for each domain',
      default: 5,
    },
  },
} as const;

export const SearchResultSnippetSchema = {
  type: 'object',
  properties: {
    text: {
      type: 'string',
      description: 'Search result content text',
    },
    highlightedText: {
      type: 'string',
      description: 'Search result highlighted content text with em html tags',
    },
  },
} as const;

export const SearchResultSchema = {
  type: 'object',
  required: ['id', 'domain', 'title'],
  properties: {
    id: {
      type: 'string',
      description: 'Search result ID to navigate to',
    },
    domain: {
      description: 'Search result domain',
      $ref: '#/components/schemas/SearchDomain',
    },
    title: {
      type: 'string',
      description: 'Search result title',
    },
    highlightedTitle: {
      type: 'string',
      description: 'Search result highlighted title with em html tags',
    },
    contentPreview: {
      type: 'string',
      description: 'Search result content preview',
    },
    snippets: {
      type: 'array',
      description: 'Search result content list with highlight marks',
      items: {
        $ref: '#/components/schemas/SearchResultSnippet',
      },
    },
    relevanceScore: {
      type: 'number',
      description: 'Search result relevance score',
    },
    metadata: {
      type: 'object',
      description: 'Search result metadata',
      additionalProperties: true,
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Data creation time',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Data update time',
    },
  },
} as const;

export const SearchResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Search result',
          items: {
            $ref: '#/components/schemas/SearchResult',
          },
        },
      },
    },
  ],
} as const;

export const ScrapeWeblinkRequestSchema = {
  type: 'object',
  required: ['url'],
  properties: {
    url: {
      type: 'string',
      description: 'Weblink URL',
    },
  },
} as const;

export const ScrapeWeblinkResultSchema = {
  type: 'object',
  properties: {
    title: {
      type: 'string',
      description: 'Weblink title',
    },
    description: {
      type: 'string',
      description: 'Weblink description',
    },
    image: {
      type: 'string',
      description: 'Weblink image',
    },
  },
} as const;

export const ScrapeWeblinkResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          description: 'Weblink scrape result',
          $ref: '#/components/schemas/ScrapeWeblinkResult',
        },
      },
    },
  ],
} as const;

export const FileVisibilitySchema = {
  type: 'string',
  enum: ['public', 'private'],
} as const;

export const UploadRequestSchema = {
  type: 'object',
  required: ['file'],
  properties: {
    file: {
      type: 'string',
      format: 'binary',
      description: 'File to upload',
    },
    entityId: {
      type: 'string',
      description: 'Entity ID',
    },
    entityType: {
      description: 'Entity type',
      $ref: '#/components/schemas/EntityType',
    },
    visibility: {
      description: 'File visibility (default is private)',
      $ref: '#/components/schemas/FileVisibility',
    },
    storageKey: {
      type: 'string',
      description: 'Storage key (if provided, the file will be replaced if it already exists)',
    },
  },
} as const;

export const UploadResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          description: 'File upload result',
          required: ['url', 'storageKey'],
          properties: {
            url: {
              type: 'string',
              description: 'File URL',
            },
            storageKey: {
              type: 'string',
              description: 'Storage key',
            },
          },
        },
      },
    },
  ],
} as const;

export const ConvertRequestSchema = {
  type: 'object',
  required: ['file'],
  properties: {
    file: {
      type: 'string',
      format: 'binary',
      description: 'The file to convert',
    },
    from: {
      type: 'string',
      description: 'Source format (e.g., html)',
      default: 'html',
    },
    to: {
      type: 'string',
      description: 'Target format (e.g., markdown)',
      default: 'markdown',
    },
  },
} as const;

export const ConvertResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          properties: {
            content: {
              type: 'string',
              description: 'Converted markdown content',
            },
          },
        },
      },
    },
  ],
} as const;

export const MediaGenerationModelCapabilitiesSchema = {
  type: 'object',
  properties: {
    image: {
      type: 'boolean',
      description: 'Whether this model supports image generation',
    },
    video: {
      type: 'boolean',
      description: 'Whether this model supports video generation',
    },
    audio: {
      type: 'boolean',
      description: 'Whether this model supports audio generation',
    },
  },
} as const;

export const ModelCapabilitiesSchema = {
  type: 'object',
  properties: {
    functionCall: {
      type: 'boolean',
      description: 'Whether this model supports function calling',
    },
    vision: {
      type: 'boolean',
      description: 'Whether this model can take images as input',
    },
    reasoning: {
      type: 'boolean',
      description: 'Whether this model includes reasoning content',
    },
    contextCaching: {
      type: 'boolean',
      description: 'Whether this model supports context caching',
    },
    supportToolChoice: {
      type: 'boolean',
      description: 'Whether this model supports tool_choice parameter',
    },
    image: {
      type: 'boolean',
      description: 'Whether this model supports image generation',
    },
    video: {
      type: 'boolean',
      description: 'Whether this model supports video generation',
    },
    audio: {
      type: 'boolean',
      description: 'Whether this model supports audio generation',
    },
  },
} as const;

export const ModelInfoSchema = {
  type: 'object',
  required: ['name', 'label', 'provider', 'contextLimit', 'maxOutput'],
  properties: {
    name: {
      type: 'string',
      description: 'Model name',
    },
    label: {
      type: 'string',
      description: 'Model label',
    },
    provider: {
      type: 'string',
      description: 'Model provider',
    },
    providerItemId: {
      type: 'string',
      description: 'Model provider item ID',
    },
    tier: {
      type: 'string',
      description: 'Model tier',
      $ref: '#/components/schemas/ModelTier',
    },
    contextLimit: {
      type: 'number',
      description: 'Model context limit (in tokens)',
    },
    maxOutput: {
      type: 'number',
      description: 'Model max output length (in tokens)',
    },
    capabilities: {
      description: 'Model capabilities',
      $ref: '#/components/schemas/ModelCapabilities',
    },
    isDefault: {
      type: 'boolean',
      description: 'Whether this model is the default model',
    },
    group: {
      type: 'string',
      description: 'Model group',
    },
    category: {
      type: 'string',
      description: 'Model category',
      $ref: '#/components/schemas/ProviderCategory',
    },
    creditBilling: {
      $ref: '#/components/schemas/CreditBilling',
      description: 'Credit billing info',
    },
    tooltip: {
      type: 'string',
      description: 'Tooltip text for the model (e.g., "Smart Routing")',
    },
    inputParameters: {
      type: 'array',
      description: 'Input parameter configurations',
      items: {
        $ref: '#/components/schemas/MediaModelParameter',
      },
    },
  },
} as const;

export const ListModelsResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Model list',
          items: {
            $ref: '#/components/schemas/ModelInfo',
          },
        },
      },
    },
  ],
} as const;

export const ProviderCategorySchema = {
  type: 'string',
  enum: [
    'llm',
    'embedding',
    'reranker',
    'webSearch',
    'urlParsing',
    'pdfParsing',
    'mediaGeneration',
  ],
} as const;

export const ProviderSchema = {
  type: 'object',
  description: 'General provider info',
  required: ['providerId', 'providerKey', 'categories', 'name', 'enabled'],
  properties: {
    providerId: {
      type: 'string',
      description: 'Provider ID',
    },
    providerKey: {
      type: 'string',
      description: 'Provider key',
    },
    name: {
      type: 'string',
      description: 'Provider name',
    },
    categories: {
      type: 'array',
      description: 'Provider categories',
      items: {
        $ref: '#/components/schemas/ProviderCategory',
      },
    },
    baseUrl: {
      type: 'string',
      description: 'Provider base URL',
    },
    enabled: {
      type: 'boolean',
      description: 'Whether the provider is enabled',
    },
    isGlobal: {
      type: 'boolean',
      description: 'Whether the provider is global',
    },
    apiKey: {
      type: 'string',
      description: 'Provider API key (this will never be exposed to the frontend)',
    },
  },
} as const;

export const LLMModelConfigSchema = {
  type: 'object',
  description: 'Provider config for LLMs',
  required: ['modelId', 'modelName'],
  properties: {
    modelId: {
      type: 'string',
      description: 'Model ID',
    },
    modelName: {
      type: 'string',
      description: 'Model name',
    },
    contextLimit: {
      type: 'number',
      description: 'Model context limit (in tokens)',
    },
    maxOutput: {
      type: 'number',
      description: 'Model max output length (in tokens)',
    },
    disallowTemperature: {
      type: 'boolean',
      description: 'Whether the model disallow setting custom temperature',
    },
    capabilities: {
      description: 'Model capabilities',
      $ref: '#/components/schemas/ModelCapabilities',
    },
    tooltip: {
      type: 'string',
      description: 'Tooltip text for the model (e.g., "Smart Routing")',
    },
  },
} as const;

export const MediaModelParameterSchema = {
  type: 'object',
  description: 'Media generation parameter configuration',
  required: ['name', 'type', 'required', 'visible'],
  properties: {
    name: {
      type: 'string',
      description: 'Parameter name',
    },
    type: {
      type: 'string',
      description: 'Parameter type',
      enum: ['url', 'text', 'option'],
    },
    value: {
      oneOf: [
        {
          type: 'string',
          description: 'String value for url/text type or option value',
        },
        {
          type: 'array',
          description: 'Array of URLs for url type',
          items: {
            type: 'string',
          },
        },
        {
          type: 'number',
          description: 'Numeric value for option type',
        },
        {
          type: 'integer',
          description: 'Integer value for option type',
        },
        {
          type: 'boolean',
          description: 'Boolean value for option type',
        },
      ],
    },
    options: {
      type: 'array',
      description: 'Available options for option type',
      items: {
        oneOf: [
          {
            type: 'string',
            description: 'String option',
          },
          {
            type: 'number',
            description: 'Numeric option',
          },
          {
            type: 'integer',
            description: 'Integer option',
          },
          {
            type: 'boolean',
            description: 'Boolean option',
          },
        ],
      },
    },
    description: {
      type: 'string',
      description: 'Parameter description',
    },
    required: {
      type: 'boolean',
      description: 'Whether this parameter is required',
    },
    visible: {
      type: 'boolean',
      description: 'Whether this parameter should be displayed in UI',
    },
  },
} as const;

export const MediaGenerationModelConfigSchema = {
  type: 'object',
  description: 'Provider config for media generation',
  required: ['modelId', 'modelName'],
  properties: {
    modelId: {
      type: 'string',
      description: 'Model ID',
    },
    modelName: {
      type: 'string',
      description: 'Model name',
    },
    capabilities: {
      description: 'Model capabilities',
      $ref: '#/components/schemas/MediaGenerationModelCapabilities',
    },
    description: {
      type: 'string',
      description: 'Model description',
    },
    tooltip: {
      type: 'string',
      description: 'Tooltip text for the model (e.g., "Smart Routing")',
    },
    supportedLanguages: {
      type: 'array',
      description: 'Supported languages for translation',
      items: {
        type: 'string',
        example: ['en', 'zh', 'ja', 'ko'],
      },
    },
    inputParameters: {
      type: 'array',
      description: 'Input parameter configurations',
      items: {
        $ref: '#/components/schemas/MediaModelParameter',
      },
    },
    outputParameters: {
      type: 'array',
      description: 'Output parameter configurations',
      items: {
        $ref: '#/components/schemas/MediaModelParameter',
      },
    },
    baseModel: {
      type: 'string',
      description: 'Base model for the model',
    },
  },
} as const;

export const EmbeddingModelConfigSchema = {
  type: 'object',
  description: 'Provider config for embeddings',
  required: ['modelId', 'dimensions'],
  properties: {
    modelId: {
      type: 'string',
      description: 'Embedding model ID',
    },
    modelName: {
      type: 'string',
      description: 'Embedding model name',
    },
    dimensions: {
      type: 'number',
      description: 'Embedding model dimension',
    },
    batchSize: {
      type: 'number',
      description: 'Embedding model batch size',
    },
  },
} as const;

export const RerankerModelConfigSchema = {
  type: 'object',
  description: 'Provider config for rerankers',
  required: ['modelId'],
  properties: {
    modelId: {
      type: 'string',
      description: 'Reranking model ID',
    },
    modelName: {
      type: 'string',
      description: 'Reranking model name',
    },
    topN: {
      type: 'number',
      description: 'Number of top results to return',
    },
    relevanceThreshold: {
      type: 'number',
      description: 'Minimum relevance score threshold (0.0-1.0)',
    },
  },
} as const;

export const ProviderItemConfigSchema = {
  oneOf: [
    {
      $ref: '#/components/schemas/LLMModelConfig',
    },
    {
      $ref: '#/components/schemas/EmbeddingModelConfig',
    },
    {
      $ref: '#/components/schemas/RerankerModelConfig',
    },
    {
      $ref: '#/components/schemas/MediaGenerationModelConfig',
    },
  ],
} as const;

export const CreditBillingSchema = {
  type: 'object',
  description: 'Credit billing configuration for provider items',
  required: ['unit', 'inputCost', 'outputCost', 'minCharge'],
  properties: {
    unit: {
      type: 'string',
      description: 'Measurement unit (e.g., token, product, second)',
      example: '5k_tokens',
    },
    inputCost: {
      type: 'number',
      description: 'Credit consumption per unit for input tokens',
      minimum: 0,
    },
    outputCost: {
      type: 'number',
      description: 'Credit consumption per unit for output tokens',
      minimum: 0,
    },
    cacheReadCost: {
      type: 'number',
      description:
        'Credit consumption per unit for cache read tokens (typically 10% of input cost)',
      minimum: 0,
    },
    cacheWriteCost: {
      type: 'number',
      description:
        'Credit consumption per unit for cache write tokens (typically higher than input cost)',
      minimum: 0,
    },
    minCharge: {
      type: 'number',
      description: 'Minimum credit charge per request',
      minimum: 0,
    },
    isEarlyBirdFree: {
      type: 'boolean',
      description: 'Whether this billing is free for early bird users',
      default: false,
    },
  },
} as const;

export const ProviderItemOptionSchema = {
  type: 'object',
  properties: {
    name: {
      type: 'string',
      description: 'Provider item name',
    },
    category: {
      description: 'Provider category',
      $ref: '#/components/schemas/ProviderCategory',
    },
    tier: {
      type: 'string',
      description: 'Provider item tier',
      $ref: '#/components/schemas/ModelTier',
    },
    config: {
      type: 'object',
      description: 'Provider item config',
      $ref: '#/components/schemas/ProviderItemConfig',
    },
  },
} as const;

export const ProviderItemSchema = {
  type: 'object',
  required: ['itemId', 'name', 'providerId', 'category', 'enabled'],
  properties: {
    itemId: {
      type: 'string',
      description: 'Provider item ID',
    },
    name: {
      type: 'string',
      description: 'Provider item name',
    },
    enabled: {
      type: 'boolean',
      description: 'Whether the provider item is enabled',
    },
    category: {
      description: 'Provider category',
      $ref: '#/components/schemas/ProviderCategory',
    },
    tier: {
      description: 'Provider item tier',
      $ref: '#/components/schemas/ModelTier',
    },
    providerId: {
      type: 'string',
      description: 'Provider ID',
    },
    provider: {
      type: 'object',
      description: 'Provider detail info',
      $ref: '#/components/schemas/Provider',
    },
    config: {
      description: 'Provider item config',
      $ref: '#/components/schemas/ProviderItemConfig',
    },
    order: {
      type: 'number',
      description: 'Provider item order',
    },
    group: {
      type: 'string',
      description: 'Provider item group',
    },
    creditBilling: {
      description: 'Credit billing info',
      $ref: '#/components/schemas/CreditBilling',
    },
  },
} as const;

export const CreditRechargeSchema = {
  type: 'object',
  description: 'Credit recharge record for user balance management',
  required: [
    'rechargeId',
    'uid',
    'amount',
    'balance',
    'enabled',
    'expiresAt',
    'createdAt',
    'updatedAt',
  ],
  properties: {
    rechargeId: {
      type: 'string',
      description: 'Unique recharge record ID',
    },
    uid: {
      type: 'string',
      description: 'User UID who owns this recharge record',
    },
    amount: {
      type: 'integer',
      description: 'Original recharge amount in credits',
      minimum: 0,
    },
    balance: {
      type: 'integer',
      description: 'Remaining balance for this recharge record',
      minimum: 0,
    },
    enabled: {
      type: 'boolean',
      description: 'Whether this recharge record is enabled (false after 30 days)',
      default: true,
    },
    source: {
      type: 'string',
      description: 'Recharge source type',
      enum: ['subscription', 'purchase', 'gift', 'promotion', 'refund', 'commission'],
      default: 'purchase',
    },
    description: {
      type: 'string',
      description: 'Optional description for this recharge',
    },
    appId: {
      type: 'string',
      description: 'Related app ID (if applicable)',
    },
    extraData: {
      type: 'string',
      description: 'Extra data for this recharge (JSON)',
      $ref: '#/components/schemas/CreditRechargeExtraData',
    },
    shareId: {
      type: 'string',
      description: 'Related share ID (if applicable)',
    },
    title: {
      type: 'string',
      description: 'Related share title (if applicable)',
    },
    expiresAt: {
      type: 'string',
      format: 'date-time',
      description: 'Expiration timestamp (30 days from creation)',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Record creation timestamp',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Record last update timestamp',
    },
  },
} as const;

export const CreditUsageSchema = {
  type: 'object',
  description: 'Credit usage record for tracking consumption',
  required: ['usageId', 'uid', 'amount', 'usageType', 'createdAt'],
  properties: {
    usageId: {
      type: 'string',
      description: 'Unique usage record ID',
    },
    uid: {
      type: 'string',
      description: 'User UID who consumed the credits',
    },
    amount: {
      type: 'integer',
      description: 'Amount of credits consumed',
      minimum: 0,
    },
    providerItemId: {
      type: 'string',
      description: 'Provider item ID that consumed the credits',
    },
    modelName: {
      type: 'string',
      description: 'Model name used for this consumption',
    },
    usageType: {
      type: 'string',
      description: 'Type of usage that consumed credits',
      enum: ['model_call', 'media_generation', 'embedding', 'reranking', 'commission', 'other'],
      default: 'model_call',
    },
    actionResultId: {
      type: 'string',
      description: 'Related action result ID (if applicable)',
    },
    pilotSessionId: {
      type: 'string',
      description: 'Related pilot session ID (if applicable)',
    },
    description: {
      type: 'string',
      description: 'Optional description for this usage',
    },
    modelUsageDetails: {
      type: 'string',
      description: 'Model usage details for skill execution (JSON array of model usage)',
    },
    appId: {
      type: 'string',
      description: 'Related app ID (if applicable)',
    },
    extraData: {
      type: 'string',
      description: 'Extra data for this usage (JSON)',
      $ref: '#/components/schemas/CreditUsageExtraData',
    },
    shareId: {
      type: 'string',
      description: 'Related share ID (if applicable)',
    },
    title: {
      type: 'string',
      description: 'Related share title (if applicable)',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Usage record creation timestamp',
    },
  },
} as const;

export const CreditRechargeExtraDataSchema = {
  type: 'object',
  description: 'Extra data for credit recharge',
  properties: {
    appId: {
      type: 'string',
      description: 'Related app ID',
    },
    executionId: {
      type: 'string',
      description: 'Related execution ID',
    },
    shareId: {
      type: 'string',
      description: 'Related share ID',
    },
    title: {
      type: 'string',
      description: 'Related share title',
    },
    commissionRate: {
      type: 'number',
      description: 'Commission rate',
    },
  },
} as const;

export const CreditUsageExtraDataSchema = {
  type: 'object',
  description: 'Extra data for credit usage',
  properties: {
    appId: {
      type: 'string',
      description: 'Related app ID (if applicable)',
    },
    executionId: {
      type: 'string',
      description: 'Related execution ID',
    },
    shareId: {
      type: 'string',
      description: 'Related share ID',
    },
    title: {
      type: 'string',
      description: 'Related share title',
    },
    commissionRate: {
      type: 'number',
      description: 'Commission rate',
    },
    toolsetKey: {
      type: 'string',
      description: 'Related toolset key',
    },
    toolsetName: {
      type: 'string',
      description: 'Related toolset name',
    },
    toolKey: {
      type: 'string',
      description: 'Related tool key',
    },
    toolName: {
      type: 'string',
      description: 'Related tool name',
    },
  },
} as const;

export const ListProvidersResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          items: {
            $ref: '#/components/schemas/Provider',
          },
        },
      },
    },
  ],
} as const;

export const UpsertProviderRequestSchema = {
  type: 'object',
  properties: {
    providerId: {
      type: 'string',
      description: 'Provider ID (only for update)',
    },
    providerKey: {
      type: 'string',
      description: 'Provider key',
    },
    name: {
      type: 'string',
      description: 'Provider name',
    },
    categories: {
      type: 'array',
      description: 'Provider categories',
      items: {
        $ref: '#/components/schemas/ProviderCategory',
      },
    },
    apiKey: {
      type: 'string',
      description: 'Provider API key',
    },
    baseUrl: {
      type: 'string',
      description: 'Provider base URL',
    },
    enabled: {
      type: 'boolean',
      description: 'Whether the provider is enabled',
    },
  },
} as const;

export const UpsertProviderResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/Provider',
        },
      },
    },
  ],
} as const;

export const DeleteProviderRequestSchema = {
  type: 'object',
  required: ['providerId'],
  properties: {
    providerId: {
      type: 'string',
      description: 'Provider ID',
    },
  },
} as const;

export const TestProviderConnectionRequestSchema = {
  type: 'object',
  required: ['providerId'],
  properties: {
    providerId: {
      type: 'string',
      description: 'Provider ID to test',
    },
    category: {
      description: 'Provider category to test (optional)',
      $ref: '#/components/schemas/ProviderCategory',
    },
  },
} as const;

export const ProviderTestResultSchema = {
  type: 'object',
  properties: {
    providerId: {
      type: 'string',
      description: 'Provider ID',
    },
    providerKey: {
      type: 'string',
      description: 'Provider key',
    },
    name: {
      type: 'string',
      description: 'Provider name',
    },
    baseUrl: {
      type: 'string',
      description: 'Provider base URL',
    },
    categories: {
      type: 'array',
      description: 'Provider categories',
      items: {
        type: 'string',
      },
    },
    status: {
      type: 'string',
      description: 'Test result status',
      enum: ['success', 'failed', 'unknown'],
    },
    message: {
      type: 'string',
      description: 'Test result message',
    },
    details: {
      type: 'object',
      description: 'Detailed test results',
      additionalProperties: true,
    },
    timestamp: {
      type: 'string',
      description: 'Test timestamp',
      format: 'date-time',
    },
  },
} as const;

export const TestProviderConnectionResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/ProviderTestResult',
        },
      },
    },
  ],
} as const;

export const ListProviderItemOptionsResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          items: {
            $ref: '#/components/schemas/ProviderItemOption',
          },
        },
      },
    },
  ],
} as const;

export const ListProviderItemsResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          items: {
            $ref: '#/components/schemas/ProviderItem',
          },
        },
      },
    },
  ],
} as const;

export const UpsertProviderItemRequestSchema = {
  type: 'object',
  properties: {
    itemId: {
      type: 'string',
      description: 'Provider item ID (only for update)',
    },
    providerId: {
      type: 'string',
      description: 'Provider ID',
    },
    globalItemId: {
      type: 'string',
      description: 'Global provider item ID',
    },
    name: {
      type: 'string',
      description: 'Provider item name',
    },
    category: {
      description: 'Provider category',
      $ref: '#/components/schemas/ProviderCategory',
    },
    enabled: {
      type: 'boolean',
      description: 'Whether the provider item is enabled',
    },
    config: {
      description: 'Provider item config',
      $ref: '#/components/schemas/ProviderItemConfig',
    },
    order: {
      type: 'number',
      description: 'Provider item order',
    },
    group: {
      type: 'string',
      description: 'Provider item group',
    },
  },
} as const;

export const UpsertProviderItemResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/ProviderItem',
        },
      },
    },
  ],
} as const;

export const BatchUpsertProviderItemsRequestSchema = {
  type: 'object',
  required: ['items'],
  properties: {
    items: {
      type: 'array',
      description: 'Provider items to upsert',
      items: {
        $ref: '#/components/schemas/UpsertProviderItemRequest',
      },
    },
  },
} as const;

export const BatchUpsertProviderItemsResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Upserted provider items',
          items: {
            $ref: '#/components/schemas/ProviderItem',
          },
        },
      },
    },
  ],
} as const;

export const DeleteProviderItemRequestSchema = {
  type: 'object',
  required: ['itemId'],
  properties: {
    itemId: {
      type: 'string',
      description: 'Provider item ID',
    },
  },
} as const;

export const ToolsetAuthTypeSchema = {
  type: 'string',
  description: 'Toolset auth type',
  enum: ['credentials', 'oauth', 'config_based'],
} as const;

export const ToolDefinitionSchema = {
  type: 'object',
  required: ['name', 'descriptionDict'],
  properties: {
    name: {
      type: 'string',
      description: 'Tool name',
    },
    descriptionDict: {
      type: 'object',
      additionalProperties: true,
      description: 'Tool description dictionary for humans',
    },
    modelOnly: {
      type: 'boolean',
      description: 'Whether the tool is only visible to model',
    },
  },
} as const;

export const AuthPatternSchema = {
  type: 'object',
  required: ['type', 'pattern'],
  properties: {
    type: {
      type: 'string',
      description: 'Auth pattern type',
      $ref: '#/components/schemas/ToolsetAuthType',
    },
    credentialItems: {
      type: 'array',
      description: 'Credential items, only for `credentials` type',
      items: {
        $ref: '#/components/schemas/DynamicConfigItem',
      },
    },
    provider: {
      type: 'string',
      description: 'Auth provider, only for `oauth` type',
    },
    scope: {
      type: 'array',
      description: 'Auth scope, only for `oauth` type',
      items: {
        type: 'string',
      },
    },
  },
} as const;

export const ToolsetDefinitionSchema = {
  type: 'object',
  required: ['key', 'labelDict', 'descriptionDict'],
  properties: {
    key: {
      type: 'string',
      description: 'Toolset key',
    },
    type: {
      $ref: '#/components/schemas/GenericToolsetType',
      description: 'Toolset type (regular, mcp, external_oauth)',
    },
    builtin: {
      type: 'boolean',
      description: 'Whether this is a builtin toolset',
    },
    internal: {
      type: 'boolean',
      description: 'Whether this is an internal toolset (cannot be selected manually)',
    },
    domain: {
      type: 'string',
      description: 'Toolset domain (used for display icon)',
    },
    labelDict: {
      type: 'object',
      additionalProperties: true,
      description: 'Toolset label dictionary',
    },
    descriptionDict: {
      type: 'object',
      additionalProperties: true,
      description: 'Toolset description dictionary for humans',
    },
    tools: {
      type: 'array',
      description: 'Toolset tools',
      items: {
        $ref: '#/components/schemas/ToolDefinition',
      },
    },
    requiresAuth: {
      type: 'boolean',
      description: 'Whether the toolset requires auth',
      default: false,
    },
    authPatterns: {
      type: 'array',
      description: 'Toolset auth patterns',
      items: {
        $ref: '#/components/schemas/AuthPattern',
      },
    },
    configItems: {
      type: 'array',
      description: 'Toolset config items',
      items: {
        $ref: '#/components/schemas/DynamicConfigItem',
      },
    },
  },
} as const;

export const ToolsetInstanceSchema = {
  type: 'object',
  required: ['toolsetId', 'name', 'key'],
  properties: {
    toolsetId: {
      type: 'string',
      description: 'Toolset ID',
    },
    name: {
      type: 'string',
      description: 'Toolset name',
    },
    key: {
      type: 'string',
      description: 'Toolset key',
    },
    isGlobal: {
      type: 'boolean',
      description: 'Whether the toolset is global',
    },
    enabled: {
      type: 'boolean',
      description: 'Whether the toolset is enabled',
    },
    authType: {
      $ref: '#/components/schemas/ToolsetAuthType',
      description: 'Toolset auth type',
    },
    authData: {
      type: 'object',
      additionalProperties: true,
      description: 'Toolset auth data',
    },
    config: {
      type: 'object',
      additionalProperties: true,
      description: 'Toolset config',
    },
    definition: {
      description: 'Toolset definition',
      $ref: '#/components/schemas/ToolsetDefinition',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Toolset creation timestamp',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Toolset update timestamp',
    },
  },
} as const;

export const ListToolsetInventoryResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          items: {
            $ref: '#/components/schemas/ToolsetDefinition',
          },
        },
      },
    },
  ],
} as const;

export const ListToolsetsResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          items: {
            $ref: '#/components/schemas/ToolsetInstance',
          },
        },
      },
    },
  ],
} as const;

export const UpsertToolsetRequestSchema = {
  type: 'object',
  properties: {
    toolsetId: {
      type: 'string',
      description: 'Toolset ID (only for update)',
    },
    name: {
      type: 'string',
      description: 'Toolset name',
    },
    key: {
      type: 'string',
      description: 'Toolset key',
    },
    enabled: {
      type: 'boolean',
      description: 'Whether the toolset is enabled',
    },
    authType: {
      $ref: '#/components/schemas/ToolsetAuthType',
      description: 'Toolset auth type',
    },
    authData: {
      type: 'object',
      additionalProperties: true,
      description: 'Toolset auth data',
    },
    config: {
      type: 'object',
      additionalProperties: true,
      description: 'Toolset config',
    },
    provider: {
      type: 'string',
      description: 'OAuth toolset provider',
    },
    scope: {
      type: 'array',
      description: 'OAuth toolset scope',
      items: {
        type: 'string',
      },
    },
  },
} as const;

export const UpsertToolsetResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/ToolsetInstance',
        },
      },
    },
  ],
} as const;

export const InitiateComposioConnectionResponseSchema = {
  type: 'object',
  required: ['redirectUrl', 'connectionRequestId', 'app'],
  properties: {
    redirectUrl: {
      type: 'string',
      format: 'uri',
      description: 'OAuth redirect URL provided by Composio.',
    },
    connectionRequestId: {
      type: 'string',
      description: 'Connection request identifier from Composio.',
    },
    app: {
      type: 'string',
      description: 'Composio app slug (e.g., gmail, slack).',
    },
  },
} as const;

export const ComposioConnectionStatusSchema = {
  type: 'string',
  description: 'Current status of the Composio connection.',
  enum: ['active', 'revoked'],
} as const;

export const ComposioConnectionStatusResponseSchema = {
  type: 'object',
  required: ['status', 'integrationId'],
  properties: {
    status: {
      $ref: '#/components/schemas/ComposioConnectionStatus',
    },
    connectedAccountId: {
      type: 'string',
      nullable: true,
      description: 'Connected account identifier returned by Composio, if available.',
    },
    integrationId: {
      type: 'string',
      description: 'Composio integration identifier (app slug).',
    },
  },
} as const;

export const ComposioRevokeResponseSchema = {
  type: 'object',
  required: ['success', 'message'],
  properties: {
    success: {
      type: 'boolean',
      description: 'Whether the connection was revoked successfully.',
    },
    message: {
      type: 'string',
      description: 'Human-readable message describing the outcome.',
    },
  },
} as const;

export const PostHandlerContextSchema = {
  type: 'object',
  description: 'Context for post-processing tool execution results',
  required: ['user', 'toolName', 'toolsetName', 'toolsetKey', 'creditCost'],
  properties: {
    user: {
      $ref: '#/components/schemas/User',
      description: 'User who executed the tool',
    },
    toolName: {
      type: 'string',
      description: 'Tool name that was executed',
    },
    toolsetName: {
      type: 'string',
      description: 'Toolset display name',
    },
    toolsetKey: {
      type: 'string',
      description: 'Toolset unique identifier/key',
    },
    creditCost: {
      type: 'number',
      description: 'Credit cost for this tool execution',
    },
    fileNameTitle: {
      type: 'string',
      description: 'File name title from input params',
    },
    resultId: {
      type: 'string',
      description: 'Result ID from execution context',
    },
    version: {
      type: 'number',
      description: 'Result version from execution context',
    },
  },
} as const;

export const PostHandlerResultSchema = {
  type: 'object',
  description: 'Result from post-processing tool execution',
  required: ['data'],
  properties: {
    data: {
      description: 'Processed data (may be uploaded to OSS)',
    },
    files: {
      type: 'array',
      description: 'Files uploaded during post-processing',
      items: {
        $ref: '#/components/schemas/DriveFile',
      },
    },
    creditCost: {
      type: 'number',
      description: 'Credit cost recorded',
    },
    metadata: {
      type: 'object',
      additionalProperties: true,
      description: 'Metadata about processing',
    },
  },
} as const;

export const ComposioConnectedAccountSchema = {
  type: 'object',
  description: 'Composio connected account structure from API response',
  required: ['id'],
  properties: {
    id: {
      type: 'string',
      description: 'Connected account ID',
    },
    status: {
      type: 'string',
      description: 'Connection status',
    },
    toolkit: {
      type: 'object',
      properties: {
        slug: {
          type: 'string',
          description: 'Toolkit slug identifier',
        },
      },
    },
  },
} as const;

export const ComposioToolSchemaSchema = {
  type: 'object',
  description: 'Composio tool JSON schema structure',
  properties: {
    type: {
      type: 'string',
      description: 'Schema type',
    },
    properties: {
      type: 'object',
      additionalProperties: {
        $ref: '#/components/schemas/ComposioSchemaProperty',
      },
      description: 'Schema properties',
    },
    required: {
      type: 'array',
      items: {
        type: 'string',
      },
      description: 'Required property names',
    },
  },
  additionalProperties: true,
} as const;

export const ComposioSchemaPropertySchema = {
  type: 'object',
  description: 'Composio schema property definition',
  properties: {
    type: {
      type: 'string',
      description: 'Property type',
    },
    description: {
      type: 'string',
      description: 'Property description',
    },
    deprecated: {
      type: 'boolean',
      description: 'Whether property is deprecated',
    },
  },
  additionalProperties: true,
} as const;

export const ToolCreationContextSchema = {
  type: 'object',
  description:
    'Context for creating a DynamicStructuredTool. User/userId comes from getCurrentUser() at runtime.',
  required: [
    'connectedAccountId',
    'authType',
    'creditCost',
    'toolsetType',
    'toolsetKey',
    'toolsetName',
  ],
  properties: {
    connectedAccountId: {
      type: 'string',
      description: 'Connected account ID from Composio',
    },
    authType: {
      type: 'string',
      enum: ['oauth', 'apikey'],
      description: 'Authentication type',
    },
    creditCost: {
      type: 'number',
      description: 'Credit cost for tool execution',
    },
    toolsetType: {
      $ref: '#/components/schemas/GenericToolsetType',
      description: 'Toolset type identifier',
    },
    toolsetKey: {
      type: 'string',
      description: 'Toolset key',
    },
    toolsetName: {
      type: 'string',
      description: 'Toolset display name',
    },
  },
} as const;

export const GenericToolsetTypeSchema = {
  type: 'string',
  enum: ['regular', 'mcp', 'external_oauth'],
} as const;

export const GenericToolsetSchema = {
  type: 'object',
  required: ['type', 'id', 'name'],
  properties: {
    type: {
      $ref: '#/components/schemas/GenericToolsetType',
      description: 'Toolset type',
    },
    id: {
      type: 'string',
      description: 'Toolset ID (toolsetId for regular toolset, name for MCP toolset)',
    },
    name: {
      type: 'string',
      description: 'Toolset name',
    },
    builtin: {
      type: 'boolean',
      description: 'Whether the toolset is builtin',
    },
    uninstalled: {
      type: 'boolean',
      description: 'Whether the toolset is uninstalled',
    },
    toolset: {
      $ref: '#/components/schemas/ToolsetInstance',
      description: 'Toolset detail',
    },
    mcpServer: {
      $ref: '#/components/schemas/McpServerDTO',
      description: 'MCP server',
    },
    selectedTools: {
      type: 'array',
      description: 'Selected tools (used for skill invocation)',
      items: {
        type: 'string',
      },
    },
  },
} as const;

export const ListToolsResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          items: {
            $ref: '#/components/schemas/GenericToolset',
          },
        },
      },
    },
  ],
} as const;

export const ListUserToolsResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          items: {
            $ref: '#/components/schemas/UserTool',
          },
        },
      },
    },
  ],
} as const;

export const UserToolSchema = {
  type: 'object',
  properties: {
    toolsetId: {
      type: 'string',
      description: 'Toolset ID (toolsetId for installed, key for uninstalled)',
    },
    key: {
      type: 'string',
      description: 'Toolset key',
    },
    name: {
      type: 'string',
      description: 'Tool name',
    },
    description: {
      type: 'string',
      description: 'Tool description',
    },
    authorized: {
      type: 'boolean',
      description: 'Whether the tool is authorized/installed',
    },
    domain: {
      type: 'string',
      description: 'Tool domain for favicon',
    },
    toolset: {
      $ref: '#/components/schemas/GenericToolset',
      description: 'Full toolset data (only for authorized tools)',
    },
    definition: {
      $ref: '#/components/schemas/ToolsetDefinition',
      description: 'Toolset definition (for unauthorized tools)',
    },
  },
} as const;

export const DeleteToolsetRequestSchema = {
  type: 'object',
  required: ['toolsetId'],
  properties: {
    toolsetId: {
      type: 'string',
      description: 'Toolset ID',
    },
  },
} as const;

export const GetToolCallResultResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          properties: {
            result: {
              $ref: '#/components/schemas/ToolCallResult',
            },
          },
        },
      },
    },
  ],
} as const;

export const DocumentInterfaceSchema = {
  type: 'object',
  properties: {
    id: {
      type: 'string',
      description:
        'An optional identifier for the document. Ideally this should be unique across the document collection and formatted as a UUID.',
    },
    pageContent: {
      type: 'string',
      description: 'The main content of the document.',
    },
    metadata: {
      type: 'object',
      additionalProperties: true,
      description: 'Metadata associated with the document.',
    },
  },
} as const;

export const InMemorySearchResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          items: {
            $ref: '#/components/schemas/DocumentInterface',
          },
        },
      },
    },
  ],
} as const;

export const CanvasNodeTypeSchema = {
  type: 'string',
  enum: [
    'document',
    'codeArtifact',
    'website',
    'resource',
    'skill',
    'file',
    'tool',
    'skillResponse',
    'toolResponse',
    'memo',
    'group',
    'image',
    'video',
    'audio',
    'mediaSkill',
    'mediaSkillResponse',
    'start',
  ],
} as const;

export const CanvasNodeDataSchema = {
  type: 'object',
  description: 'Node data',
  required: ['title', 'entityId'],
  properties: {
    title: {
      type: 'string',
      description: 'Node title',
    },
    editedTitle: {
      type: 'string',
      description: 'Node edited title',
      deprecated: true,
    },
    entityId: {
      type: 'string',
      description: 'Node entity ID',
    },
    contentPreview: {
      type: 'string',
      description: 'Node content preview',
    },
    metadata: {
      type: 'object',
      additionalProperties: true,
      description: 'Node metadata',
    },
  },
} as const;

export const XYPositionSchema = {
  type: 'object',
  required: ['x', 'y'],
  properties: {
    x: {
      type: 'number',
      description: 'Node position x',
    },
    y: {
      type: 'number',
      description: 'Node position y',
    },
  },
} as const;

export const CanvasNodeSchema = {
  type: 'object',
  required: ['id', 'type', 'position', 'data'],
  properties: {
    id: {
      type: 'string',
      description: 'Node ID',
    },
    type: {
      description: 'Node type',
      $ref: '#/components/schemas/CanvasNodeType',
    },
    position: {
      $ref: '#/components/schemas/XYPosition',
      description: 'Node position',
    },
    offsetPosition: {
      $ref: '#/components/schemas/XYPosition',
      description: 'Node offset position',
    },
    data: {
      type: 'object',
      description: 'Node data',
      $ref: '#/components/schemas/CanvasNodeData',
    },
    style: {
      type: 'object',
      description: 'Node style',
    },
    selected: {
      type: 'boolean',
      description: 'Whether the node is selected',
    },
    dragging: {
      type: 'boolean',
      description: 'Whether the node is being dragged',
    },
    parentId: {
      type: 'string',
      description: 'Parent node ID',
    },
  },
} as const;

export const CanvasEdgeSchema = {
  type: 'object',
  required: ['id', 'source', 'target', 'type'],
  properties: {
    id: {
      type: 'string',
      description: 'Edge ID',
    },
    source: {
      type: 'string',
      description: 'Edge source node ID',
    },
    target: {
      type: 'string',
      description: 'Edge target node ID',
    },
    type: {
      type: 'string',
      description: 'Edge type',
    },
  },
} as const;

export const InitializeWorkflowRequestSchema = {
  type: 'object',
  required: ['canvasId'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID to initialize workflow for',
      example: 'canvas-123',
    },
    sourceCanvasId: {
      type: 'string',
      description: 'Source canvas ID',
      example: 'canvas-456',
    },
    sourceCanvasData: {
      description: 'Source canvas data',
      $ref: '#/components/schemas/RawCanvasData',
    },
    createNewCanvas: {
      description: 'Whether to create a new canvas',
      type: 'boolean',
      default: false,
    },
    nodeBehavior: {
      description: 'Node behavior when executing workflow',
      type: 'string',
      enum: ['create', 'update'],
      default: 'update',
    },
    variables: {
      type: 'array',
      description: 'Workflow variables',
      items: {
        $ref: '#/components/schemas/WorkflowVariable',
      },
    },
    startNodes: {
      type: 'array',
      description: 'Start node IDs',
      items: {
        type: 'string',
        example: 'node-123',
      },
    },
  },
} as const;

export const InitializeWorkflowResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          required: ['workflowExecutionId'],
          properties: {
            workflowExecutionId: {
              type: 'string',
              description: 'Workflow execution ID',
              example: 'we-abc123',
            },
          },
        },
      },
    },
  ],
} as const;

export const AbortWorkflowRequestSchema = {
  type: 'object',
  required: ['executionId'],
  properties: {
    executionId: {
      type: 'string',
      description: 'Workflow execution ID to abort',
      example: 'we-abc123',
    },
  },
} as const;

export const WorkflowNodeExecutionSchema = {
  type: 'object',
  required: ['nodeId'],
  properties: {
    nodeExecutionId: {
      type: 'string',
      description: 'Node execution ID',
    },
    nodeId: {
      type: 'string',
      description: 'Node ID',
    },
    nodeType: {
      type: 'string',
      description: 'Node type',
    },
    nodeData: {
      type: 'string',
      description: 'Node data',
    },
    entityId: {
      type: 'string',
      description: 'Node entity ID',
    },
    newEntityId: {
      type: 'string',
      description: 'New node entity ID',
    },
    title: {
      type: 'string',
      description: 'Node title',
    },
    status: {
      description: 'Node status',
      $ref: '#/components/schemas/ActionStatus',
    },
    progress: {
      type: 'number',
      description: 'Node progress',
    },
    errorMessage: {
      type: 'string',
      description: 'Node error message',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Node creation timestamp',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Node update timestamp',
    },
  },
} as const;

export const WorkflowExecutionStatusSchema = {
  type: 'string',
  enum: ['init', 'executing', 'finish', 'failed'],
} as const;

export const WorkflowExecutionSchema = {
  type: 'object',
  required: ['executionId'],
  properties: {
    executionId: {
      type: 'string',
      description: 'Workflow execution ID',
    },
    canvasId: {
      type: 'string',
      description: 'Canvas ID',
    },
    title: {
      type: 'string',
      description: 'Workflow title',
    },
    status: {
      $ref: '#/components/schemas/WorkflowExecutionStatus',
      description: 'Workflow status',
    },
    abortedByUser: {
      type: 'boolean',
      description: 'Whether the workflow was aborted by user',
    },
    nodeExecutions: {
      type: 'array',
      description: 'Node executions',
      items: {
        $ref: '#/components/schemas/WorkflowNodeExecution',
      },
    },
    appId: {
      type: 'string',
      description: 'Workflow app ID',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Workflow creation timestamp',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Workflow update timestamp',
    },
  },
} as const;

export const WorkflowTaskSchema = {
  type: 'object',
  required: ['id', 'title', 'prompt', 'toolsets'],
  properties: {
    id: {
      type: 'string',
      description: 'Unique ID for the task',
    },
    title: {
      type: 'string',
      description: 'Display title for the task',
    },
    prompt: {
      type: 'string',
      description: 'The prompt or instruction for this task',
    },
    toolsets: {
      type: 'array',
      description: 'Toolsets selected for this task',
      items: {
        type: 'string',
        description: 'Toolset ID',
      },
    },
    dependentTasks: {
      type: 'array',
      description: 'Tasks that must be executed before this task',
      items: {
        type: 'string',
        description: 'Task ID',
      },
    },
  },
} as const;

export const WorkflowPlanSchema = {
  type: 'object',
  required: ['title', 'tasks'],
  properties: {
    title: {
      type: 'string',
      description: 'Title of the workflow plan',
    },
    tasks: {
      type: 'array',
      description: 'Array of workflow tasks to be executed',
      items: {
        $ref: '#/components/schemas/WorkflowTask',
      },
    },
    variables: {
      type: 'array',
      description: 'Array of variables (aka User inputs) defined for the workflow plan',
      items: {
        $ref: '#/components/schemas/WorkflowVariable',
      },
    },
  },
} as const;

export const WorkflowPlanRecordSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/WorkflowPlan',
    },
    {
      type: 'object',
      properties: {
        planId: {
          type: 'string',
          description: 'Workflow plan ID',
        },
        version: {
          type: 'number',
          description: 'Workflow plan version',
        },
        createdAt: {
          type: 'string',
          format: 'date-time',
          description: 'Workflow plan creation timestamp',
        },
        updatedAt: {
          type: 'string',
          format: 'date-time',
          description: 'Workflow plan update timestamp',
        },
      },
    },
  ],
} as const;

export const GetWorkflowPlanDetailResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/WorkflowPlanRecord',
        },
      },
    },
  ],
} as const;

export const GetWorkflowDetailResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'object',
          $ref: '#/components/schemas/WorkflowExecution',
        },
      },
    },
  ],
} as const;

export const CreateWorkflowAppRequestSchema = {
  type: 'object',
  required: ['canvasId', 'title', 'description', 'query', 'variables', 'coverStorageKey'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID',
    },
    title: {
      type: 'string',
      description: 'Workflow app title',
    },
    description: {
      type: 'string',
      description: 'Workflow app description',
    },
    query: {
      type: 'string',
      description: 'Workflow app query',
    },
    variables: {
      type: 'array',
      description: 'Workflow app variables',
      items: {
        $ref: '#/components/schemas/WorkflowVariable',
      },
    },
    resultNodeIds: {
      type: 'array',
      description: 'Result node IDs',
      items: {
        type: 'string',
      },
    },
    coverStorageKey: {
      type: 'string',
      description: 'Cover image storage key',
    },
    remixEnabled: {
      type: 'boolean',
      description: 'Whether remix is enabled for this app',
    },
    publishToCommunity: {
      type: 'boolean',
      description: 'Whether to publish this app to the community',
    },
  },
} as const;

export const DeleteWorkflowAppRequestSchema = {
  type: 'object',
  required: ['appId'],
  properties: {
    appId: {
      type: 'string',
      description: 'Workflow app ID',
    },
  },
} as const;

export const WorkflowAppSchema = {
  type: 'object',
  required: ['appId', 'canvasId', 'variables'],
  properties: {
    appId: {
      type: 'string',
      description: 'Workflow app ID',
    },
    shareId: {
      type: 'string',
      description: 'Share ID for public access and URL generation',
    },
    title: {
      type: 'string',
      description: 'Workflow app title',
    },
    description: {
      type: 'string',
      description: 'Workflow app description',
    },
    owner: {
      description: 'Workflow app owner',
      $ref: '#/components/schemas/ShareUser',
    },
    canvasId: {
      type: 'string',
      description: 'Canvas ID',
    },
    query: {
      type: 'string',
      description: 'Workflow app query',
    },
    variables: {
      type: 'array',
      description: 'Workflow app variables',
      items: {
        $ref: '#/components/schemas/WorkflowVariable',
      },
    },
    resultNodeIds: {
      type: 'array',
      description: 'Result node IDs',
      items: {
        type: 'string',
      },
    },
    remixEnabled: {
      type: 'boolean',
      description: 'Whether remix is enabled for this app',
    },
    coverUrl: {
      type: 'string',
      description: 'Cover image URL',
    },
    publishToCommunity: {
      type: 'boolean',
      description: 'Whether to publish this app to the community',
    },
    publishReviewStatus: {
      type: 'string',
      description: 'Community publish review status',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Workflow app creation timestamp',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Workflow app update timestamp',
    },
    voucherTriggerResult: {
      $ref: '#/components/schemas/VoucherTriggerResult',
      description: 'Voucher trigger result when publishing to community',
    },
  },
} as const;

export const CreateWorkflowAppResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/WorkflowApp',
        },
      },
    },
  ],
} as const;

export const GetWorkflowAppDetailResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/WorkflowApp',
        },
      },
    },
  ],
} as const;

export const ListWorkflowAppsResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'List of workflow apps',
          items: {
            $ref: '#/components/schemas/WorkflowApp',
          },
        },
      },
    },
  ],
} as const;

export const TemplateGenerationStatusSchema = {
  type: 'string',
  description: 'Template generation status',
  enum: ['idle', 'pending', 'generating', 'completed', 'failed'],
  example: 'completed',
} as const;

export const GetTemplateGenerationStatusResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      required: ['data'],
      properties: {
        data: {
          type: 'object',
          required: ['status', 'updatedAt', 'createdAt'],
          properties: {
            status: {
              $ref: '#/components/schemas/TemplateGenerationStatus',
            },
            templateContent: {
              type: 'string',
              nullable: true,
              description: 'Generated template content',
            },
            error: {
              type: 'string',
              nullable: true,
              description: 'Error message if generation failed',
            },
            updatedAt: {
              type: 'string',
              format: 'date-time',
              description: 'Last update time',
            },
            createdAt: {
              type: 'string',
              format: 'date-time',
              description: 'Creation time',
            },
          },
        },
      },
    },
  ],
} as const;

export const ExecuteWorkflowAppRequestSchema = {
  type: 'object',
  required: ['shareId', 'variables'],
  properties: {
    shareId: {
      type: 'string',
      description: 'Workflow app share ID for execution',
    },
    variables: {
      type: 'array',
      description: 'Workflow app variables',
      items: {
        $ref: '#/components/schemas/WorkflowVariable',
      },
    },
  },
} as const;

export const ExecuteWorkflowAppResultSchema = {
  type: 'object',
  required: ['executionId'],
  properties: {
    executionId: {
      type: 'string',
      description: 'Workflow execution ID',
    },
  },
} as const;

export const ExecuteWorkflowAppResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/ExecuteWorkflowAppResult',
        },
      },
    },
  ],
} as const;

export const ValueTypeSchema = {
  type: 'string',
  enum: ['text', 'resource'],
} as const;

export const ResourceValueSchema = {
  type: 'object',
  required: ['name', 'fileType'],
  properties: {
    name: {
      type: 'string',
      description: 'Resource name',
    },
    fileType: {
      description: 'Resource file type',
      $ref: '#/components/schemas/VariableResourceType',
    },
    fileId: {
      type: 'string',
      description: 'DriveFile ID (primary identifier for resource)',
    },
    storageKey: {
      type: 'string',
      description: 'Resource storage key (legacy, for backward compatibility)',
    },
    entityId: {
      type: 'string',
      description: 'Resource ID (deprecated, use fileId instead)',
    },
  },
} as const;

export const VariableValueSchema = {
  type: 'object',
  required: ['type'],
  properties: {
    type: {
      description: 'Variable type',
      $ref: '#/components/schemas/ValueType',
    },
    text: {
      type: 'string',
      description: 'Variable text value (for text type)',
    },
    resource: {
      description: 'Variable resource value (for resource type)',
      $ref: '#/components/schemas/ResourceValue',
    },
  },
} as const;

export const VariableResourceTypeSchema = {
  type: 'string',
  enum: ['document', 'image', 'video', 'audio'],
} as const;

export const WorkflowVariableSchema = {
  type: 'object',
  description: 'Workflow variable definition',
  required: ['name', 'value', 'variableId'],
  properties: {
    variableId: {
      type: 'string',
      description: 'Variable ID, unique and readonly',
    },
    name: {
      type: 'string',
      description: 'Variable name used in the workflow',
    },
    value: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/VariableValue',
      },
      description: 'Variable values',
    },
    description: {
      type: 'string',
      description: 'Variable description',
      example: '',
    },
    createdAt: {
      type: 'string',
      description: 'Variable created at',
      example: '2021-01-01T00:00:00.000Z',
    },
    updatedAt: {
      type: 'string',
      description: 'Variable updated at',
      example: '2021-01-01T00:00:00.000Z',
    },
    variableType: {
      type: 'string',
      description: 'Variable type',
      enum: ['string', 'option', 'resource'],
    },
    required: {
      type: 'boolean',
      description: 'Whether the variable is required. Defaults to false.',
    },
    isSingle: {
      type: 'boolean',
      description: 'Whether the variable value is single (not multiple)',
    },
    options: {
      type: 'array',
      items: {
        type: 'string',
      },
      description: 'Array of options (only valid when variable type is `option`)',
    },
    resourceTypes: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/VariableResourceType',
      },
      description: 'Supported resource types (only valid when variable type is resource)',
    },
  },
} as const;

export const GetWorkflowVariablesResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'List of workflow variables',
          items: {
            $ref: '#/components/schemas/WorkflowVariable',
          },
        },
      },
    },
  ],
} as const;

export const UpdateWorkflowVariablesRequestSchema = {
  type: 'object',
  required: ['canvasId', 'variables'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID',
    },
    variables: {
      type: 'array',
      description: 'List of workflow variables',
      items: {
        $ref: '#/components/schemas/WorkflowVariable',
      },
    },
    archiveOldFiles: {
      type: 'boolean',
      description:
        'Whether to archive existing drive files associated with old resource variables before updating',
    },
  },
} as const;

export const UpdateWorkflowVariablesResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'Updated list of workflow variables',
          items: {
            $ref: '#/components/schemas/WorkflowVariable',
          },
        },
      },
    },
  ],
} as const;

export const DriveFileCategorySchema = {
  type: 'string',
  enum: ['document', 'image', 'video', 'audio', 'others'],
} as const;

export const DriveFileSourceSchema = {
  type: 'string',
  enum: ['manual', 'variable', 'agent'],
} as const;

export const DriveFileScopeSchema = {
  type: 'string',
  enum: ['present', 'archive'],
} as const;

export const DriveFileSchema = {
  type: 'object',
  required: ['fileId', 'canvasId', 'name', 'type'],
  properties: {
    fileId: {
      type: 'string',
      description: 'Drive file ID',
    },
    canvasId: {
      type: 'string',
      description: 'Canvas ID',
    },
    name: {
      type: 'string',
      description: 'Drive file name',
    },
    type: {
      type: 'string',
      description: 'Drive file type',
    },
    category: {
      $ref: '#/components/schemas/DriveFileCategory',
      description: 'Drive file category',
    },
    source: {
      $ref: '#/components/schemas/DriveFileSource',
      description: 'Drive file source',
    },
    scope: {
      $ref: '#/components/schemas/DriveFileScope',
      description: 'Drive file scope',
    },
    size: {
      type: 'number',
      description: 'Drive file size',
    },
    summary: {
      type: 'string',
      description: 'Drive file summary',
    },
    storageKey: {
      type: 'string',
      description: 'Object storage key for the file',
    },
    variableId: {
      type: 'string',
      description: 'Related variable ID',
    },
    resultId: {
      type: 'string',
      description: 'Action result ID',
    },
    resultVersion: {
      type: 'number',
      description: 'Action result version',
    },
    content: {
      type: 'string',
      description: 'Drive file content (only used for model input)',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Drive file creation timestamp',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Drive file update timestamp',
    },
    url: {
      type: 'string',
      description: 'Private access URL for the file (requires authentication)',
    },
  },
} as const;

export const ListDriveFilesResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'List of drive files',
          items: {
            $ref: '#/components/schemas/DriveFile',
          },
        },
      },
    },
  ],
} as const;

export const UpsertDriveFileRequestSchema = {
  type: 'object',
  required: ['canvasId', 'name'],
  properties: {
    fileId: {
      type: 'string',
      description: 'File ID (required for update)',
    },
    canvasId: {
      type: 'string',
      description: 'Canvas ID',
    },
    name: {
      type: 'string',
      description: 'Drive file name',
    },
    type: {
      type: 'string',
      description: 'Drive file type (MIME type)',
    },
    summary: {
      type: 'string',
      description: 'Brief summary for this file',
    },
    content: {
      type: 'string',
      description: 'File content (for plain text files)',
    },
    storageKey: {
      type: 'string',
      description: 'File storage key (for uploaded files)',
    },
    externalUrl: {
      type: 'string',
      description: 'External URL to download from',
    },
    source: {
      $ref: '#/components/schemas/DriveFileSource',
      description: 'File source',
    },
    variableId: {
      type: 'string',
      description: 'Related variable ID',
    },
    resultId: {
      type: 'string',
      description: 'Related agent result ID',
    },
    resultVersion: {
      type: 'number',
      description: 'Related agent result version',
    },
    archiveFiles: {
      type: 'boolean',
      description:
        'Whether to archive existing files with the same variableId or resultId before creating new file',
    },
  },
} as const;

export const BatchCreateDriveFilesRequestSchema = {
  type: 'object',
  required: ['canvasId', 'files'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID',
    },
    files: {
      type: 'array',
      description: 'List of drive files',
      items: {
        $ref: '#/components/schemas/UpsertDriveFileRequest',
      },
    },
  },
} as const;

export const BatchCreateDriveFilesResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          description: 'List of drive files',
          items: {
            $ref: '#/components/schemas/DriveFile',
          },
        },
      },
    },
  ],
} as const;

export const UpsertDriveFileResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/DriveFile',
        },
      },
    },
  ],
} as const;

export const DeleteDriveFileRequestSchema = {
  type: 'object',
  required: ['fileId'],
  properties: {
    fileId: {
      type: 'string',
      description: 'Drive file ID',
    },
  },
} as const;

export const SendEmailRequestSchema = {
  type: 'object',
  required: ['subject', 'html'],
  properties: {
    subject: {
      type: 'string',
      description: 'Email subject',
    },
    html: {
      type: 'string',
      description: 'Email HTML content',
    },
    to: {
      type: 'string',
      description: 'Email recipient. If not specified, the email will be sent to current user.',
    },
    from: {
      type: 'string',
      description: 'Email sender. If not specified, server will use the default sender.',
    },
    attachments: {
      type: 'array',
      description: 'Email attachments, should be array of URLs.',
      items: {
        type: 'string',
      },
    },
  },
} as const;

export const GenerateAppTemplateRequestSchema = {
  type: 'object',
  required: ['canvasId'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID to generate template for',
      pattern: '^[a-zA-Z0-9_-]+$',
      example: 'canvas-123',
    },
  },
} as const;

export const AppTemplateResultSchema = {
  type: 'object',
  required: ['templateContent', 'variables', 'metadata'],
  properties: {
    templateContent: {
      type: 'string',
      description: `Template with placeholders for user interaction.
Variables are represented using handlebars syntax (e.g., {{variableName}}).
`,
      example:
        'Create a {{workflowType}} workflow with {{variableCount}} variables including {{primarySkill}} functionality',
    },
    variables: {
      type: 'array',
      description: 'List of related workflow variables used in the template',
      items: {
        $ref: '#/components/schemas/WorkflowVariable',
      },
    },
    metadata: {
      type: 'object',
      required: ['extractedAt', 'variableCount'],
      properties: {
        extractedAt: {
          type: 'number',
          description: 'Template generation timestamp (for version control)',
          example: 1703123456789,
        },
        variableCount: {
          type: 'number',
          description: 'Total variable count (for frontend statistics display)',
          example: 5,
        },
        promptCount: {
          type: 'number',
          description: 'Original prompt count (for quality assessment)',
          example: 3,
        },
        canvasComplexity: {
          type: 'string',
          description: 'Canvas complexity level',
          enum: ['simple', 'medium', 'complex'],
          example: 'medium',
        },
        workflowType: {
          type: 'string',
          description: 'Workflow type (for template classification and display)',
          example: 'data-processing',
        },
        templateVersion: {
          type: 'number',
          description: 'Template version number (supports template iteration)',
          example: 1,
        },
        workflowTitle: {
          type: 'string',
          description: 'Workflow title for display',
          example: 'Data Processing Pipeline',
        },
        workflowDescription: {
          type: 'string',
          description: 'Workflow description',
          example: 'Automated data processing workflow',
        },
        estimatedExecutionTime: {
          type: 'string',
          description: 'Estimated execution time',
          example: '5-10 minutes',
        },
        skillTags: {
          type: 'array',
          description: 'Skill tags for categorization',
          items: {
            type: 'string',
          },
          example: ['data-processing', 'automation'],
        },
      },
    },
  },
} as const;

export const FormDefinitionSchema = {
  type: 'object',
  required: ['formId', 'title', 'schema', 'createdAt', 'updatedAt'],
  properties: {
    formId: {
      type: 'string',
      description: 'Form ID',
      example: 'form-123',
    },
    title: {
      type: 'string',
      description: 'Form title',
      example: 'User feedback survey',
    },
    description: {
      type: 'string',
      description: 'Form description',
      example: 'Please fill out the following survey',
    },
    schema: {
      type: 'string',
      description: 'JSON Schema definition (RJSF compatible)',
      example:
        '{"type":"object","properties":{"feedback":{"type":"string","title":"Feedback content"}},"required":["feedback"]}',
    },
    uiSchema: {
      type: 'string',
      description:
        'UI Schema definition (RJSF compatible for controlling UI elements like emoji, layout, helper text)',
      example:
        '{"feedback":{"ui:widget":"textarea","ui:placeholder":"Please enter your feedback"}}',
    },
    status: {
      type: 'string',
      description: 'Form status',
      enum: ['draft', 'published', 'archived'],
      default: 'draft',
      example: 'published',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Creation timestamp',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Last update timestamp',
    },
    deletedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Soft delete timestamp',
    },
  },
} as const;

export const FormSubmissionSchema = {
  type: 'object',
  required: ['formId', 'uid', 'answers', 'createdAt', 'updatedAt'],
  properties: {
    submissionId: {
      type: 'string',
      description: 'Submission ID',
      example: 'sub-456',
    },
    formId: {
      type: 'string',
      description: 'Associated form ID',
      example: 'form-123',
    },
    uid: {
      type: 'string',
      description: 'User ID who submitted the form',
      example: 'user-789',
    },
    answers: {
      type: 'string',
      description: 'Submission answers (JSON object with field values)',
      example: '{"feedback":"The service is very good","rating":5}',
    },
    status: {
      type: 'string',
      description: 'Submission status',
      enum: ['draft', 'submitted', 'reviewed'],
      default: 'draft',
      example: 'submitted',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Creation timestamp',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Last update timestamp',
    },
  },
} as const;

export const FormFieldSchemaSchema = {
  type: 'object',
  description: 'RJSF compatible field schema definition',
  properties: {
    type: {
      type: 'string',
      description: 'Field type',
      enum: ['string', 'number', 'integer', 'boolean', 'object', 'array'],
      example: 'string',
    },
    title: {
      type: 'string',
      description: 'Field display title',
      example: 'Your name',
    },
    description: {
      type: 'string',
      description: 'Field description/helper text',
      example: 'Please enter your real name',
    },
    enum: {
      type: 'array',
      description: 'Enumeration values for radio/select fields',
      items: {
        type: 'string',
      },
      example: ['A', 'B', 'C'],
    },
    enumNames: {
      type: 'array',
      description: 'Display names for enum values',
      items: {
        type: 'string',
      },
      example: ['Excellent', 'Good', 'Average'],
    },
    default: {
      description: 'Default value for the field',
    },
    minLength: {
      type: 'integer',
      description: 'Minimum string length',
      example: 2,
    },
    maxLength: {
      type: 'integer',
      description: 'Maximum string length',
      example: 100,
    },
    pattern: {
      type: 'string',
      description: 'Regex pattern for validation',
      example: '^[a-zA-Z0-9]+$',
    },
    minimum: {
      type: 'number',
      description: 'Minimum numeric value',
    },
    maximum: {
      type: 'number',
      description: 'Maximum numeric value',
    },
    required: {
      type: 'boolean',
      description: 'Whether this field is required',
      default: false,
    },
  },
} as const;

export const FormUiSchemaSchema = {
  type: 'object',
  description: 'RJSF UI schema for controlling form appearance and behavior',
  properties: {
    'ui:widget': {
      type: 'string',
      description: 'Widget type override',
      enum: [
        'text',
        'textarea',
        'select',
        'radio',
        'checkbox',
        'checkboxes',
        'date',
        'email',
        'password',
      ],
      example: 'textarea',
    },
    'ui:placeholder': {
      type: 'string',
      description: 'Input placeholder text',
      example: 'Please enter content...',
    },
    'ui:help': {
      type: 'string',
      description: 'Help text displayed below the field',
      example: 'This field is required',
    },
    'ui:options': {
      type: 'object',
      description: 'Widget-specific options (can include emoji, layout settings, etc.)',
      properties: {
        emoji: {
          type: 'string',
          description: 'Emoji to display with the field',
          example: '',
        },
        layout: {
          type: 'string',
          description: 'Layout style',
          enum: ['horizontal', 'vertical'],
          example: 'vertical',
        },
        rows: {
          type: 'integer',
          description: 'Number of rows for textarea',
          example: 4,
        },
        inline: {
          type: 'boolean',
          description: 'Whether to display radio/checkbox options inline',
          example: true,
        },
      },
    },
  },
} as const;

export const BillingTypeSchema = {
  type: 'string',
  enum: ['per_call', 'per_quantity'],
  description: 'Type of billing for a tool method',
} as const;

export const BillingConfigSchema = {
  type: 'object',
  required: ['enabled', 'type'],
  properties: {
    enabled: {
      type: 'boolean',
      description: 'Whether billing is enabled',
    },
    type: {
      $ref: '#/components/schemas/BillingType',
    },
    creditsPerCall: {
      type: 'number',
      description: 'Credits per call (for PER_CALL type)',
    },
    creditsPerUnit: {
      type: 'number',
      description: 'Credits per unit (for PER_QUANTITY type)',
    },
    quantityField: {
      type: 'string',
      description: 'Field name to extract quantity from (for PER_QUANTITY type)',
    },
    maxCredits: {
      type: 'number',
      description: 'Maximum credits per single call',
    },
    quantityTransform: {
      type: 'string',
      description: 'Transform function name for custom quantity calculation',
    },
  },
} as const;

export const SchemaPropertyTypeSchema = {
  type: 'string',
  enum: ['string', 'number', 'boolean', 'object', 'array'],
  description: 'JSON Schema property type',
} as const;

export const ToolResourceTypeSchema = {
  type: 'string',
  enum: ['audio', 'video', 'image', 'document'],
  description: 'Resource type for tool operations (subset of ResourceType)',
} as const;

export const SchemaPropertySchema = {
  type: 'object',
  required: ['type'],
  properties: {
    type: {
      $ref: '#/components/schemas/SchemaPropertyType',
    },
    description: {
      type: 'string',
      description: 'Property description',
    },
    isResource: {
      type: 'boolean',
      description: 'Whether this property is a resource reference',
    },
    format: {
      type: 'string',
      description:
        'Format for the property value. For resources: base64, url, binary, text. For strings: date-time, uri, email, etc.',
      example: 'binary',
    },
    file_uploadable: {
      type: 'boolean',
      description: 'Whether this field accepts file uploads (Composio-specific marker)',
    },
    const: {
      description: 'Constant value for discriminator matching in oneOf/anyOf',
    },
    oneOf: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/SchemaProperty',
      },
      description: 'One of the listed schemas must match',
    },
    anyOf: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/SchemaProperty',
      },
      description: 'Any of the listed schemas can match',
    },
    minLength: {
      type: 'number',
      description: 'Minimum length (for string)',
    },
    maxLength: {
      type: 'number',
      description: 'Maximum length (for string)',
    },
    min: {
      type: 'number',
      description: 'Minimum value (for number)',
    },
    max: {
      type: 'number',
      description: 'Maximum value (for number)',
    },
    enum: {
      type: 'array',
      items: {
        type: 'string',
      },
      description: 'Enum values',
    },
    default: {
      description: 'Default value',
    },
    optional: {
      type: 'boolean',
      description: 'Whether this property is optional',
    },
    properties: {
      type: 'object',
      additionalProperties: {
        $ref: '#/components/schemas/SchemaProperty',
      },
      description: 'Nested properties (for object type)',
    },
    items: {
      $ref: '#/components/schemas/SchemaProperty',
    },
    required: {
      type: 'array',
      items: {
        type: 'string',
      },
      description: 'Required properties (for object type)',
    },
  },
} as const;

export const JsonSchemaSchema = {
  type: 'object',
  description: 'JSON schema definition for request/response with resource field markers',
  required: ['type', 'properties'],
  properties: {
    type: {
      type: 'string',
      enum: ['object'],
      description: 'Schema type',
    },
    properties: {
      type: 'object',
      additionalProperties: {
        $ref: '#/components/schemas/SchemaProperty',
      },
      description: 'Schema properties',
    },
    required: {
      type: 'array',
      items: {
        type: 'string',
      },
      description: 'Required property names',
    },
    omitFields: {
      type: 'array',
      items: {
        type: 'string',
      },
      description: "Field names to omit from the response (e.g., ['thoughtSignature'])",
    },
  },
} as const;

export const ResponseSchemaSchema = {
  $ref: '#/components/schemas/JsonSchema',
} as const;

export const ResourceFieldSchema = {
  type: 'object',
  required: ['fieldPath', 'isArray'],
  properties: {
    fieldPath: {
      type: 'string',
      description: 'JSONPath to the resource field',
    },
    type: {
      $ref: '#/components/schemas/ToolResourceType',
      description: 'Resource type hint (optional, can be inferred from file MIME type)',
    },
    isArray: {
      type: 'boolean',
      description: 'Whether this field is an array of resources',
    },
    format: {
      type: 'string',
      description:
        'Format to convert resource content to (default is binary). Options: base64, url, binary, text',
      example: 'binary',
    },
  },
} as const;

export const HttpMethodSchema = {
  type: 'string',
  enum: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH'],
  description: 'HTTP method',
} as const;

export const ToolMethodConfigSchema = {
  type: 'object',
  required: ['name', 'description', 'endpoint', 'schema', 'responseSchema'],
  properties: {
    name: {
      type: 'string',
      description: "Method name (e.g., 'text_to_speech')",
    },
    version: {
      type: 'number',
      description: 'Version number (incremental integer, derived from pk or timestamp)',
    },
    displayName: {
      type: 'string',
      description: 'Human-readable display name',
    },
    description: {
      type: 'string',
      description: 'Method description for LLM',
    },
    endpoint: {
      type: 'string',
      description: 'API endpoint URL',
    },
    method: {
      $ref: '#/components/schemas/HttpMethod',
    },
    schema: {
      type: 'string',
      description: 'Input parameter schema (JSON string)',
    },
    responseSchema: {
      type: 'string',
      description: 'Response schema for resource identification (JSON string)',
    },
    billing: {
      $ref: '#/components/schemas/BillingConfig',
    },
    customHandler: {
      type: 'string',
      description: 'Custom handler class name (optional)',
    },
    useSdk: {
      type: 'boolean',
      description: 'Whether to use SDK instead of HTTP (optional)',
    },
    sdkPackage: {
      type: 'string',
      description: 'SDK package name (if useSdk is true)',
    },
    sdkMethod: {
      type: 'string',
      description: "SDK method path (e.g., 'client.textToSpeech.convert')",
    },
    timeout: {
      type: 'number',
      description: 'Request timeout in milliseconds',
    },
    maxRetries: {
      type: 'number',
      description: 'Maximum retries on failure',
    },
  },
} as const;

export const CredentialConfigSchema = {
  type: 'object',
  additionalProperties: {
    type: 'string',
  },
  properties: {
    apiKey: {
      type: 'string',
      description: 'API key',
    },
    apiSecret: {
      type: 'string',
      description: 'API secret',
    },
    accessToken: {
      type: 'string',
      description: 'OAuth access token',
    },
    refreshToken: {
      type: 'string',
      description: 'OAuth refresh token',
    },
  },
  description: 'Credential configuration',
} as const;

export const ToolsetConfigSchema = {
  type: 'object',
  required: ['inventoryKey', 'domain', 'methods'],
  properties: {
    inventoryKey: {
      type: 'string',
      description: "Toolset inventory key (e.g., 'fish_audio', 'heygen')",
    },
    domain: {
      type: 'string',
      description: "Tool domain (e.g., 'fish.audio')",
    },
    name: {
      type: 'string',
      description: 'Display name',
    },
    credentials: {
      $ref: '#/components/schemas/CredentialConfig',
    },
    methods: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/ToolMethodConfig',
      },
      description: 'Tool methods',
    },
    version: {
      type: 'number',
      description: 'Configuration version',
    },
    metadata: {
      type: 'object',
      additionalProperties: true,
      description: 'Configuration metadata',
    },
  },
} as const;

export const ParsedMethodConfigSchema = {
  type: 'object',
  required: ['name', 'description', 'endpoint', 'schema', 'responseSchema'],
  properties: {
    name: {
      type: 'string',
      description: 'Method name',
    },
    version: {
      type: 'number',
      description: 'Version number',
    },
    displayName: {
      type: 'string',
      description: 'Human-readable display name',
    },
    description: {
      type: 'string',
      description: 'Method description for LLM',
    },
    endpoint: {
      type: 'string',
      description: 'API endpoint URL',
    },
    method: {
      $ref: '#/components/schemas/HttpMethod',
    },
    schema: {
      $ref: '#/components/schemas/JsonSchema',
    },
    responseSchema: {
      $ref: '#/components/schemas/JsonSchema',
    },
    billing: {
      $ref: '#/components/schemas/BillingConfig',
    },
    customHandler: {
      type: 'string',
      description: 'Custom handler class name',
    },
    useSdk: {
      type: 'boolean',
      description: 'Whether to use SDK instead of HTTP',
    },
    sdkPackage: {
      type: 'string',
      description: 'SDK package name',
    },
    sdkMethod: {
      type: 'string',
      description: 'SDK method path',
    },
    timeout: {
      type: 'number',
      description: 'Request timeout in milliseconds',
    },
    maxRetries: {
      type: 'number',
      description: 'Maximum retries on failure',
    },
    useFormData: {
      type: 'boolean',
      description: 'Whether to use multipart/form-data encoding',
    },
  },
} as const;

export const ParsedToolsetConfigSchema = {
  type: 'object',
  required: ['inventoryKey', 'domain', 'methods'],
  properties: {
    inventoryKey: {
      type: 'string',
      description: "Toolset inventory key (e.g., 'fish_audio', 'heygen')",
    },
    domain: {
      type: 'string',
      description: 'Tool domain',
    },
    name: {
      type: 'string',
      description: 'Display name',
    },
    credentials: {
      $ref: '#/components/schemas/CredentialConfig',
    },
    methods: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/ParsedMethodConfig',
      },
      description: 'Parsed methods with JSON schemas',
    },
    version: {
      type: 'number',
      description: 'Configuration version',
    },
    metadata: {
      type: 'object',
      additionalProperties: true,
      description: 'Configuration metadata',
    },
  },
} as const;

export const ConfigChangeEventSchema = {
  type: 'object',
  required: ['toolsetKey', 'md5', 'config', 'timestamp'],
  properties: {
    toolsetKey: {
      type: 'string',
      description: 'Toolset key',
    },
    md5: {
      type: 'string',
      description: 'Configuration MD5 hash',
    },
    config: {
      $ref: '#/components/schemas/ToolsetConfig',
    },
    timestamp: {
      type: 'string',
      format: 'date-time',
      description: 'Event timestamp',
    },
  },
} as const;

export const AdapterRequestSchema = {
  type: 'object',
  required: ['endpoint', 'params'],
  properties: {
    endpoint: {
      type: 'string',
      description: 'API endpoint or SDK method path',
    },
    method: {
      $ref: '#/components/schemas/HttpMethod',
    },
    params: {
      type: 'object',
      additionalProperties: true,
      description: 'Request parameters',
    },
    headers: {
      type: 'object',
      additionalProperties: {
        type: 'string',
      },
      description: 'Request headers (for HTTP adapter)',
    },
    credentials: {
      type: 'object',
      additionalProperties: true,
      description: 'Credentials for authentication',
    },
    timeout: {
      type: 'number',
      description: 'Request timeout in milliseconds',
    },
    useFormData: {
      type: 'boolean',
      description: 'Whether to use multipart/form-data (for HTTP adapter)',
    },
  },
} as const;

export const AdapterResponseSchema = {
  type: 'object',
  required: ['data'],
  properties: {
    data: {
      description: 'Response data',
    },
    status: {
      type: 'number',
      description: 'HTTP status code (for HTTP adapter)',
    },
    headers: {
      type: 'object',
      additionalProperties: {
        type: 'string',
      },
      description: 'Response headers (for HTTP adapter)',
    },
    raw: {
      description: 'Raw response body (for debugging)',
    },
  },
} as const;

export const HttpAdapterConfigSchema = {
  type: 'object',
  properties: {
    baseUrl: {
      type: 'string',
      description: 'Base URL for the API',
    },
    defaultHeaders: {
      type: 'object',
      additionalProperties: {
        type: 'string',
      },
      description: 'Default headers',
    },
    timeout: {
      type: 'number',
      description: 'Request timeout in milliseconds',
    },
    maxRetries: {
      type: 'number',
      description: 'Maximum retries',
    },
    retryDelay: {
      type: 'number',
      description: 'Retry delay in milliseconds',
    },
    proxy: {
      type: 'string',
      description: 'HTTP proxy URL',
    },
    polling: {
      $ref: '#/components/schemas/PollingConfig',
      description: 'Polling configuration for async task tracking',
    },
  },
} as const;

export const PollingConfigSchema = {
  type: 'object',
  required: ['statusUrl'],
  properties: {
    statusUrl: {
      type: 'string',
      description:
        'Status check endpoint template (e.g., "/v1/tasks/{id}" or "/v1/video_status.get?video_id={id}")',
    },
    statusMethod: {
      type: 'string',
      enum: ['GET', 'POST'],
      default: 'GET',
      description: 'HTTP method for status check (GET or POST)',
    },
    statusBody: {
      type: 'object',
      additionalProperties: true,
      description:
        'Request body template for POST status check. Supports placeholders like {task_id}, {req_key}',
    },
    taskIdPath: {
      type: 'string',
      description: 'JSON path to extract task ID from initial response (e.g., "data.task_id")',
    },
    statusPath: {
      type: 'string',
      description: 'JSON path to extract status from polling response (e.g., "data.status")',
    },
    resultPath: {
      type: 'string',
      description:
        'JSON path to extract result data from completed response (e.g., "data.resp_data")',
    },
    completedStatuses: {
      type: 'array',
      items: {
        type: 'string',
      },
      description: 'List of status values indicating completion (e.g., ["done", "completed"])',
    },
    failedStatuses: {
      type: 'array',
      items: {
        type: 'string',
      },
      description: 'List of status values indicating failure (e.g., ["failed", "error"])',
    },
    maxWaitSeconds: {
      type: 'number',
      description: 'Maximum wait time in seconds',
      default: 300,
    },
    intervalSeconds: {
      type: 'number',
      description: 'Poll interval in seconds',
      default: 5,
    },
  },
} as const;

export const SdkAdapterConfigSchema = {
  type: 'object',
  required: ['packageName', 'methodPath'],
  properties: {
    packageName: {
      type: 'string',
      description: 'NPM package name',
    },
    methodPath: {
      type: 'string',
      description: "Method path in the SDK (e.g., 'client.textToSpeech.convert')",
    },
    clientFactory: {
      description: 'SDK client initialization function (runtime only, not serializable)',
    },
    paramTransformer: {
      description: 'Parameter transformer function (runtime only, not serializable)',
    },
  },
} as const;

export const RetryConfigSchema = {
  type: 'object',
  required: ['maxRetries', 'initialDelay', 'maxDelay', 'backoffMultiplier'],
  properties: {
    maxRetries: {
      type: 'number',
      description: 'Maximum number of retries',
    },
    initialDelay: {
      type: 'number',
      description: 'Initial retry delay in milliseconds',
    },
    maxDelay: {
      type: 'number',
      description: 'Maximum retry delay in milliseconds',
    },
    backoffMultiplier: {
      type: 'number',
      description: 'Backoff multiplier',
    },
    retryableStatusCodes: {
      type: 'array',
      items: {
        type: 'number',
      },
      description: 'Status codes that should trigger a retry',
    },
    retryableErrorCodes: {
      type: 'array',
      items: {
        type: 'string',
      },
      description: 'Error codes that should trigger a retry',
    },
  },
} as const;

export const CircuitBreakerStateSchema = {
  type: 'string',
  enum: ['closed', 'open', 'half_open'],
  description: 'Circuit breaker state',
} as const;

export const CircuitBreakerConfigSchema = {
  type: 'object',
  required: ['failureThreshold', 'successThreshold', 'timeout', 'rollingWindowSize'],
  properties: {
    failureThreshold: {
      type: 'number',
      description: 'Failure threshold to open the circuit',
    },
    successThreshold: {
      type: 'number',
      description: 'Success threshold to close the circuit from half-open',
    },
    timeout: {
      type: 'number',
      description: 'Timeout in milliseconds before attempting to close',
    },
    rollingWindowSize: {
      type: 'number',
      description: 'Rolling window size for failure counting',
    },
  },
} as const;

export const HandlerRequestSchema = {
  type: 'object',
  required: ['provider', 'method', 'params'],
  properties: {
    provider: {
      type: 'string',
      description: 'Provider/toolset identifier',
    },
    method: {
      type: 'string',
      description: 'Method name',
    },
    params: {
      type: 'object',
      additionalProperties: true,
      description: 'Input parameters',
    },
    user: {
      $ref: '#/components/schemas/User',
    },
    metadata: {
      type: 'object',
      additionalProperties: true,
      description: 'Request metadata',
    },
  },
} as const;

export const UploadResultMetadataSchema = {
  type: 'object',
  properties: {
    size: {
      type: 'number',
      description: 'File size in bytes',
    },
    mimeType: {
      type: 'string',
      description: 'MIME type',
    },
    duration: {
      type: 'number',
      description: 'Duration (for audio/video)',
    },
    width: {
      type: 'number',
      description: 'Width (for images/video)',
    },
    height: {
      type: 'number',
      description: 'Height (for images/video)',
    },
    format: {
      type: 'string',
      description: 'File format',
    },
  },
} as const;

export const UploadResultSchema = {
  type: 'object',
  required: ['fileId', 'resourceType'],
  properties: {
    fileId: {
      type: 'string',
      description: 'File ID in database (DriveService)',
    },
    resourceType: {
      $ref: '#/components/schemas/ToolResourceType',
    },
    metadata: {
      $ref: '#/components/schemas/UploadResultMetadata',
    },
  },
} as const;

export const HandlerResponseSchema = {
  type: 'object',
  required: ['success'],
  properties: {
    success: {
      type: 'boolean',
      description: 'Success status',
    },
    data: {
      oneOf: [
        {
          type: 'object',
          additionalProperties: true,
        },
        {
          type: 'array',
          items: {
            type: 'object',
            additionalProperties: true,
          },
        },
      ],
      description: 'Response data (object or array of objects)',
    },
    localPath: {
      type: 'string',
      description: 'Local file path (if file was saved)',
    },
    storageKey: {
      type: 'string',
      description: 'Storage key (if file was uploaded)',
    },
    entityId: {
      type: 'string',
      description: 'Entity ID (if resource was created)',
    },
    fileId: {
      type: 'string',
      description: 'File ID in database',
    },
    files: {
      type: 'array',
      description: 'List of drive files generated by the tool',
      items: {
        $ref: '#/components/schemas/DriveFile',
      },
    },
    url: {
      type: 'string',
      description: 'CDN/public URL',
    },
    error: {
      type: 'string',
      description: 'Error information',
    },
    errorCode: {
      type: 'string',
      description: 'Error code',
    },
    metadata: {
      type: 'object',
      additionalProperties: true,
      description: 'Response metadata',
    },
  },
} as const;

export const HandlerContextSchema = {
  type: 'object',
  required: ['startTime'],
  properties: {
    user: {
      $ref: '#/components/schemas/User',
      description: 'User information for billing and tracking',
    },
    credentials: {
      type: 'object',
      additionalProperties: true,
      description: 'Credentials for authentication',
    },
    responseSchema: {
      $ref: '#/components/schemas/JsonSchema',
      description: 'Response schema for identifying resource fields via traversal',
    },
    startTime: {
      type: 'number',
      description: 'Request start timestamp',
    },
  },
} as const;

export const HandlerConfigSchema = {
  type: 'object',
  required: ['endpoint'],
  properties: {
    endpoint: {
      type: 'string',
      description: 'API endpoint URL',
    },
    method: {
      $ref: '#/components/schemas/HttpMethod',
    },
    credentials: {
      type: 'object',
      additionalProperties: true,
      description: 'Credentials',
    },
    responseSchema: {
      $ref: '#/components/schemas/JsonSchema',
      description: 'Response schema for identifying resource fields via traversal',
    },
    timeout: {
      type: 'number',
      description: 'Request timeout (ms)',
    },
    maxRetries: {
      type: 'number',
      description: 'Maximum retries',
    },
    useFormData: {
      type: 'boolean',
      description: 'Whether to use multipart/form-data',
    },
  },
} as const;

export const FileMetadataSchema = {
  type: 'object',
  required: ['entityId', 'storageKey', 'type', 'visibility'],
  properties: {
    entityId: {
      type: 'string',
      description: 'Entity ID',
    },
    storageKey: {
      type: 'string',
      description: 'Storage key',
    },
    type: {
      type: 'string',
      description: 'File type',
    },
    mimeType: {
      type: 'string',
      description: 'MIME type',
    },
    visibility: {
      type: 'string',
      enum: ['public', 'private'],
      description: 'Visibility',
    },
    size: {
      type: 'number',
      description: 'File size in bytes',
    },
    metadata: {
      type: 'object',
      additionalProperties: true,
      description: 'Additional metadata',
    },
  },
} as const;

export const UploadMetadataSchema = {
  type: 'object',
  required: ['provider', 'method', 'type'],
  properties: {
    provider: {
      type: 'string',
      description: 'Provider name',
    },
    method: {
      type: 'string',
      description: 'Method name',
    },
    type: {
      $ref: '#/components/schemas/ToolResourceType',
    },
    mimeType: {
      type: 'string',
      description: 'MIME type',
    },
    userId: {
      type: 'string',
      description: 'User ID',
    },
  },
} as const;

export const HandlerExecutionResultSchema = {
  type: 'object',
  required: ['success'],
  properties: {
    success: {
      type: 'boolean',
      description: 'Success status',
    },
    data: {
      description: 'Result data',
    },
    error: {
      type: 'object',
      properties: {
        code: {
          type: 'string',
          description: 'Error code',
        },
        message: {
          type: 'string',
          description: 'Error message',
        },
        details: {
          type: 'object',
          additionalProperties: true,
          description: 'Error details',
        },
      },
    },
    metrics: {
      type: 'object',
      properties: {
        duration: {
          type: 'number',
          description: 'Execution duration in milliseconds',
        },
        retries: {
          type: 'number',
          description: 'Number of retries',
        },
      },
    },
  },
} as const;

export const ToolMetadataBillingSchema = {
  type: 'object',
  required: ['enabled', 'type'],
  properties: {
    enabled: {
      type: 'boolean',
      description: 'Whether billing is enabled',
    },
    type: {
      type: 'string',
      enum: ['per_call', 'per_quantity'],
      description: 'Billing type',
    },
    creditsPerCall: {
      type: 'number',
      description: 'Credits per call',
    },
    creditsPerUnit: {
      type: 'number',
      description: 'Credits per unit',
    },
  },
} as const;

export const ToolMetadataSchema = {
  type: 'object',
  required: ['version', 'toolsetKey', 'methodName'],
  properties: {
    version: {
      type: 'number',
      description: 'Version number (incremental integer for version tracking)',
    },
    toolsetKey: {
      type: 'string',
      description: 'Toolset key',
    },
    methodName: {
      type: 'string',
      description: 'Method name',
    },
    billing: {
      $ref: '#/components/schemas/ToolMetadataBilling',
    },
    resourceTypes: {
      type: 'array',
      items: {
        type: 'string',
      },
      description: 'Resource types handled by this tool',
    },
    resourceExtensions: {
      type: 'object',
      additionalProperties: {
        type: 'array',
        items: {
          type: 'string',
        },
      },
      description: 'Supported file extensions for each resource type',
    },
  },
} as const;

export const ToolInstantiationContextUserSchema = {
  type: 'object',
  required: ['uid'],
  properties: {
    uid: {
      type: 'string',
      description: 'User ID',
    },
    name: {
      type: 'string',
      description: 'User name',
    },
    email: {
      type: 'string',
      description: 'User email',
    },
  },
} as const;

export const ToolInstantiationContextSchema = {
  type: 'object',
  required: ['user', 'toolsetId'],
  properties: {
    user: {
      $ref: '#/components/schemas/ToolInstantiationContextUser',
    },
    toolsetId: {
      type: 'string',
      description: 'Toolset ID',
    },
    configId: {
      type: 'string',
      description: 'Configuration ID (for versioned configs)',
    },
    metadata: {
      type: 'object',
      additionalProperties: true,
      description: 'Additional context',
    },
  },
} as const;

export const ToolExecutionContextUserSchema = {
  type: 'object',
  required: ['uid'],
  properties: {
    uid: {
      type: 'string',
      description: 'User ID',
    },
    name: {
      type: 'string',
      description: 'User name',
    },
    email: {
      type: 'string',
      description: 'User email',
    },
  },
} as const;

export const ToolExecutionContextSchema = {
  type: 'object',
  required: ['user'],
  properties: {
    user: {
      $ref: '#/components/schemas/ToolExecutionContextUser',
    },
    parentResultId: {
      type: 'string',
      description: 'Parent result ID (for workflow chaining)',
    },
    actionStepPk: {
      type: 'number',
      description: 'Action step PK (for workflow tracking)',
    },
    canvasNodeId: {
      type: 'string',
      description: 'Canvas node ID',
    },
    metadata: {
      type: 'object',
      additionalProperties: true,
      description: 'Additional metadata',
    },
  },
} as const;

export const ToolExecutionResultSchema = {
  type: 'object',
  required: ['success'],
  properties: {
    success: {
      type: 'boolean',
      description: 'Success status',
    },
    data: {
      description: 'Result data',
    },
    error: {
      type: 'object',
      properties: {
        code: {
          type: 'string',
          description: 'Error code',
        },
        message: {
          type: 'string',
          description: 'Error message',
        },
        details: {
          type: 'object',
          additionalProperties: true,
          description: 'Error details',
        },
      },
    },
    metrics: {
      type: 'object',
      properties: {
        duration: {
          type: 'number',
          description: 'Execution duration in milliseconds',
        },
        creditsCost: {
          type: 'number',
          description: 'Credits cost',
        },
      },
    },
  },
} as const;

export const DynamicToolDefinitionSchema = {
  type: 'object',
  required: ['name', 'description', 'metadata'],
  properties: {
    name: {
      type: 'string',
      description: 'Tool name (unique identifier)',
    },
    description: {
      type: 'string',
      description: 'Tool description for LLM',
    },
    schema: {
      description: 'Zod schema for parameters (runtime only, not serializable)',
    },
    metadata: {
      $ref: '#/components/schemas/ToolMetadata',
    },
  },
} as const;

export const InstantiatedToolSchema = {
  type: 'object',
  required: ['metadata'],
  properties: {
    tool: {
      description: 'LangChain DynamicStructuredTool instance (runtime only, not serializable)',
    },
    metadata: {
      $ref: '#/components/schemas/ToolMetadata',
    },
    configVersion: {
      type: 'number',
      description: 'Configuration version',
    },
  },
} as const;

export const ToolCacheEntrySchema = {
  type: 'object',
  required: ['configHash', 'timestamp', 'expiresAt'],
  properties: {
    configHash: {
      type: 'string',
      description: 'Configuration MD5 hash',
    },
    timestamp: {
      type: 'string',
      format: 'date-time',
      description: 'Cache timestamp',
    },
    expiresAt: {
      type: 'string',
      format: 'date-time',
      description: 'Cache expiration time',
    },
  },
} as const;

export const ToolRegistryEntrySchema = {
  type: 'object',
  required: ['toolsetKey', 'definitions', 'configVersion', 'updatedAt'],
  properties: {
    toolsetKey: {
      type: 'string',
      description: 'Toolset key',
    },
    definitions: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/DynamicToolDefinition',
      },
      description: 'Tool definitions',
    },
    configVersion: {
      type: 'number',
      description: 'Configuration version',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Last update timestamp',
    },
  },
} as const;

export const VoucherStatusSchema = {
  type: 'string',
  enum: ['unused', 'used', 'expired', 'invalid'],
  description: 'Voucher status',
} as const;

export const VoucherSourceSchema = {
  type: 'string',
  enum: ['template_publish', 'invitation_claim'],
  description: 'Voucher source',
} as const;

export const InvitationStatusSchema = {
  type: 'string',
  enum: ['unclaimed', 'claimed', 'expired'],
  description: 'Invitation status',
} as const;

export const VoucherSchema = {
  type: 'object',
  required: [
    'voucherId',
    'uid',
    'discountPercent',
    'status',
    'source',
    'expiresAt',
    'createdAt',
    'updatedAt',
  ],
  properties: {
    voucherId: {
      type: 'string',
      description: 'Unique voucher ID',
    },
    uid: {
      type: 'string',
      description: 'User ID who owns the voucher',
    },
    discountPercent: {
      type: 'number',
      description: 'Discount percentage (10-90)',
    },
    status: {
      $ref: '#/components/schemas/VoucherStatus',
    },
    source: {
      $ref: '#/components/schemas/VoucherSource',
    },
    sourceId: {
      type: 'string',
      description: 'Source entity ID (template ID or invitation ID)',
    },
    llmScore: {
      type: 'number',
      description: 'LLM scoring result (0-100)',
    },
    expiresAt: {
      type: 'string',
      format: 'date-time',
      description: 'Voucher expiration time',
    },
    usedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Voucher usage time',
    },
    subscriptionId: {
      type: 'string',
      description: 'Subscription ID if voucher was used',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Creation timestamp',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Update timestamp',
    },
  },
} as const;

export const VoucherInvitationSchema = {
  type: 'object',
  required: [
    'invitationId',
    'inviterUid',
    'inviteCode',
    'voucherId',
    'discountPercent',
    'status',
    'rewardGranted',
    'createdAt',
    'updatedAt',
  ],
  properties: {
    invitationId: {
      type: 'string',
      description: 'Unique invitation ID',
    },
    inviterUid: {
      type: 'string',
      description: 'Inviter user ID',
    },
    inviteeUid: {
      type: 'string',
      description: 'Invitee user ID',
    },
    inviteCode: {
      type: 'string',
      description: 'Short invitation code for sharing',
    },
    voucherId: {
      type: 'string',
      description: 'Source voucher ID',
    },
    discountPercent: {
      type: 'number',
      description: 'Discount percentage',
    },
    status: {
      $ref: '#/components/schemas/InvitationStatus',
    },
    claimedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Claim timestamp',
    },
    rewardGranted: {
      type: 'boolean',
      description: 'Whether inviter reward has been granted',
    },
    createdAt: {
      type: 'string',
      format: 'date-time',
      description: 'Creation timestamp',
    },
    updatedAt: {
      type: 'string',
      format: 'date-time',
      description: 'Update timestamp',
    },
  },
} as const;

export const VoucherTriggerResultSchema = {
  type: 'object',
  required: ['voucher', 'score'],
  properties: {
    voucher: {
      $ref: '#/components/schemas/Voucher',
    },
    score: {
      type: 'number',
      description: 'LLM score (0-100)',
    },
    feedback: {
      type: 'string',
      description: 'LLM feedback for improvement',
    },
    triggerLimitReached: {
      type: 'boolean',
      description: 'Whether daily trigger limit was reached',
    },
  },
} as const;

export const VoucherAvailableResultSchema = {
  type: 'object',
  required: ['hasAvailableVoucher', 'vouchers'],
  properties: {
    hasAvailableVoucher: {
      type: 'boolean',
      description: 'Whether user has available vouchers',
    },
    vouchers: {
      type: 'array',
      items: {
        $ref: '#/components/schemas/Voucher',
      },
      description: 'List of available vouchers',
    },
    bestVoucher: {
      $ref: '#/components/schemas/Voucher',
      description: 'Best available voucher (highest discount)',
    },
  },
} as const;

export const VoucherValidateResultSchema = {
  type: 'object',
  required: ['valid'],
  properties: {
    valid: {
      type: 'boolean',
      description: 'Whether voucher is valid',
    },
    voucher: {
      $ref: '#/components/schemas/Voucher',
      description: 'Voucher details',
    },
    reason: {
      type: 'string',
      description: 'Reason if not valid',
    },
  },
} as const;

export const CreateInvitationResultSchema = {
  type: 'object',
  required: ['invitation'],
  properties: {
    invitation: {
      $ref: '#/components/schemas/VoucherInvitation',
      description: 'Created invitation',
    },
  },
} as const;

export const ClaimInvitationResultSchema = {
  type: 'object',
  required: ['success'],
  properties: {
    success: {
      type: 'boolean',
      description: 'Whether claim was successful',
    },
    voucher: {
      $ref: '#/components/schemas/Voucher',
      description: 'Created voucher for invitee',
    },
    inviterName: {
      type: 'string',
      description: 'Name of the user who sent the invitation',
    },
    message: {
      type: 'string',
      description: 'Error message if failed',
    },
  },
} as const;

export const ValidateVoucherRequestSchema = {
  type: 'object',
  required: ['voucherId'],
  properties: {
    voucherId: {
      type: 'string',
      description: 'Voucher ID to validate',
    },
  },
} as const;

export const CreateVoucherInvitationRequestSchema = {
  type: 'object',
  required: ['voucherId'],
  properties: {
    voucherId: {
      type: 'string',
      description: 'Voucher ID to create invitation for',
    },
  },
} as const;

export const ClaimVoucherInvitationRequestSchema = {
  type: 'object',
  required: ['inviteCode'],
  properties: {
    inviteCode: {
      type: 'string',
      description: 'Invitation code to claim',
    },
  },
} as const;

export const GetAvailableVouchersResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/VoucherAvailableResult',
        },
      },
    },
  ],
} as const;

export const ListUserVouchersResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          type: 'array',
          items: {
            $ref: '#/components/schemas/Voucher',
          },
        },
      },
    },
  ],
} as const;

export const ValidateVoucherResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/VoucherValidateResult',
        },
      },
    },
  ],
} as const;

export const CreateVoucherInvitationResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/CreateInvitationResult',
        },
      },
    },
  ],
} as const;

export const VerifyInvitationResultSchema = {
  type: 'object',
  required: ['valid'],
  properties: {
    valid: {
      type: 'boolean',
      description: 'Whether the invitation is valid and can be claimed',
    },
    invitation: {
      $ref: '#/components/schemas/VoucherInvitation',
    },
    voucher: {
      $ref: '#/components/schemas/Voucher',
      description: 'The original voucher being shared (for unclaimed invitations)',
    },
    claimedByUid: {
      type: 'string',
      description: 'If already claimed, the UID of the user who claimed it',
    },
    inviterName: {
      type: 'string',
      description: "Inviter's name (for display)",
    },
    message: {
      type: 'string',
      description: 'Error or status message',
    },
  },
} as const;

export const VerifyVoucherInvitationResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/VerifyInvitationResult',
        },
      },
    },
  ],
} as const;

export const ClaimVoucherInvitationResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/ClaimInvitationResult',
        },
      },
    },
  ],
} as const;

export const TriggerVoucherRequestSchema = {
  type: 'object',
  required: ['canvasId', 'triggerType'],
  properties: {
    canvasId: {
      type: 'string',
      description: 'Canvas ID of the template being published',
    },
    templateId: {
      type: 'string',
      description: 'Optional template ID (defaults to canvasId if not provided)',
    },
    triggerType: {
      type: 'string',
      enum: ['template_publish'],
      description: 'Type of trigger event',
    },
  },
} as const;

export const TriggerVoucherResponseSchema = {
  allOf: [
    {
      $ref: '#/components/schemas/BaseResponse',
    },
    {
      type: 'object',
      properties: {
        data: {
          $ref: '#/components/schemas/VoucherTriggerResult',
        },
      },
    },
  ],
} as const;
